
================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/Executor.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { ReentrancyGuardUpgradeable } from "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";

import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { IUltraLightNode301 } from "./uln/uln301/interfaces/IUltraLightNode301.sol";
import { IExecutor } from "./interfaces/IExecutor.sol";
import { IExecutorFeeLib } from "./interfaces/IExecutorFeeLib.sol";
import { WorkerUpgradeable } from "./upgradeable/WorkerUpgradeable.sol";

interface ILayerZeroEndpointV2 {
    function eid() external view returns (uint32);

    function lzReceive(
        Origin calldata _origin,
        address _receiver,
        bytes32 _guid,
        bytes calldata _message,
        bytes calldata _extraData
    ) external payable;

    function lzReceiveAlert(
        Origin calldata _origin,
        address _receiver,
        bytes32 _guid,
        uint256 _gas,
        uint256 _value,
        bytes calldata _message,
        bytes calldata _extraData,
        bytes calldata _reason
    ) external;

    function lzCompose(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index,
        bytes calldata _message,
        bytes calldata _extraData
    ) external payable;

    function lzComposeAlert(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index,
        uint256 _gas,
        uint256 _value,
        bytes calldata _message,
        bytes calldata _extraData,
        bytes calldata _reason
    ) external;
}

contract Executor is WorkerUpgradeable, ReentrancyGuardUpgradeable, Proxied, IExecutor {
    using PacketV1Codec for bytes;

    mapping(uint32 dstEid => DstConfig) public dstConfig;

    // endpoint v2
    address public endpoint;
    uint32 public localEid;

    // endpoint v1
    address public receiveUln301;

    function initialize(
        address _endpoint,
        address _receiveUln301,
        address[] memory _messageLibs,
        address _priceFeed,
        address _roleAdmin,
        address[] memory _admins
    ) external proxied initializer {
        __ReentrancyGuard_init();
        __Worker_init(_messageLibs, _priceFeed, 12000, _roleAdmin, _admins);
        endpoint = _endpoint;
        localEid = ILayerZeroEndpointV2(_endpoint).eid();
        receiveUln301 = _receiveUln301;
    }

    function onUpgrade(address _receiveUln301) external proxied {
        receiveUln301 = _receiveUln301;
    }

    // --- Admin ---
    function setDstConfig(DstConfigParam[] memory _params) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; i++) {
            DstConfigParam memory param = _params[i];
            dstConfig[param.dstEid] = DstConfig(
                param.lzReceiveBaseGas,
                param.multiplierBps,
                param.floorMarginUSD,
                param.nativeCap,
                param.lzComposeBaseGas
            );
        }
        emit DstConfigSet(_params);
    }

    function nativeDrop(
        Origin calldata _origin,
        uint32 _dstEid,
        address _oapp,
        NativeDropParams[] calldata _nativeDropParams,
        uint256 _nativeDropGasLimit
    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {
        _nativeDrop(_origin, _dstEid, _oapp, _nativeDropParams, _nativeDropGasLimit);
    }

    function nativeDropAndExecute301(
        Origin calldata _origin,
        NativeDropParams[] calldata _nativeDropParams,
        uint256 _nativeDropGasLimit,
        bytes calldata _packet,
        uint256 _gasLimit
    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {
        _nativeDrop(_origin, _packet.dstEid(), _packet.receiverB20(), _nativeDropParams, _nativeDropGasLimit);
        IUltraLightNode301(receiveUln301).commitVerification(_packet, _gasLimit);
    }

    function execute301(bytes calldata _packet, uint256 _gasLimit) external onlyRole(ADMIN_ROLE) nonReentrant {
        IUltraLightNode301(receiveUln301).commitVerification(_packet, _gasLimit);
    }

    function execute302(ExecutionParams calldata _executionParams) external payable onlyRole(ADMIN_ROLE) nonReentrant {
        try
        ILayerZeroEndpointV2(endpoint).lzReceive{ value: msg.value, gas: _executionParams.gasLimit }(
            _executionParams.origin,
            _executionParams.receiver,
            _executionParams.guid,
            _executionParams.message,
            _executionParams.extraData
        )
        {
            // do nothing
        } catch (bytes memory reason) {
            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(
                _executionParams.origin,
                _executionParams.receiver,
                _executionParams.guid,
                _executionParams.gasLimit,
                msg.value,
                _executionParams.message,
                _executionParams.extraData,
                reason
            );
        }
    }

    function compose302(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index,
        bytes calldata _message,
        bytes calldata _extraData,
        uint256 _gasLimit
    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {
        try
        ILayerZeroEndpointV2(endpoint).lzCompose{ value: msg.value, gas: _gasLimit }(
            _from,
            _to,
            _guid,
            _index,
            _message,
            _extraData
        )
        {
            // do nothing
        } catch (bytes memory reason) {
            ILayerZeroEndpointV2(endpoint).lzComposeAlert(
                _from,
                _to,
                _guid,
                _index,
                _gasLimit,
                msg.value,
                _message,
                _extraData,
                reason
            );
        }
    }

    function nativeDropAndExecute302(
        NativeDropParams[] calldata _nativeDropParams,
        uint256 _nativeDropGasLimit,
        ExecutionParams calldata _executionParams
    ) external payable onlyRole(ADMIN_ROLE) nonReentrant {
        uint256 spent = _nativeDrop(
            _executionParams.origin,
            localEid,
            _executionParams.receiver,
            _nativeDropParams,
            _nativeDropGasLimit
        );

        uint256 value = msg.value - spent;
        try
        ILayerZeroEndpointV2(endpoint).lzReceive{ value: value, gas: _executionParams.gasLimit }(
            _executionParams.origin,
            _executionParams.receiver,
            _executionParams.guid,
            _executionParams.message,
            _executionParams.extraData
        )
        {
            // do nothing
        } catch (bytes memory reason) {
            ILayerZeroEndpointV2(endpoint).lzReceiveAlert(
                _executionParams.origin,
                _executionParams.receiver,
                _executionParams.guid,
                _executionParams.gasLimit,
                value,
                _executionParams.message,
                _executionParams.extraData,
                reason
            );
        }
    }

    // --- Message Lib ---
    function assignJob(
        uint32 _dstEid,
        address _sender,
        uint256 _calldataSize,
        bytes calldata _options
    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) whenNotPaused returns (uint256 fee) {
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            priceFeed,
            _dstEid,
            _sender,
            _calldataSize,
            defaultMultiplierBps
        );
        fee = IExecutorFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[_dstEid], _options);
    }

    // --- Only ACL ---
    function getFee(
        uint32 _dstEid,
        address _sender,
        uint256 _calldataSize,
        bytes calldata _options
    ) external view onlyAcl(_sender) whenNotPaused returns (uint256 fee) {
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            priceFeed,
            _dstEid,
            _sender,
            _calldataSize,
            defaultMultiplierBps
        );
        fee = IExecutorFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], _options);
    }

    function _nativeDrop(
        Origin calldata _origin,
        uint32 _dstEid,
        address _oapp,
        NativeDropParams[] calldata _nativeDropParams,
        uint256 _nativeDropGasLimit
    ) internal returns (uint256 spent) {
        bool[] memory success = new bool[](_nativeDropParams.length);
        for (uint256 i = 0; i < _nativeDropParams.length; i++) {
            NativeDropParams memory param = _nativeDropParams[i];

            (bool sent, ) = param.receiver.call{ value: param.amount, gas: _nativeDropGasLimit }("");

            success[i] = sent;
            spent += param.amount;
        }
        emit NativeDropApplied(_origin, _dstEid, _oapp, _nativeDropParams, success);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/ExecutorFeeLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";
import { ExecutorOptions } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol";

import { ILayerZeroPriceFeed } from "./interfaces/ILayerZeroPriceFeed.sol";
import { IExecutor } from "./interfaces/IExecutor.sol";
import { IExecutorFeeLib } from "./interfaces/IExecutorFeeLib.sol";

contract ExecutorFeeLib is Ownable, IExecutorFeeLib {
    using ExecutorOptions for bytes;

    uint256 private immutable nativeDecimalsRate;

    constructor(uint256 _nativeDecimalsRate) {
        nativeDecimalsRate = _nativeDecimalsRate;
    }

    // ================================ OnlyOwner ================================
    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {
        // transfers native if _token is address(0x0)
        Transfer.nativeOrToken(_token, _to, _amount);
    }

    // ================================ External ================================
    function getFeeOnSend(
        FeeParams calldata _params,
        IExecutor.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external returns (uint256 fee) {
        if (_dstConfig.lzReceiveBaseGas == 0) revert Executor_EidNotSupported(_params.dstEid);

        (uint256 totalDstAmount, uint256 totalGas) = _decodeExecutorOptions(
            _isV1Eid(_params.dstEid),
            _dstConfig.lzReceiveBaseGas,
            _dstConfig.lzComposeBaseGas,
            _dstConfig.nativeCap,
            _options
        );

        // for future versions where priceFeed charges a fee
        (
            uint256 totalGasFee,
            uint128 priceRatio,
            uint128 priceRatioDenominator,
            uint128 nativePriceUSD
        ) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeOnSend(_params.dstEid, _params.calldataSize, totalGas);

        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;

        fee = _applyPremiumToGas(totalGasFee, multiplierBps, _dstConfig.floorMarginUSD, nativePriceUSD);
        fee += _convertAndApplyPremiumToValue(totalDstAmount, priceRatio, priceRatioDenominator, multiplierBps);
    }

    // ================================ View ================================
    function getFee(
        FeeParams calldata _params,
        IExecutor.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external view returns (uint256 fee) {
        if (_dstConfig.lzReceiveBaseGas == 0) revert Executor_EidNotSupported(_params.dstEid);

        (uint256 totalDstAmount, uint256 totalGas) = _decodeExecutorOptions(
            _isV1Eid(_params.dstEid),
            _dstConfig.lzReceiveBaseGas,
            _dstConfig.lzComposeBaseGas,
            _dstConfig.nativeCap,
            _options
        );

        (
            uint256 totalGasFee,
            uint128 priceRatio,
            uint128 priceRatioDenominator,
            uint128 nativePriceUSD
        ) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(_params.dstEid, _params.calldataSize, totalGas);

        uint16 multiplierBps = _dstConfig.multiplierBps == 0 ? _params.defaultMultiplierBps : _dstConfig.multiplierBps;

        fee = _applyPremiumToGas(totalGasFee, multiplierBps, _dstConfig.floorMarginUSD, nativePriceUSD);
        fee += _convertAndApplyPremiumToValue(totalDstAmount, priceRatio, priceRatioDenominator, multiplierBps);
    }

    // ================================ Internal ================================
    // @dev decode executor options into dstAmount and totalGas
    function _decodeExecutorOptions(
        bool _v1Eid,
        uint64 _lzReceiveBaseGas,
        uint64 _lzComposeBaseGas,
        uint128 _nativeCap,
        bytes calldata _options
    ) internal pure returns (uint256 dstAmount, uint256 totalGas) {
        if (_options.length == 0) {
            revert Executor_NoOptions();
        }

        uint256 cursor = 0;
        bool ordered = false;
        totalGas = _lzReceiveBaseGas; // lz receive only called once

        bool v1Eid = _v1Eid; // stack too deep
        uint256 lzReceiveGas;
        while (cursor < _options.length) {
            (uint8 optionType, bytes calldata option, uint256 newCursor) = _options.nextExecutorOption(cursor);
            cursor = newCursor;

            if (optionType == ExecutorOptions.OPTION_TYPE_LZRECEIVE) {
                (uint128 gas, uint128 value) = ExecutorOptions.decodeLzReceiveOption(option);

                // endpoint v1 does not support lzReceive with value
                if (v1Eid && value > 0) revert Executor_UnsupportedOptionType(optionType);

                dstAmount += value;
                lzReceiveGas += gas;
            } else if (optionType == ExecutorOptions.OPTION_TYPE_NATIVE_DROP) {
                (uint128 nativeDropAmount, ) = ExecutorOptions.decodeNativeDropOption(option);
                dstAmount += nativeDropAmount;
            } else if (optionType == ExecutorOptions.OPTION_TYPE_LZCOMPOSE) {
                // endpoint v1 does not support lzCompose
                if (v1Eid) revert Executor_UnsupportedOptionType(optionType);

                (, uint128 gas, uint128 value) = ExecutorOptions.decodeLzComposeOption(option);
                if (gas == 0) revert Executor_ZeroLzComposeGasProvided();

                dstAmount += value;
                // lz compose can be called multiple times, based on unique index
                // to simplify the quoting, we add lzComposeBaseGas for each lzComposeOption received
                // if the same index has multiple compose options, the gas will be added multiple times
                totalGas += gas + _lzComposeBaseGas;
            } else if (optionType == ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION) {
                ordered = true;
            } else {
                revert Executor_UnsupportedOptionType(optionType);
            }
        }
        if (cursor != _options.length) revert Executor_InvalidExecutorOptions(cursor);
        if (dstAmount > _nativeCap) revert Executor_NativeAmountExceedsCap(dstAmount, _nativeCap);
        if (lzReceiveGas == 0) revert Executor_ZeroLzReceiveGasProvided();
        totalGas += lzReceiveGas;

        if (ordered) {
            totalGas = (totalGas * 102) / 100;
        }
    }

    function _applyPremiumToGas(
        uint256 _fee,
        uint16 _multiplierBps,
        uint128 _marginUSD,
        uint128 _nativePriceUSD
    ) internal view returns (uint256) {
        uint256 feeWithMultiplier = (_fee * _multiplierBps) / 10000;

        if (_nativePriceUSD == 0 || _marginUSD == 0) {
            return feeWithMultiplier;
        }
        uint256 feeWithMargin = (_marginUSD * nativeDecimalsRate) / _nativePriceUSD + _fee;
        return feeWithMargin > feeWithMultiplier ? feeWithMargin : feeWithMultiplier;
    }

    // includes value and nativeDrop
    function _convertAndApplyPremiumToValue(
        uint256 _value,
        uint128 _ratio,
        uint128 _denom,
        uint16 _multiplierBps
    ) internal pure returns (uint256 fee) {
        if (_value > 0) {
            fee = (((_value * _ratio) / _denom) * _multiplierBps) / 10000;
        }
    }

    function _isV1Eid(uint32 _eid) internal pure virtual returns (bool) {
        // v1 eid is < 30000
        return _eid < 30000;
    }

    // send funds here to pay for price feed directly
    receive() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/MessageLibBase.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

/// @dev simply a container of endpoint address and local eid
abstract contract MessageLibBase {
    address internal immutable endpoint;
    uint32 internal immutable localEid;

    error LZ_MessageLib_OnlyEndpoint();

    modifier onlyEndpoint() {
        if (endpoint != msg.sender) revert LZ_MessageLib_OnlyEndpoint();
        _;
    }

    constructor(address _endpoint, uint32 _localEid) {
        endpoint = _endpoint;
        localEid = _localEid;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/PriceFeed.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";

import { ILayerZeroEndpointV2 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { ILayerZeroPriceFeed } from "./interfaces/ILayerZeroPriceFeed.sol";

// PriceFeed is updated based on v1 eids
// v2 eids will fall to the convention of v1 eid + 30,000
contract PriceFeed is ILayerZeroPriceFeed, OwnableUpgradeable, Proxied {
    uint128 internal PRICE_RATIO_DENOMINATOR;

    // sets pricing
    mapping(address updater => bool active) public priceUpdater;

    mapping(uint32 dstEid => Price) internal _defaultModelPrice;
    ArbitrumPriceExt internal _arbitrumPriceExt;

    uint128 internal _nativePriceUSD; // uses PRICE_RATIO_DENOMINATOR

    // upgrade: arbitrum compression - percentage of callDataSize after brotli compression
    uint128 public ARBITRUM_COMPRESSION_PERCENT;

    ILayerZeroEndpointV2 public endpoint;

    // ============================ Constructor ===================================

    function initialize(address _priceUpdater) public proxied initializer {
        __Ownable_init();
        priceUpdater[_priceUpdater] = true;
        PRICE_RATIO_DENOMINATOR = 1e20;
        ARBITRUM_COMPRESSION_PERCENT = 47;
    }

    // ============================ Modifier ======================================

    // owner is always approved
    modifier onlyPriceUpdater() {
        if (owner() != msg.sender) {
            if (!priceUpdater[msg.sender]) {
                revert LZ_PriceFeed_OnlyPriceUpdater();
            }
        }
        _;
    }

    // ============================ OnlyOwner =====================================

    function setPriceUpdater(address _addr, bool _active) external onlyOwner {
        priceUpdater[_addr] = _active;
    }

    function setPriceRatioDenominator(uint128 _denominator) external onlyOwner {
        PRICE_RATIO_DENOMINATOR = _denominator;
    }

    function setArbitrumCompressionPercent(uint128 _compressionPercent) external onlyOwner {
        ARBITRUM_COMPRESSION_PERCENT = _compressionPercent;
    }

    function setEndpoint(address _endpoint) external onlyOwner {
        endpoint = ILayerZeroEndpointV2(_endpoint);
    }

    function withdrawFee(address _to, uint256 _amount) external onlyOwner {
        Transfer.native(_to, _amount);
    }

    // ============================ OnlyPriceUpdater =====================================

    function setPrice(UpdatePrice[] calldata _price) external onlyPriceUpdater {
        for (uint256 i = 0; i < _price.length; i++) {
            UpdatePrice calldata _update = _price[i];
            _setPrice(_update.eid, _update.price);
        }
    }

    function setPriceForArbitrum(UpdatePriceExt calldata _update) external onlyPriceUpdater {
        _setPrice(_update.eid, _update.price);

        uint64 gasPerL2Tx = _update.extend.gasPerL2Tx;
        uint32 gasPerL1CalldataByte = _update.extend.gasPerL1CallDataByte;

        _arbitrumPriceExt.gasPerL2Tx = gasPerL2Tx;
        _arbitrumPriceExt.gasPerL1CallDataByte = gasPerL1CalldataByte;
    }

    function setNativeTokenPriceUSD(uint128 _nativeTokenPriceUSD) external onlyPriceUpdater {
        _nativePriceUSD = _nativeTokenPriceUSD;
    }

    // ============================ External =====================================

    function estimateFeeOnSend(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) external payable returns (uint256, uint128, uint128, uint128) {
        uint256 fee = getFee(_dstEid, _callDataSize, _gas);
        if (msg.value < fee) revert LZ_PriceFeed_InsufficientFee(msg.value, fee);
        return _estimateFeeByEid(_dstEid, _callDataSize, _gas);
    }

    // ============================ View ==========================================

    // get fee for calling estimateFeeOnSend
    function getFee(uint32 /*_dstEid*/, uint256 /*_callDataSize*/, uint256 /*_gas*/) public pure returns (uint256) {
        return 0;
    }

    function getPriceRatioDenominator() external view returns (uint128) {
        return PRICE_RATIO_DENOMINATOR;
    }

    // NOTE: to be reverted when endpoint is in sendContext
    function nativeTokenPriceUSD() external view returns (uint128) {
        return _nativePriceUSD;
    }

    // NOTE: to be reverted when endpoint is in sendContext
    function arbitrumPriceExt() external view returns (ArbitrumPriceExt memory) {
        return _arbitrumPriceExt;
    }

    // NOTE: to be reverted when endpoint is in sendContext
    function getPrice(uint32 _dstEid) external view returns (Price memory price) {
        price = _defaultModelPrice[_dstEid];
    }

    // NOTE: to be reverted when endpoint is in sendContext
    function estimateFeeByEid(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) external view returns (uint256, uint128, uint128, uint128) {
        return _estimateFeeByEid(_dstEid, _callDataSize, _gas);
    }

    // NOTE: to be reverted when endpoint is in sendContext
    // NOTE: to support legacy
    function getPrice(uint16 _dstEid) external view returns (Price memory price) {
        price = _defaultModelPrice[_dstEid];
    }

    // NOTE: to be reverted when endpoint is in sendContext
    // NOTE: to support legacy
    function estimateFeeByChain(
        uint16 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) external view returns (uint256 fee, uint128 priceRatio) {
        if (_dstEid == 110 || _dstEid == 10143 || _dstEid == 20143) {
            return _estimateFeeWithArbitrumModel(_dstEid, _callDataSize, _gas);
        } else if (_dstEid == 111 || _dstEid == 10132 || _dstEid == 20132) {
            return _estimateFeeWithOptimismModel(_dstEid, _callDataSize, _gas);
        } else {
            return _estimateFeeWithDefaultModel(_dstEid, _callDataSize, _gas);
        }
    }

    // ============================ Internal ==========================================

    function _setPrice(uint32 _dstEid, Price memory _price) internal {
        uint128 priceRatio = _price.priceRatio;
        uint64 gasPriceInUnit = _price.gasPriceInUnit;
        uint32 gasPerByte = _price.gasPerByte;
        _defaultModelPrice[_dstEid] = Price(priceRatio, gasPriceInUnit, gasPerByte);
    }

    function _getL1LookupId(uint32 _l2Eid) internal pure returns (uint32) {
        uint32 l2Eid = _l2Eid % 30_000;
        if (l2Eid == 111) {
            return 101;
        } else if (l2Eid == 10132) {
            return 10121; // ethereum-goerli
        } else if (l2Eid == 20132) {
            return 20121; // ethereum-goerli
        }
        revert LZ_PriceFeed_UnknownL2Eid(l2Eid);
    }

    function _estimateFeeWithDefaultModel(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) internal view returns (uint256 fee, uint128 priceRatio) {
        Price storage remotePrice = _defaultModelPrice[_dstEid];

        // assuming the _gas includes (1) the 21,000 overhead and (2) not the calldata gas
        uint256 gasForCallData = _callDataSize * remotePrice.gasPerByte;
        uint256 remoteFee = (gasForCallData + _gas) * remotePrice.gasPriceInUnit;
        return ((remoteFee * remotePrice.priceRatio) / PRICE_RATIO_DENOMINATOR, remotePrice.priceRatio);
    }

    function _estimateFeeByEid(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) internal view returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 priceUSD) {
        uint32 dstEid = _dstEid % 30_000;
        if (dstEid == 110 || dstEid == 10143 || dstEid == 20143) {
            (fee, priceRatio) = _estimateFeeWithArbitrumModel(dstEid, _callDataSize, _gas);
        } else if (dstEid == 111 || dstEid == 10132 || dstEid == 20132) {
            (fee, priceRatio) = _estimateFeeWithOptimismModel(dstEid, _callDataSize, _gas);
        } else {
            (fee, priceRatio) = _estimateFeeWithDefaultModel(dstEid, _callDataSize, _gas);
        }
        priceRatioDenominator = PRICE_RATIO_DENOMINATOR;
        priceUSD = _nativePriceUSD;
    }

    function _estimateFeeWithOptimismModel(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) internal view returns (uint256 fee, uint128 priceRatio) {
        uint32 ethereumId = _getL1LookupId(_dstEid);

        // L1 fee
        Price storage ethereumPrice = _defaultModelPrice[ethereumId];
        uint256 gasForL1CallData = (_callDataSize * ethereumPrice.gasPerByte) + 3188; // 2100 + 68 * 16
        uint256 l1Fee = gasForL1CallData * ethereumPrice.gasPriceInUnit;

        // L2 fee
        Price storage optimismPrice = _defaultModelPrice[_dstEid];
        uint256 gasForL2CallData = _callDataSize * optimismPrice.gasPerByte;
        uint256 l2Fee = (gasForL2CallData + _gas) * optimismPrice.gasPriceInUnit;

        uint256 l1FeeInSrcPrice = (l1Fee * ethereumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;
        uint256 l2FeeInSrcPrice = (l2Fee * optimismPrice.priceRatio) / PRICE_RATIO_DENOMINATOR;
        uint256 gasFee = l1FeeInSrcPrice + l2FeeInSrcPrice;
        return (gasFee, optimismPrice.priceRatio);
    }

    function _estimateFeeWithArbitrumModel(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) internal view returns (uint256 fee, uint128 priceRatio) {
        Price storage arbitrumPrice = _defaultModelPrice[_dstEid];

        // L1 fee
        uint256 gasForL1CallData = ((_callDataSize * ARBITRUM_COMPRESSION_PERCENT) / 100) *
            _arbitrumPriceExt.gasPerL1CallDataByte;
        // L2 Fee
        uint256 gasForL2CallData = _callDataSize * arbitrumPrice.gasPerByte;
        uint256 gasFee = (_gas + _arbitrumPriceExt.gasPerL2Tx + gasForL1CallData + gasForL2CallData) *
            arbitrumPrice.gasPriceInUnit;

        return ((gasFee * arbitrumPrice.priceRatio) / PRICE_RATIO_DENOMINATOR, arbitrumPrice.priceRatio);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/ReceiveLibBaseE2.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import { ERC165 } from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import { ILayerZeroEndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { IMessageLib, MessageLibType } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { MessageLibBase } from "./MessageLibBase.sol";

/// @dev receive-side message library base contract on endpoint v2.
/// it does not have the complication as the one of endpoint v1, such as nonce, executor whitelist, etc.
abstract contract ReceiveLibBaseE2 is MessageLibBase, ERC165, IMessageLib {
    using PacketV1Codec for bytes;

    constructor(address _endpoint) MessageLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid()) {}

    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return _interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(_interfaceId);
    }

    function messageLibType() external pure virtual override returns (MessageLibType) {
        return MessageLibType.Receive;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/SendLibBase.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { ILayerZeroExecutor } from "./interfaces/ILayerZeroExecutor.sol";
import { ILayerZeroTreasury } from "./interfaces/ILayerZeroTreasury.sol";
import { SafeCall } from "./libs/SafeCall.sol";
import { MessageLibBase } from "./MessageLibBase.sol";

struct WorkerOptions {
    uint8 workerId;
    bytes options;
}

struct SetDefaultExecutorConfigParam {
    uint32 eid;
    ExecutorConfig config;
}

struct ExecutorConfig {
    uint32 maxMessageSize;
    address executor;
}

/// @dev base contract for both SendLibBaseE1 and SendLibBaseE2
abstract contract SendLibBase is MessageLibBase, Ownable {
    using SafeCall for address;

    address private constant DEFAULT_CONFIG = address(0);
    uint16 internal constant TREASURY_MAX_COPY = 32;

    uint256 internal immutable treasuryGasLimit;
    uint256 internal treasuryNativeFeeCap;

    // config
    address public treasury;
    mapping(address oapp => mapping(uint32 eid => ExecutorConfig)) public executorConfigs;

    // accumulated fees for workers and treasury
    mapping(address worker => uint256) public fees;

    event ExecutorFeePaid(address executor, uint256 fee);
    event TreasurySet(address treasury);
    event DefaultExecutorConfigsSet(SetDefaultExecutorConfigParam[] params);
    event ExecutorConfigSet(address oapp, uint32 eid, ExecutorConfig config);
    event TreasuryNativeFeeCapSet(uint256 newTreasuryNativeFeeCap);

    error LZ_MessageLib_InvalidMessageSize(uint256 actual, uint256 max);
    error LZ_MessageLib_InvalidAmount(uint256 requested, uint256 available);
    error LZ_MessageLib_TransferFailed();
    error LZ_MessageLib_InvalidExecutor();
    error LZ_MessageLib_ZeroMessageSize();

    constructor(
        address _endpoint,
        uint32 _localEid,
        uint256 _treasuryGasLimit,
        uint256 _treasuryNativeFeeCap
    ) MessageLibBase(_endpoint, _localEid) {
        treasuryGasLimit = _treasuryGasLimit;
        treasuryNativeFeeCap = _treasuryNativeFeeCap;
    }

    function setDefaultExecutorConfigs(SetDefaultExecutorConfigParam[] calldata _params) external onlyOwner {
        for (uint256 i = 0; i < _params.length; ++i) {
            SetDefaultExecutorConfigParam calldata param = _params[i];

            if (param.config.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();
            if (param.config.maxMessageSize == 0) revert LZ_MessageLib_ZeroMessageSize();

            executorConfigs[DEFAULT_CONFIG][param.eid] = param.config;
        }
        emit DefaultExecutorConfigsSet(_params);
    }

    /// @dev the new value can not be greater than the old value, i.e. down only
    function setTreasuryNativeFeeCap(uint256 _newTreasuryNativeFeeCap) external onlyOwner {
        // assert the new value is no greater than the old value
        if (_newTreasuryNativeFeeCap > treasuryNativeFeeCap)
            revert LZ_MessageLib_InvalidAmount(_newTreasuryNativeFeeCap, treasuryNativeFeeCap);
        treasuryNativeFeeCap = _newTreasuryNativeFeeCap;
        emit TreasuryNativeFeeCapSet(_newTreasuryNativeFeeCap);
    }

    // ============================ View ===================================
    // @dev get the executor config and if not set, return the default config
    function getExecutorConfig(address _oapp, uint32 _remoteEid) public view returns (ExecutorConfig memory rtnConfig) {
        ExecutorConfig storage defaultConfig = executorConfigs[DEFAULT_CONFIG][_remoteEid];
        ExecutorConfig storage customConfig = executorConfigs[_oapp][_remoteEid];

        uint32 maxMessageSize = customConfig.maxMessageSize;
        rtnConfig.maxMessageSize = maxMessageSize != 0 ? maxMessageSize : defaultConfig.maxMessageSize;

        address executor = customConfig.executor;
        rtnConfig.executor = executor != address(0x0) ? executor : defaultConfig.executor;
    }

    // ======================= Internal =======================
    function _assertMessageSize(uint256 _actual, uint256 _max) internal pure {
        if (_actual > _max) revert LZ_MessageLib_InvalidMessageSize(_actual, _max);
    }

    function _payExecutor(
        address _executor,
        uint32 _dstEid,
        address _sender,
        uint256 _msgSize,
        bytes memory _executorOptions
    ) internal returns (uint256 executorFee) {
        executorFee = ILayerZeroExecutor(_executor).assignJob(_dstEid, _sender, _msgSize, _executorOptions);
        if (executorFee > 0) {
            fees[_executor] += executorFee;
        }
        emit ExecutorFeePaid(_executor, executorFee);
    }

    function _payTreasury(
        address _sender,
        uint32 _dstEid,
        uint256 _totalNativeFee,
        bool _payInLzToken
    ) internal returns (uint256 treasuryNativeFee, uint256 lzTokenFee) {
        if (treasury != address(0x0)) {
            bytes memory callData = abi.encodeCall(
                ILayerZeroTreasury.payFee,
                (_sender, _dstEid, _totalNativeFee, _payInLzToken)
            );
            (bool success, bytes memory result) = treasury.safeCall(treasuryGasLimit, 0, TREASURY_MAX_COPY, callData);

            (treasuryNativeFee, lzTokenFee) = _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);
            // fee should be in lzTokenFee if payInLzToken, otherwise in native
            if (treasuryNativeFee > 0) {
                fees[treasury] += treasuryNativeFee;
            }
        }
    }

    /// @dev the abstract process for quote() is:
    /// 0/ split out the executor options and options of other workers
    /// 1/ quote workers
    /// 2/ quote executor
    /// 3/ quote treasury
    /// @return nativeFee, lzTokenFee
    function _quote(
        address _sender,
        uint32 _dstEid,
        uint256 _msgSize,
        bool _payInLzToken,
        bytes calldata _options
    ) internal view returns (uint256, uint256) {
        (bytes memory executorOptions, WorkerOptions[] memory validationOptions) = _splitOptions(_options);

        // quote the verifier used in the library. for ULN, it is a list of DVNs
        uint256 nativeFee = _quoteVerifier(_sender, _dstEid, validationOptions);

        // quote executor
        ExecutorConfig memory config = getExecutorConfig(_sender, _dstEid);
        // assert msg size
        _assertMessageSize(_msgSize, config.maxMessageSize);

        nativeFee += ILayerZeroExecutor(config.executor).getFee(_dstEid, _sender, _msgSize, executorOptions);

        // quote treasury
        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _quoteTreasury(_sender, _dstEid, nativeFee, _payInLzToken);
        nativeFee += treasuryNativeFee;

        return (nativeFee, lzTokenFee);
    }

    /// @dev this interface should be DoS-free if the user is paying with native. properties
    /// 1/ treasury can return an overly high lzToken fee
    /// 2/ if treasury returns an overly high native fee, it will be capped by maxNativeFee,
    ///    which can be reasoned with the configurations
    /// 3/ the owner can not configure the treasury in a way that force this function to revert
    function _quoteTreasury(
        address _sender,
        uint32 _dstEid,
        uint256 _totalNativeFee,
        bool _payInLzToken
    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {
        // treasury must be set, and it has to be a contract
        if (treasury != address(0x0)) {
            bytes memory callData = abi.encodeCall(
                ILayerZeroTreasury.getFee,
                (_sender, _dstEid, _totalNativeFee, _payInLzToken)
            );
            (bool success, bytes memory result) = treasury.safeStaticCall(
                treasuryGasLimit,
                TREASURY_MAX_COPY,
                callData
            );

            return _parseTreasuryResult(_totalNativeFee, _payInLzToken, success, result);
        }
    }

    function _parseTreasuryResult(
        uint256 _totalNativeFee,
        bool _payInLzToken,
        bool _success,
        bytes memory _result
    ) internal view returns (uint256 nativeFee, uint256 lzTokenFee) {
        // failure, charges nothing
        if (!_success || _result.length < TREASURY_MAX_COPY) return (0, 0);

        // parse the result
        uint256 treasureFeeQuote = abi.decode(_result, (uint256));
        if (_payInLzToken) {
            lzTokenFee = treasureFeeQuote;
        } else {
            // pay in native
            // we must prevent high-treasuryFee Dos attack
            // nativeFee = min(treasureFeeQuote, maxNativeFee)
            // opportunistically raise the maxNativeFee to be the same as _totalNativeFee
            // can't use the _totalNativeFee alone because the oapp can use custom workers to force the fee to 0.
            // maxNativeFee = max (_totalNativeFee, treasuryNativeFeeCap)
            uint256 maxNativeFee = _totalNativeFee > treasuryNativeFeeCap ? _totalNativeFee : treasuryNativeFeeCap;

            // min (treasureFeeQuote, nativeFeeCap)
            nativeFee = treasureFeeQuote > maxNativeFee ? maxNativeFee : treasureFeeQuote;
        }
    }

    /// @dev authenticated by msg.sender only
    function _debitFee(uint256 _amount) internal {
        uint256 fee = fees[msg.sender];
        if (_amount > fee) revert LZ_MessageLib_InvalidAmount(_amount, fee);
        unchecked {
            fees[msg.sender] = fee - _amount;
        }
    }

    function _setTreasury(address _treasury) internal {
        treasury = _treasury;
        emit TreasurySet(_treasury);
    }

    function _setExecutorConfig(uint32 _remoteEid, address _oapp, ExecutorConfig memory _config) internal {
        executorConfigs[_oapp][_remoteEid] = _config;
        emit ExecutorConfigSet(_oapp, _remoteEid, _config);
    }

    // ======================= Virtual =======================
    /// @dev these two functions will be overridden with specific logics of the library function
    function _quoteVerifier(
        address _oapp,
        uint32 _eid,
        WorkerOptions[] memory _options
    ) internal view virtual returns (uint256 nativeFee);

    /// @dev this function will split the options into executorOptions and validationOptions
    function _splitOptions(
        bytes calldata _options
    ) internal view virtual returns (bytes memory executorOptions, WorkerOptions[] memory validationOptions);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/SendLibBaseE2.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import { ERC165 } from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import { ILayerZeroEndpointV2, MessagingFee } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { IMessageLib, MessageLibType } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol";
import { ISendLib, Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { SendLibBase, WorkerOptions, ExecutorConfig } from "./SendLibBase.sol";

/// @dev send-side message library base contract on endpoint v2.
/// design: the high level logic is the same as SendLibBaseE1
/// 1/ with added interfaces
/// 2/ adapt the functions to the new types, like uint32 for eid, address for sender.
abstract contract SendLibBaseE2 is SendLibBase, ERC165, ISendLib {
    event NativeFeeWithdrawn(address worker, address receiver, uint256 amount);
    event LzTokenFeeWithdrawn(address lzToken, address receiver, uint256 amount);

    error LZ_MessageLib_NotTreasury();
    error LZ_MessageLib_CannotWithdrawAltToken();

    constructor(
        address _endpoint,
        uint256 _treasuryGasLimit,
        uint256 _treasuryNativeFeeCap
    ) SendLibBase(_endpoint, ILayerZeroEndpointV2(_endpoint).eid(), _treasuryGasLimit, _treasuryNativeFeeCap) {}

    function supportsInterface(bytes4 _interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            _interfaceId == type(IMessageLib).interfaceId ||
            _interfaceId == type(ISendLib).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    // ========================= OnlyEndpoint =========================
    // @dev this function is marked as virtual and public for testing purpose
    function send(
        Packet calldata _packet,
        bytes calldata _options,
        bool _payInLzToken
    ) public virtual onlyEndpoint returns (MessagingFee memory, bytes memory) {
        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_packet, _options);

        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(
            _packet.sender,
            _packet.dstEid,
            totalNativeFee,
            _payInLzToken
        );
        totalNativeFee += treasuryNativeFee;

        return (MessagingFee(totalNativeFee, lzTokenFee), encodedPacket);
    }

    // ========================= OnlyOwner =========================
    function setTreasury(address _treasury) external onlyOwner {
        _setTreasury(_treasury);
    }

    // ========================= External =========================
    /// @dev E2 only
    function withdrawFee(address _to, uint256 _amount) external {
        _debitFee(_amount);
        address nativeToken = ILayerZeroEndpointV2(endpoint).nativeToken();
        // transfers native if nativeToken == address(0x0)
        Transfer.nativeOrToken(nativeToken, _to, _amount);
        emit NativeFeeWithdrawn(msg.sender, _to, _amount);
    }

    /// @dev _lzToken is a user-supplied value because lzToken might change in the endpoint before all lzToken can be taken out
    /// @dev E2 only
    /// @dev treasury only function
    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external {
        if (msg.sender != treasury) revert LZ_MessageLib_NotTreasury();

        // lz token cannot be the same as the native token
        if (ILayerZeroEndpointV2(endpoint).nativeToken() == _lzToken) revert LZ_MessageLib_CannotWithdrawAltToken();

        Transfer.token(_lzToken, _to, _amount);

        emit LzTokenFeeWithdrawn(_lzToken, _to, _amount);
    }

    // ========================= View =========================
    function quote(
        Packet calldata _packet,
        bytes calldata _options,
        bool _payInLzToken
    ) external view returns (MessagingFee memory) {
        (uint256 nativeFee, uint256 lzTokenFee) = _quote(
            _packet.sender,
            _packet.dstEid,
            _packet.message.length,
            _payInLzToken,
            _options
        );
        return MessagingFee(nativeFee, lzTokenFee);
    }

    function messageLibType() external pure virtual override returns (MessageLibType) {
        return MessageLibType.Send;
    }

    // ========================= Internal =========================
    /// 1/ handle executor
    /// 2/ handle other workers
    function _payWorkers(
        Packet calldata _packet,
        bytes calldata _options
    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {
        // split workers options
        (bytes memory executorOptions, WorkerOptions[] memory validationOptions) = _splitOptions(_options);

        // handle executor
        ExecutorConfig memory config = getExecutorConfig(_packet.sender, _packet.dstEid);
        uint256 msgSize = _packet.message.length;
        _assertMessageSize(msgSize, config.maxMessageSize);
        totalNativeFee += _payExecutor(config.executor, _packet.dstEid, _packet.sender, msgSize, executorOptions);

        // handle other workers
        (uint256 verifierFee, bytes memory packetBytes) = _payVerifier(_packet, validationOptions); //for ULN, it will be dvns
        totalNativeFee += verifierFee;

        encodedPacket = packetBytes;
    }

    // ======================= Virtual =======================
    // For implementation to override
    function _payVerifier(
        Packet calldata _packet,
        WorkerOptions[] memory _options
    ) internal virtual returns (uint256 otherWorkerFees, bytes memory encodedPacket);

    // receive native token from endpoint
    receive() external payable virtual {}
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/Treasury.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { ISendLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { ILayerZeroTreasury } from "./interfaces/ILayerZeroTreasury.sol";

contract Treasury is Ownable, ILayerZeroTreasury {
    uint256 public nativeBP;
    uint256 public lzTokenFee;
    bool public lzTokenEnabled;

    error LZ_Treasury_LzTokenNotEnabled();

    function getFee(
        address /*_sender*/,
        uint32 /*_eid*/,
        uint256 _totalFee,
        bool _payInLzToken
    ) external view override returns (uint256) {
        return _getFee(_totalFee, _payInLzToken);
    }

    function payFee(
        address /*_sender*/,
        uint32 /*_eid*/,
        uint256 _totalFee,
        bool _payInLzToken
    ) external payable override returns (uint256) {
        return _getFee(_totalFee, _payInLzToken);
    }

    function setLzTokenEnabled(bool _lzTokenEnabled) external onlyOwner {
        lzTokenEnabled = _lzTokenEnabled;
    }

    function setNativeFeeBP(uint256 _nativeBP) external onlyOwner {
        nativeBP = _nativeBP;
    }

    function setLzTokenFee(uint256 _lzTokenFee) external onlyOwner {
        lzTokenFee = _lzTokenFee;
    }

    function withdrawLzToken(address _messageLib, address _lzToken, address _to, uint256 _amount) external onlyOwner {
        ISendLib(_messageLib).withdrawLzTokenFee(_lzToken, _to, _amount);
    }

    function withdrawNativeFee(address _messageLib, address payable _to, uint256 _amount) external onlyOwner {
        ISendLib(_messageLib).withdrawFee(_to, _amount);
    }

    // this is for withdrawing lz token sent to this contract by uln301 and fee handler
    // and to withdraw any native sent over via payFee
    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {
        // transfers native if _token is address(0x0)
        Transfer.nativeOrToken(_token, _to, _amount);
    }

    // ======================= Internal =======================

    function _getFee(uint256 _totalFee, bool _payInLzToken) internal view returns (uint256) {
        if (_payInLzToken) {
            if (!lzTokenEnabled) revert LZ_Treasury_LzTokenNotEnabled();
            return lzTokenFee;
        } else {
            return (_totalFee * nativeBP) / 10000;
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/Worker.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Pausable } from "@openzeppelin/contracts/security/Pausable.sol";
import { AccessControl } from "@openzeppelin/contracts/access/AccessControl.sol";

import { ISendLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { IWorker } from "./interfaces/IWorker.sol";

abstract contract Worker is AccessControl, Pausable, IWorker {
    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256("MESSAGE_LIB_ROLE");
    bytes32 internal constant ALLOWLIST = keccak256("ALLOWLIST");
    bytes32 internal constant DENYLIST = keccak256("DENYLIST");
    bytes32 internal constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    address public workerFeeLib;

    uint64 public allowlistSize;
    uint16 public defaultMultiplierBps;
    address public priceFeed;

    mapping(uint32 eid => uint8[] optionTypes) internal supportedOptionTypes;

    // ========================= Constructor =========================

    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE
    /// @param _priceFeed price feed address
    /// @param _defaultMultiplierBps default multiplier for worker fee
    /// @param _roleAdmin address that is granted the DEFAULT_ADMIN_ROLE (can grant and revoke all roles)
    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE
    constructor(
        address[] memory _messageLibs,
        address _priceFeed,
        uint16 _defaultMultiplierBps,
        address _roleAdmin,
        address[] memory _admins
    ) {
        defaultMultiplierBps = _defaultMultiplierBps;
        priceFeed = _priceFeed;

        if (_roleAdmin != address(0x0)) {
            _grantRole(DEFAULT_ADMIN_ROLE, _roleAdmin); // _roleAdmin can grant and revoke all roles
        }

        for (uint256 i = 0; i < _messageLibs.length; ++i) {
            _grantRole(MESSAGE_LIB_ROLE, _messageLibs[i]);
        }

        for (uint256 i = 0; i < _admins.length; ++i) {
            _grantRole(ADMIN_ROLE, _admins[i]);
        }
    }

    // ========================= Modifier =========================

    modifier onlyAcl(address _sender) {
        if (!hasAcl(_sender)) {
            revert Worker_NotAllowed();
        }
        _;
    }

    /// @dev Access control list using allowlist and denylist
    /// @dev 1) if one address is in the denylist -> deny
    /// @dev 2) else if address in the allowlist OR allowlist is empty (allows everyone)-> allow
    /// @dev 3) else deny
    /// @param _sender address to check
    function hasAcl(address _sender) public view returns (bool) {
        if (hasRole(DENYLIST, _sender)) {
            return false;
        } else if (allowlistSize == 0 || hasRole(ALLOWLIST, _sender)) {
            return true;
        } else {
            return false;
        }
    }

    // ========================= OnyDefaultAdmin =========================

    /// @dev flag to pause execution of workers (if used with whenNotPaused modifier)
    /// @param _paused true to pause, false to unpause
    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_paused) {
            _pause();
        } else {
            _unpause();
        }
    }

    // ========================= OnlyAdmin =========================

    /// @param _priceFeed price feed address
    function setPriceFeed(address _priceFeed) external onlyRole(ADMIN_ROLE) {
        priceFeed = _priceFeed;
        emit SetPriceFeed(_priceFeed);
    }

    /// @param _workerFeeLib worker fee lib address
    function setWorkerFeeLib(address _workerFeeLib) external onlyRole(ADMIN_ROLE) {
        workerFeeLib = _workerFeeLib;
        emit SetWorkerLib(_workerFeeLib);
    }

    /// @param _multiplierBps default multiplier for worker fee
    function setDefaultMultiplierBps(uint16 _multiplierBps) external onlyRole(ADMIN_ROLE) {
        defaultMultiplierBps = _multiplierBps;
        emit SetDefaultMultiplierBps(_multiplierBps);
    }

    /// @dev supports withdrawing fee from ULN301, ULN302 and more
    /// @param _lib message lib address
    /// @param _to address to withdraw fee to
    /// @param _amount amount to withdraw
    function withdrawFee(address _lib, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {
        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) revert Worker_OnlyMessageLib();
        ISendLib(_lib).withdrawFee(_to, _amount);
        emit Withdraw(_lib, _to, _amount);
    }

    /// @dev supports withdrawing token from the contract
    /// @param _token token address
    /// @param _to address to withdraw token to
    /// @param _amount amount to withdraw
    function withdrawToken(address _token, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {
        // transfers native if _token is address(0x0)
        Transfer.nativeOrToken(_token, _to, _amount);
    }

    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external onlyRole(ADMIN_ROLE) {
        supportedOptionTypes[_eid] = _optionTypes;
    }

    // ========================= View Functions =========================
    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory) {
        return supportedOptionTypes[_eid];
    }

    // ========================= Internal Functions =========================

    /// @dev overrides AccessControl to allow for counting of allowlistSize
    /// @param _role role to grant
    /// @param _account address to grant role to
    function _grantRole(bytes32 _role, address _account) internal override {
        if (_role == ALLOWLIST && !hasRole(_role, _account)) {
            ++allowlistSize;
        }
        super._grantRole(_role, _account);
    }

    /// @dev overrides AccessControl to allow for counting of allowlistSize
    /// @param _role role to revoke
    /// @param _account address to revoke role from
    function _revokeRole(bytes32 _role, address _account) internal override {
        if (_role == ALLOWLIST && hasRole(_role, _account)) {
            --allowlistSize;
        }
        super._revokeRole(_role, _account);
    }

    /// @dev overrides AccessControl to disable renouncing of roles
    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {
        revert Worker_RoleRenouncingDisabled();
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/interfaces/IExecutor.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";

import { IWorker } from "./IWorker.sol";
import { ILayerZeroExecutor } from "./ILayerZeroExecutor.sol";

interface IExecutor is IWorker, ILayerZeroExecutor {
    struct DstConfigParam {
        uint32 dstEid;
        uint64 lzReceiveBaseGas;
        uint64 lzComposeBaseGas;
        uint16 multiplierBps;
        uint128 floorMarginUSD;
        uint128 nativeCap;
    }

    struct DstConfig {
        uint64 lzReceiveBaseGas;
        uint16 multiplierBps;
        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR
        uint128 nativeCap;
        uint64 lzComposeBaseGas;
    }

    struct ExecutionParams {
        address receiver;
        Origin origin;
        bytes32 guid;
        bytes message;
        bytes extraData;
        uint256 gasLimit;
    }

    struct NativeDropParams {
        address receiver;
        uint256 amount;
    }

    event DstConfigSet(DstConfigParam[] params);
    event NativeDropApplied(Origin origin, uint32 dstEid, address oapp, NativeDropParams[] params, bool[] success);

    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128, uint128, uint64);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/interfaces/IExecutorFeeLib.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { IExecutor } from "./IExecutor.sol";

interface IExecutorFeeLib {
    struct FeeParams {
        address priceFeed;
        uint32 dstEid;
        address sender;
        uint256 calldataSize;
        uint16 defaultMultiplierBps;
    }

    error Executor_NoOptions();
    error Executor_NativeAmountExceedsCap(uint256 amount, uint256 cap);
    error Executor_UnsupportedOptionType(uint8 optionType);
    error Executor_InvalidExecutorOptions(uint256 cursor);
    error Executor_ZeroLzReceiveGasProvided();
    error Executor_ZeroLzComposeGasProvided();
    error Executor_EidNotSupported(uint32 eid);

    function getFeeOnSend(
        FeeParams calldata _params,
        IExecutor.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external returns (uint256 fee);

    function getFee(
        FeeParams calldata _params,
        IExecutor.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external view returns (uint256 fee);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/interfaces/ILayerZeroExecutor.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface ILayerZeroExecutor {
    // @notice query price and assign jobs at the same time
    // @param _dstEid - the destination endpoint identifier
    // @param _sender - the source sending contract address. executors may apply price discrimination to senders
    // @param _calldataSize - dynamic data size of message + caller params
    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain
    function assignJob(
        uint32 _dstEid,
        address _sender,
        uint256 _calldataSize,
        bytes calldata _options
    ) external returns (uint256 price);

    // @notice query the executor price for relaying the payload and its proof to the destination chain
    // @param _dstEid - the destination endpoint identifier
    // @param _sender - the source sending contract address. executors may apply price discrimination to senders
    // @param _calldataSize - dynamic data size of message + caller params
    // @param _options - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain
    function getFee(
        uint32 _dstEid,
        address _sender,
        uint256 _calldataSize,
        bytes calldata _options
    ) external view returns (uint256 price);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/interfaces/ILayerZeroPriceFeed.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface ILayerZeroPriceFeed {
    /**
     * @dev
     * priceRatio: (USD price of 1 unit of remote native token in unit of local native token) * PRICE_RATIO_DENOMINATOR
     */

    struct Price {
        uint128 priceRatio; // float value * 10 ^ 20, decimal awared. for aptos to evm, the basis would be (10^18 / 10^8) * 10 ^20 = 10 ^ 30.
        uint64 gasPriceInUnit; // for evm, it is in wei, for aptos, it is in octas.
        uint32 gasPerByte;
    }

    struct UpdatePrice {
        uint32 eid;
        Price price;
    }

    /**
     * @dev
     *    ArbGasInfo.go:GetPricesInArbGas
     *
     */
    struct ArbitrumPriceExt {
        uint64 gasPerL2Tx; // L2 overhead
        uint32 gasPerL1CallDataByte;
    }

    struct UpdatePriceExt {
        uint32 eid;
        Price price;
        ArbitrumPriceExt extend;
    }

    error LZ_PriceFeed_OnlyPriceUpdater();
    error LZ_PriceFeed_InsufficientFee(uint256 provided, uint256 required);
    error LZ_PriceFeed_UnknownL2Eid(uint32 l2Eid);

    function nativeTokenPriceUSD() external view returns (uint128);

    function getFee(uint32 _dstEid, uint256 _callDataSize, uint256 _gas) external view returns (uint256);

    function getPrice(uint32 _dstEid) external view returns (Price memory);

    function getPriceRatioDenominator() external view returns (uint128);

    function estimateFeeByEid(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) external view returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);

    function estimateFeeOnSend(
        uint32 _dstEid,
        uint256 _callDataSize,
        uint256 _gas
    ) external payable returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/interfaces/ILayerZeroTreasury.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface ILayerZeroTreasury {
    function getFee(
        address _sender,
        uint32 _dstEid,
        uint256 _totalNativeFee,
        bool _payInLzToken
    ) external view returns (uint256 fee);

    function payFee(
        address _sender,
        uint32 _dstEid,
        uint256 _totalNativeFee,
        bool _payInLzToken
    ) external payable returns (uint256 fee);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/interfaces/IWorker.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface IWorker {
    event SetWorkerLib(address workerLib);
    event SetPriceFeed(address priceFeed);
    event SetDefaultMultiplierBps(uint16 multiplierBps);
    event SetSupportedOptionTypes(uint32 dstEid, uint8[] optionTypes);
    event Withdraw(address lib, address to, uint256 amount);

    error Worker_NotAllowed();
    error Worker_OnlyMessageLib();
    error Worker_RoleRenouncingDisabled();

    function setPriceFeed(address _priceFeed) external;

    function priceFeed() external view returns (address);

    function setDefaultMultiplierBps(uint16 _multiplierBps) external;

    function defaultMultiplierBps() external view returns (uint16);

    function withdrawFee(address _lib, address _to, uint256 _amount) external;

    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external;

    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/libs/SafeCall.sol
================================================================================

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.20;

/// @dev copied from https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol.
library SafeCall {
    /// @notice calls a contract with a specified gas limit and value and captures the return data
    /// @param _target The address to call
    /// @param _gas The amount of gas to forward to the remote contract
    /// @param _value The value in wei to send to the remote contract
    /// to memory.
    /// @param _maxCopy The maximum number of bytes of returndata to copy
    /// to memory.
    /// @param _calldata The data to send to the remote contract
    /// @return success and returndata, as `.call()`. Returndata is capped to
    /// `_maxCopy` bytes.
    function safeCall(
        address _target,
        uint256 _gas,
        uint256 _value,
        uint16 _maxCopy,
        bytes memory _calldata
    ) internal returns (bool, bytes memory) {
        // check that target has code
        uint size;
        assembly {
            size := extcodesize(_target)
        }
        if (size == 0) {
            return (false, new bytes(0));
        }

        // set up for assembly call
        uint256 _toCopy;
        bool _success;
        bytes memory _returnData = new bytes(_maxCopy);
        // dispatch message to recipient
        // by assembly calling "handle" function
        // we call via assembly to avoid memcopying a very large returndata
        // returned by a malicious contract
        assembly {
            _success := call(
                _gas, // gas
                _target, // recipient
                _value, // ether value
                add(_calldata, 0x20), // inloc
                mload(_calldata), // inlen
                0, // outloc
                0 // outlen
            )
            // limit our copy to 100 bytes
            _toCopy := returndatasize()
            if gt(_toCopy, _maxCopy) {
                _toCopy := _maxCopy
            }
            // Store the length of the copied bytes
            mstore(_returnData, _toCopy)
            // copy the bytes from returndata[0:_toCopy]
            returndatacopy(add(_returnData, 0x20), 0, _toCopy)
        }
        return (_success, _returnData);
    }

    /// @notice Use when you _really_ really _really_ don't trust the called
    /// contract. This prevents the called contract from causing reversion of
    /// the caller in as many ways as we can.
    /// @dev The main difference between this and a solidity low-level call is
    /// that we limit the number of bytes that the callee can cause to be
    /// copied to caller memory. This prevents stupid things like malicious
    /// contracts returning 10,000,000 bytes causing a local OOG when copying
    /// to memory.
    /// @param _target The address to call
    /// @param _gas The amount of gas to forward to the remote contract
    /// @param _maxCopy The maximum number of bytes of returndata to copy
    /// to memory.
    /// @param _calldata The data to send to the remote contract
    /// @return success and returndata, as `.call()`. Returndata is capped to
    /// `_maxCopy` bytes.
    function safeStaticCall(
        address _target,
        uint256 _gas,
        uint16 _maxCopy,
        bytes memory _calldata
    ) internal view returns (bool, bytes memory) {
        // check that target has code
        uint size;
        assembly {
            size := extcodesize(_target)
        }
        if (size == 0) {
            return (false, new bytes(0));
        }

        // set up for assembly call
        uint256 _toCopy;
        bool _success;
        bytes memory _returnData = new bytes(_maxCopy);
        // dispatch message to recipient
        // by assembly calling "handle" function
        // we call via assembly to avoid memcopying a very large returndata
        // returned by a malicious contract
        assembly {
            _success := staticcall(
                _gas, // gas
                _target, // recipient
                add(_calldata, 0x20), // inloc
                mload(_calldata), // inlen
                0, // outloc
                0 // outlen
            )
            // limit our copy to 256 bytes
            _toCopy := returndatasize()
            if gt(_toCopy, _maxCopy) {
                _toCopy := _maxCopy
            }
            // Store the length of the copied bytes
            mstore(_returnData, _toCopy)
            // copy the bytes from returndata[0:_toCopy]
            returndatacopy(add(_returnData, 0x20), 0, _toCopy)
        }
        return (_success, _returnData);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/LzExecutor.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";

import { IReceiveUlnE2 } from "./interfaces/IReceiveUlnE2.sol";
import { ILayerZeroEndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { ExecutionState, EndpointV2ViewUpgradeable } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol";

import { VerificationState } from "./uln302/ReceiveUln302View.sol";

struct LzReceiveParam {
    Origin origin;
    address receiver;
    bytes32 guid;
    bytes message;
    bytes extraData;
    uint256 gas;
    uint256 value;
}

struct NativeDropParam {
    address _receiver;
    uint256 _amount;
}

interface IReceiveUlnView {
    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState);
}

contract LzExecutor is OwnableUpgradeable, EndpointV2ViewUpgradeable, Proxied {
    error LzExecutor_Executed();
    error LzExecutor_Verifying();
    error LzExecutor_ReceiveLibViewNotSet();

    event NativeWithdrawn(address _to, uint256 _amount);
    event ReceiveLibViewSet(address _receiveLib, address _receiveLibView);

    address public receiveUln302;
    uint32 public localEid;

    mapping(address receiveLib => address receiveLibView) public receiveLibToView;

    function initialize(
        address _receiveUln302,
        address _receiveUln302View,
        address _endpoint
    ) external proxied initializer {
        __Ownable_init();
        __EndpointV2View_init(_endpoint);

        receiveUln302 = _receiveUln302;
        localEid = endpoint.eid();
        receiveLibToView[_receiveUln302] = _receiveUln302View;
    }

    // ============================ OnlyOwner ===================================

    function withdrawNative(address _to, uint256 _amount) external onlyOwner {
        Transfer.native(_to, _amount);
        emit NativeWithdrawn(_to, _amount);
    }

    function setReceiveLibView(address _receiveLib, address _receiveLibView) external onlyOwner {
        receiveLibToView[_receiveLib] = _receiveLibView;
        emit ReceiveLibViewSet(_receiveLib, _receiveLibView);
    }

    // ============================ External ===================================

    /// @notice process for commit and execute
    /// 1. check if executable, revert if executed, execute if executable
    /// 2. check if verifiable, revert if verifying, commit if verifiable
    /// 3. native drop
    /// 4. try execute, will revert if not executable
    function commitAndExecute(
        address _receiveLib,
        LzReceiveParam calldata _lzReceiveParam,
        NativeDropParam[] calldata _nativeDropParams
    ) external payable {
        /// 1. check if executable, revert if executed
        ExecutionState executionState = executable(_lzReceiveParam.origin, _lzReceiveParam.receiver);
        if (executionState == ExecutionState.Executed) revert LzExecutor_Executed();

        /// 2. if not executable, check if verifiable, revert if verifying, commit if verifiable
        if (executionState != ExecutionState.Executable) {
            address receiveLib = receiveUln302 == address(0x0) ? _receiveLib : address(receiveUln302);
            bytes memory packetHeader = abi.encodePacked(
                uint8(1), // packet version 1
                _lzReceiveParam.origin.nonce,
                _lzReceiveParam.origin.srcEid,
                _lzReceiveParam.origin.sender,
                localEid,
                bytes32(uint256(uint160(_lzReceiveParam.receiver)))
            );
            bytes32 payloadHash = keccak256(abi.encodePacked(_lzReceiveParam.guid, _lzReceiveParam.message));

            address receiveLibView = receiveLibToView[receiveLib];
            if (receiveLibView == address(0x0)) revert LzExecutor_ReceiveLibViewNotSet();

            VerificationState verificationState = IReceiveUlnView(receiveLibView).verifiable(packetHeader, payloadHash);
            if (verificationState == VerificationState.Verifiable) {
                // verification required
                IReceiveUlnE2(receiveLib).commitVerification(packetHeader, payloadHash);
            } else if (verificationState == VerificationState.Verifying) {
                revert LzExecutor_Verifying();
            }
        }

        /// 3. native drop
        for (uint256 i = 0; i < _nativeDropParams.length; i++) {
            NativeDropParam calldata param = _nativeDropParams[i];
            Transfer.native(param._receiver, param._amount);
        }

        /// 4. try execute, will revert if not executable
        endpoint.lzReceive{ gas: _lzReceiveParam.gas, value: _lzReceiveParam.value }(
            _lzReceiveParam.origin,
            _lzReceiveParam.receiver,
            _lzReceiveParam.guid,
            _lzReceiveParam.message,
            _lzReceiveParam.extraData
        );
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/ReceiveUlnBase.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { UlnBase, UlnConfig } from "./UlnBase.sol";

struct Verification {
    bool submitted;
    uint64 confirmations;
}

/// @dev includes the utility functions for checking ULN states and logics
abstract contract ReceiveUlnBase is UlnBase {
    using PacketV1Codec for bytes;

    mapping(bytes32 headerHash => mapping(bytes32 payloadHash => mapping(address dvn => Verification)))
        public hashLookup;

    event PayloadVerified(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);

    error LZ_ULN_InvalidPacketHeader();
    error LZ_ULN_InvalidPacketVersion();
    error LZ_ULN_InvalidEid();
    error LZ_ULN_Verifying();

    // ============================ External ===================================
    function verifiable(
        UlnConfig memory _config,
        bytes32 _headerHash,
        bytes32 _payloadHash
    ) external view returns (bool) {
        return _checkVerifiable(_config, _headerHash, _payloadHash);
    }

    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure {
        _assertHeader(_packetHeader, _localEid);
    }

    // ============================ Internal ===================================
    /// @dev per DVN signing function
    function _verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) internal {
        hashLookup[keccak256(_packetHeader)][_payloadHash][msg.sender] = Verification(true, _confirmations);
        emit PayloadVerified(msg.sender, _packetHeader, _confirmations, _payloadHash);
    }

    function _verified(
        address _dvn,
        bytes32 _headerHash,
        bytes32 _payloadHash,
        uint64 _requiredConfirmation
    ) internal view returns (bool verified) {
        Verification memory verification = hashLookup[_headerHash][_payloadHash][_dvn];
        // return true if the dvn has signed enough confirmations
        verified = verification.submitted && verification.confirmations >= _requiredConfirmation;
    }

    function _verifyAndReclaimStorage(UlnConfig memory _config, bytes32 _headerHash, bytes32 _payloadHash) internal {
        if (!_checkVerifiable(_config, _headerHash, _payloadHash)) {
            revert LZ_ULN_Verifying();
        }

        // iterate the required DVNs
        if (_config.requiredDVNCount > 0) {
            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {
                delete hashLookup[_headerHash][_payloadHash][_config.requiredDVNs[i]];
            }
        }

        // iterate the optional DVNs
        if (_config.optionalDVNCount > 0) {
            for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {
                delete hashLookup[_headerHash][_payloadHash][_config.optionalDVNs[i]];
            }
        }
    }

    function _assertHeader(bytes calldata _packetHeader, uint32 _localEid) internal pure {
        // assert packet header is of right size 81
        if (_packetHeader.length != 81) revert LZ_ULN_InvalidPacketHeader();
        // assert packet header version is the same as ULN
        if (_packetHeader.version() != PacketV1Codec.PACKET_VERSION) revert LZ_ULN_InvalidPacketVersion();
        // assert the packet is for this endpoint
        if (_packetHeader.dstEid() != _localEid) revert LZ_ULN_InvalidEid();
    }

    /// @dev for verifiable view function
    /// @dev checks if this verification is ready to be committed to the endpoint
    function _checkVerifiable(
        UlnConfig memory _config,
        bytes32 _headerHash,
        bytes32 _payloadHash
    ) internal view returns (bool) {
        // iterate the required DVNs
        if (_config.requiredDVNCount > 0) {
            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {
                if (!_verified(_config.requiredDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {
                    // return if any of the required DVNs haven't signed
                    return false;
                }
            }
            if (_config.optionalDVNCount == 0) {
                // returns early if all required DVNs have signed and there are no optional DVNs
                return true;
            }
        }

        // then it must require optional validations
        uint8 threshold = _config.optionalDVNThreshold;
        for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {
            if (_verified(_config.optionalDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {
                // increment the optional count if the optional DVN has signed
                threshold--;
                if (threshold == 0) {
                    // early return if the optional threshold has hit
                    return true;
                }
            }
        }

        // return false as a catch-all
        return false;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/SendUlnBase.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { ILayerZeroDVN } from "./interfaces/ILayerZeroDVN.sol";
import { DVNOptions } from "./libs/DVNOptions.sol";
import { UlnOptions } from "./libs/UlnOptions.sol";
import { WorkerOptions } from "../SendLibBase.sol";
import { UlnConfig, UlnBase } from "./UlnBase.sol";

/// @dev includes the utility functions for checking ULN states and logics
abstract contract SendUlnBase is UlnBase {
    event DVNFeePaid(address[] requiredDVNs, address[] optionalDVNs, uint256[] fees);

    function _splitUlnOptions(bytes calldata _options) internal pure returns (bytes memory, WorkerOptions[] memory) {
        (bytes memory executorOpts, bytes memory dvnOpts) = UlnOptions.decode(_options);

        if (dvnOpts.length == 0) {
            return (executorOpts, new WorkerOptions[](0));
        }

        WorkerOptions[] memory workerOpts = new WorkerOptions[](1);
        workerOpts[0] = WorkerOptions(DVNOptions.WORKER_ID, dvnOpts);
        return (executorOpts, workerOpts);
    }

    /// ---------- pay and assign jobs ----------

    function _payDVNs(
        mapping(address => uint256) storage _fees,
        Packet memory _packet,
        WorkerOptions[] memory _options
    ) internal returns (uint256 totalFee, bytes memory encodedPacket) {
        bytes memory packetHeader = PacketV1Codec.encodePacketHeader(_packet);
        bytes memory payload = PacketV1Codec.encodePayload(_packet);
        bytes32 payloadHash = keccak256(payload);
        uint32 dstEid = _packet.dstEid;
        address sender = _packet.sender;
        UlnConfig memory config = getUlnConfig(sender, dstEid);

        // if options is not empty, it must be dvn options
        bytes memory dvnOptions = _options.length == 0 ? bytes("") : _options[0].options;
        uint256[] memory dvnFees;
        (totalFee, dvnFees) = _assignJobs(
            _fees,
            config,
            ILayerZeroDVN.AssignJobParam(dstEid, packetHeader, payloadHash, config.confirmations, sender),
            dvnOptions
        );
        encodedPacket = abi.encodePacked(packetHeader, payload);

        emit DVNFeePaid(config.requiredDVNs, config.optionalDVNs, dvnFees);
    }

    function _assignJobs(
        mapping(address => uint256) storage _fees,
        UlnConfig memory _ulnConfig,
        ILayerZeroDVN.AssignJobParam memory _param,
        bytes memory dvnOptions
    ) internal returns (uint256 totalFee, uint256[] memory dvnFees) {
        (bytes[] memory optionsArray, uint8[] memory dvnIds) = DVNOptions.groupDVNOptionsByIdx(dvnOptions);

        uint8 dvnsLength = _ulnConfig.requiredDVNCount + _ulnConfig.optionalDVNCount;
        dvnFees = new uint256[](dvnsLength);
        for (uint8 i = 0; i < dvnsLength; ++i) {
            address dvn = i < _ulnConfig.requiredDVNCount
                ? _ulnConfig.requiredDVNs[i]
                : _ulnConfig.optionalDVNs[i - _ulnConfig.requiredDVNCount];

            bytes memory options = "";
            for (uint256 j = 0; j < dvnIds.length; ++j) {
                if (dvnIds[j] == i) {
                    options = optionsArray[j];
                    break;
                }
            }

            dvnFees[i] = ILayerZeroDVN(dvn).assignJob(_param, options);
            if (dvnFees[i] > 0) {
                _fees[dvn] += dvnFees[i];
                totalFee += dvnFees[i];
            }
        }
    }

    /// ---------- quote ----------
    function _quoteDVNs(
        address _sender,
        uint32 _dstEid,
        WorkerOptions[] memory _options
    ) internal view returns (uint256 totalFee) {
        UlnConfig memory config = getUlnConfig(_sender, _dstEid);

        // if options is not empty, it must be dvn options
        bytes memory dvnOptions = _options.length == 0 ? bytes("") : _options[0].options;
        (bytes[] memory optionsArray, uint8[] memory dvnIndices) = DVNOptions.groupDVNOptionsByIdx(dvnOptions);

        totalFee = _getFees(config, _dstEid, _sender, optionsArray, dvnIndices);
    }

    function _getFees(
        UlnConfig memory _config,
        uint32 _dstEid,
        address _sender,
        bytes[] memory _optionsArray,
        uint8[] memory _dvnIds
    ) internal view returns (uint256 totalFee) {
        // here we merge 2 list of dvns into 1 to allocate the indexed dvn options to the right dvn
        uint8 dvnsLength = _config.requiredDVNCount + _config.optionalDVNCount;
        for (uint8 i = 0; i < dvnsLength; ++i) {
            address dvn = i < _config.requiredDVNCount
                ? _config.requiredDVNs[i]
                : _config.optionalDVNs[i - _config.requiredDVNCount];

            bytes memory options = "";
            // it is a double loop here. however, if the list is short, the cost is very acceptable.
            for (uint256 j = 0; j < _dvnIds.length; ++j) {
                if (_dvnIds[j] == i) {
                    options = _optionsArray[j];
                    break;
                }
            }
            totalFee += ILayerZeroDVN(dvn).getFee(_dstEid, _config.confirmations, _sender, options);
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/UlnBase.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

// the formal properties are documented in the setter functions
struct UlnConfig {
    uint64 confirmations;
    // we store the length of required DVNs and optional DVNs instead of using DVN.length directly to save gas
    uint8 requiredDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)
    uint8 optionalDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)
    uint8 optionalDVNThreshold; // (0, optionalDVNCount]
    address[] requiredDVNs; // no duplicates. sorted an an ascending order. allowed overlap with optionalDVNs
    address[] optionalDVNs; // no duplicates. sorted an an ascending order. allowed overlap with requiredDVNs
}

struct SetDefaultUlnConfigParam {
    uint32 eid;
    UlnConfig config;
}

/// @dev includes the utility functions for checking ULN states and logics
abstract contract UlnBase is Ownable {
    address private constant DEFAULT_CONFIG = address(0);
    // reserved values for
    uint8 internal constant DEFAULT = 0;
    uint8 internal constant NIL_DVN_COUNT = type(uint8).max;
    uint64 internal constant NIL_CONFIRMATIONS = type(uint64).max;
    // 127 to prevent total number of DVNs (127 * 2) exceeding uint8.max (255)
    // by limiting the total size, it would help constraint the design of DVNOptions
    uint8 private constant MAX_COUNT = (type(uint8).max - 1) / 2;

    mapping(address oapp => mapping(uint32 eid => UlnConfig)) internal ulnConfigs;

    error LZ_ULN_Unsorted();
    error LZ_ULN_InvalidRequiredDVNCount();
    error LZ_ULN_InvalidOptionalDVNCount();
    error LZ_ULN_AtLeastOneDVN();
    error LZ_ULN_InvalidOptionalDVNThreshold();
    error LZ_ULN_InvalidConfirmations();
    error LZ_ULN_UnsupportedEid(uint32 eid);

    event DefaultUlnConfigsSet(SetDefaultUlnConfigParam[] params);
    event UlnConfigSet(address oapp, uint32 eid, UlnConfig config);

    // ============================ OnlyOwner ===================================

    /// @dev about the DEFAULT ULN config
    /// 1) its values are all LITERAL (e.g. 0 is 0). whereas in the oapp ULN config, 0 (default value) points to the default ULN config
    ///     this design enables the oapp to point to DEFAULT config without explicitly setting the config
    /// 2) its configuration is more restrictive than the oapp ULN config that
    ///     a) it must not use NIL value, where NIL is used only by oapps to indicate the LITERAL 0
    ///     b) it must have at least one DVN
    function setDefaultUlnConfigs(SetDefaultUlnConfigParam[] calldata _params) external onlyOwner {
        for (uint256 i = 0; i < _params.length; ++i) {
            SetDefaultUlnConfigParam calldata param = _params[i];

            // 2.a must not use NIL
            if (param.config.requiredDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidRequiredDVNCount();
            if (param.config.optionalDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidOptionalDVNCount();
            if (param.config.confirmations == NIL_CONFIRMATIONS) revert LZ_ULN_InvalidConfirmations();

            // 2.b must have at least one dvn
            _assertAtLeastOneDVN(param.config);

            _setConfig(DEFAULT_CONFIG, param.eid, param.config);
        }
        emit DefaultUlnConfigsSet(_params);
    }

    // ============================ View ===================================
    // @dev assuming most oapps use default, we get default as memory and custom as storage to save gas
    function getUlnConfig(address _oapp, uint32 _remoteEid) public view returns (UlnConfig memory rtnConfig) {
        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];
        UlnConfig storage customConfig = ulnConfigs[_oapp][_remoteEid];

        // if confirmations is 0, use default
        uint64 confirmations = customConfig.confirmations;
        if (confirmations == DEFAULT) {
            rtnConfig.confirmations = defaultConfig.confirmations;
        } else if (confirmations != NIL_CONFIRMATIONS) {
            // if confirmations is uint64.max, no block confirmations required
            rtnConfig.confirmations = confirmations;
        } // else do nothing, rtnConfig.confirmation is 0

        if (customConfig.requiredDVNCount == DEFAULT) {
            if (defaultConfig.requiredDVNCount > 0) {
                // copy only if count > 0. save gas
                rtnConfig.requiredDVNs = defaultConfig.requiredDVNs;
                rtnConfig.requiredDVNCount = defaultConfig.requiredDVNCount;
            } // else, do nothing
        } else {
            if (customConfig.requiredDVNCount != NIL_DVN_COUNT) {
                rtnConfig.requiredDVNs = customConfig.requiredDVNs;
                rtnConfig.requiredDVNCount = customConfig.requiredDVNCount;
            } // else, do nothing
        }

        if (customConfig.optionalDVNCount == DEFAULT) {
            if (defaultConfig.optionalDVNCount > 0) {
                // copy only if count > 0. save gas
                rtnConfig.optionalDVNs = defaultConfig.optionalDVNs;
                rtnConfig.optionalDVNCount = defaultConfig.optionalDVNCount;
                rtnConfig.optionalDVNThreshold = defaultConfig.optionalDVNThreshold;
            }
        } else {
            if (customConfig.optionalDVNCount != NIL_DVN_COUNT) {
                rtnConfig.optionalDVNs = customConfig.optionalDVNs;
                rtnConfig.optionalDVNCount = customConfig.optionalDVNCount;
                rtnConfig.optionalDVNThreshold = customConfig.optionalDVNThreshold;
            }
        }

        // the final value must have at least one dvn
        // it is possible that some default config result into 0 dvns
        _assertAtLeastOneDVN(rtnConfig);
    }

    /// @dev Get the uln config without the default config for the given remoteEid.
    function getAppUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory) {
        return ulnConfigs[_oapp][_remoteEid];
    }

    // ============================ Internal ===================================
    function _setUlnConfig(uint32 _remoteEid, address _oapp, UlnConfig memory _param) internal {
        _setConfig(_oapp, _remoteEid, _param);

        // get ULN config again as a catch all to ensure the config is valid
        getUlnConfig(_oapp, _remoteEid);
        emit UlnConfigSet(_oapp, _remoteEid, _param);
    }

    /// @dev a supported Eid must have a valid default uln config, which has at least one dvn
    function _isSupportedEid(uint32 _remoteEid) internal view returns (bool) {
        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];
        return defaultConfig.requiredDVNCount > 0 || defaultConfig.optionalDVNThreshold > 0;
    }

    function _assertSupportedEid(uint32 _remoteEid) internal view {
        if (!_isSupportedEid(_remoteEid)) revert LZ_ULN_UnsupportedEid(_remoteEid);
    }

    // ============================ Private ===================================

    function _assertAtLeastOneDVN(UlnConfig memory _config) private pure {
        if (_config.requiredDVNCount == 0 && _config.optionalDVNThreshold == 0) revert LZ_ULN_AtLeastOneDVN();
    }

    /// @dev this private function is used in both setDefaultUlnConfigs and setUlnConfig
    function _setConfig(address _oapp, uint32 _eid, UlnConfig memory _param) private {
        // @dev required dvns
        // if dvnCount == NONE, dvns list must be empty
        // if dvnCount == DEFAULT, dvn list must be empty
        // otherwise, dvnList.length == dvnCount and assert the list is valid
        if (_param.requiredDVNCount == NIL_DVN_COUNT || _param.requiredDVNCount == DEFAULT) {
            if (_param.requiredDVNs.length != 0) revert LZ_ULN_InvalidRequiredDVNCount();
        } else {
            if (_param.requiredDVNs.length != _param.requiredDVNCount || _param.requiredDVNCount > MAX_COUNT)
                revert LZ_ULN_InvalidRequiredDVNCount();
            _assertNoDuplicates(_param.requiredDVNs);
        }

        // @dev optional dvns
        // if optionalDVNCount == NONE, optionalDVNs list must be empty and threshold must be 0
        // if optionalDVNCount == DEFAULT, optionalDVNs list must be empty and threshold must be 0
        // otherwise, optionalDVNs.length == optionalDVNCount, threshold > 0 && threshold <= optionalDVNCount and assert the list is valid

        // example use case: an oapp uses the DEFAULT 'required' but
        //     a) use a custom 1/1 dvn (practically a required dvn), or
        //     b) use a custom 2/3 dvn
        if (_param.optionalDVNCount == NIL_DVN_COUNT || _param.optionalDVNCount == DEFAULT) {
            if (_param.optionalDVNs.length != 0) revert LZ_ULN_InvalidOptionalDVNCount();
            if (_param.optionalDVNThreshold != 0) revert LZ_ULN_InvalidOptionalDVNThreshold();
        } else {
            if (_param.optionalDVNs.length != _param.optionalDVNCount || _param.optionalDVNCount > MAX_COUNT)
                revert LZ_ULN_InvalidOptionalDVNCount();
            if (_param.optionalDVNThreshold == 0 || _param.optionalDVNThreshold > _param.optionalDVNCount)
                revert LZ_ULN_InvalidOptionalDVNThreshold();
            _assertNoDuplicates(_param.optionalDVNs);
        }
        // don't assert valid count here, as it needs to be validated along side default config

        ulnConfigs[_oapp][_eid] = _param;
    }

    function _assertNoDuplicates(address[] memory _dvns) private pure {
        address lastDVN = address(0);
        for (uint256 i = 0; i < _dvns.length; i++) {
            address dvn = _dvns[i];
            if (dvn <= lastDVN) revert LZ_ULN_Unsorted(); // to ensure no duplicates
            lastDVN = dvn;
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/DVN.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { ILayerZeroUltraLightNodeV2 } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUltraLightNodeV2.sol";

import { Worker } from "../../Worker.sol";
import { MultiSig } from "./MultiSig.sol";
import { IDVN } from "../interfaces/IDVN.sol";
import { IDVNFeeLib } from "../interfaces/IDVNFeeLib.sol";
import { IReceiveUlnE2 } from "../interfaces/IReceiveUlnE2.sol";

struct ExecuteParam {
    uint32 vid;
    address target;
    bytes callData;
    uint256 expiration;
    bytes signatures;
}

contract DVN is Worker, MultiSig, IDVN {
    // to uniquely identify this DVN instance
    // set to endpoint v1 eid if available OR endpoint v2 eid % 30_000
    uint32 public immutable vid;

    mapping(uint32 dstEid => DstConfig) public dstConfig;
    mapping(bytes32 executableHash => bool used) public usedHashes;

    error DVN_OnlySelf();
    error DVN_InvalidRole(bytes32 role);
    error DVN_InstructionExpired();
    error DVN_InvalidTarget(address target);
    error DVN_InvalidVid(uint32 vid);
    error DVN_InvalidSignatures();
    error DVN_DuplicatedHash(bytes32 executableHash);

    event VerifySignaturesFailed(uint256 idx);
    event ExecuteFailed(uint256 _index, bytes _data);
    event HashAlreadyUsed(ExecuteParam param, bytes32 _hash);
    // same as DVNFeePaid, but for ULNv2
    event VerifierFeePaid(uint256 fee);

    // ========================= Constructor =========================

    /// @dev DVN doesn't have a roleAdmin (address(0x0))
    /// @dev Supports all of ULNv2, ULN301, ULN302 and more
    /// @param _vid unique identifier for this DVN instance
    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE
    /// @param _priceFeed price feed address
    /// @param _signers array of signer addresses for multisig
    /// @param _quorum quorum for multisig
    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE
    constructor(
        uint32 _vid,
        address[] memory _messageLibs,
        address _priceFeed,
        address[] memory _signers,
        uint64 _quorum,
        address[] memory _admins
    ) Worker(_messageLibs, _priceFeed, 12000, address(0x0), _admins) MultiSig(_signers, _quorum) {
        vid = _vid;
    }

    // ========================= Modifier =========================

    /// @dev depending on role, restrict access to only self or admin
    /// @dev ALLOWLIST, DENYLIST, MESSAGE_LIB_ROLE can only be granted/revoked by self
    /// @dev ADMIN_ROLE can only be granted/revoked by admin
    /// @dev reverts if not one of the above roles
    /// @param _role role to check
    modifier onlySelfOrAdmin(bytes32 _role) {
        if (_role == ALLOWLIST || _role == DENYLIST || _role == MESSAGE_LIB_ROLE) {
            // self required
            if (address(this) != msg.sender) {
                revert DVN_OnlySelf();
            }
        } else if (_role == ADMIN_ROLE) {
            // admin required
            _checkRole(ADMIN_ROLE);
        } else {
            revert DVN_InvalidRole(_role);
        }
        _;
    }

    modifier onlySelf() {
        if (address(this) != msg.sender) {
            revert DVN_OnlySelf();
        }
        _;
    }

    // ========================= OnlySelf =========================

    /// @dev set signers for multisig
    /// @dev function sig 0x31cb6105
    /// @param _signer signer address
    /// @param _active true to add, false to remove
    function setSigner(address _signer, bool _active) external onlySelf {
        _setSigner(_signer, _active);
    }

    /// @dev set quorum for multisig
    /// @dev function sig 0x8585c945
    /// @param _quorum to set
    function setQuorum(uint64 _quorum) external onlySelf {
        _setQuorum(_quorum);
    }

    // ========================= OnlySelf / OnlyAdmin =========================

    /// @dev overrides AccessControl to allow self/admin to grant role'
    /// @dev function sig 0x2f2ff15d
    /// @param _role role to grant
    /// @param _account account to grant role to
    function grantRole(bytes32 _role, address _account) public override onlySelfOrAdmin(_role) {
        _grantRole(_role, _account);
    }

    /// @dev overrides AccessControl to allow self/admin to revoke role
    /// @dev function sig 0xd547741f
    /// @param _role role to revoke
    /// @param _account account to revoke role from
    function revokeRole(bytes32 _role, address _account) public override onlySelfOrAdmin(_role) {
        _revokeRole(_role, _account);
    }

    // ========================= OnlyQuorum =========================

    /// @notice function for quorum to change admin without going through execute function
    /// @dev calldata in the case is abi.encode new admin address
    function quorumChangeAdmin(ExecuteParam calldata _param) external {
        if (_param.expiration <= block.timestamp) {
            revert DVN_InstructionExpired();
        }
        if (_param.target != address(this)) {
            revert DVN_InvalidTarget(_param.target);
        }
        if (_param.vid != vid) {
            revert DVN_InvalidVid(_param.vid);
        }

        // generate and validate hash
        bytes32 hash = hashCallData(_param.vid, _param.target, _param.callData, _param.expiration);
        (bool sigsValid, ) = verifySignatures(hash, _param.signatures);
        if (!sigsValid) {
            revert DVN_InvalidSignatures();
        }
        if (usedHashes[hash]) {
            revert DVN_DuplicatedHash(hash);
        }

        usedHashes[hash] = true;
        _grantRole(ADMIN_ROLE, abi.decode(_param.callData, (address)));
    }

    // ========================= OnlyAdmin =========================

    /// @param _params array of DstConfigParam
    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; ++i) {
            DstConfigParam calldata param = _params[i];
            dstConfig[param.dstEid] = DstConfig(param.gas, param.multiplierBps, param.floorMarginUSD);
        }
        emit SetDstConfig(_params);
    }

    /// @dev takes a list of instructions and executes them in order
    /// @dev if any of the instructions fail, it will emit an error event and continue to execute the rest of the instructions
    /// @param _params array of ExecuteParam, includes target, callData, expiration, signatures
    function execute(ExecuteParam[] calldata _params) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; ++i) {
            ExecuteParam calldata param = _params[i];
            // 1. skip if invalid vid
            if (param.vid != vid) {
                continue;
            }

            // 2. skip if expired
            if (param.expiration <= block.timestamp) {
                continue;
            }

            // generate and validate hash
            bytes32 hash = hashCallData(param.vid, param.target, param.callData, param.expiration);

            // 3. check signatures
            (bool sigsValid, ) = verifySignatures(hash, param.signatures);
            if (!sigsValid) {
                emit VerifySignaturesFailed(i);
                continue;
            }

            // 4. should check hash
            bool shouldCheckHash = _shouldCheckHash(bytes4(param.callData));
            if (shouldCheckHash) {
                if (usedHashes[hash]) {
                    emit HashAlreadyUsed(param, hash);
                    continue;
                } else {
                    usedHashes[hash] = true; // prevent reentry and replay attack
                }
            }

            (bool success, bytes memory rtnData) = param.target.call(param.callData);
            if (!success) {
                if (shouldCheckHash) {
                    // need to unset the usedHash otherwise it cant be used
                    usedHashes[hash] = false;
                }
                // emit an event in any case
                emit ExecuteFailed(i, rtnData);
            }
        }
    }

    /// @dev to support ULNv2
    /// @dev the withdrawFee function for ULN30X is built in the Worker contract
    /// @param _lib message lib address
    /// @param _to address to withdraw to
    /// @param _amount amount to withdraw
    function withdrawFeeFromUlnV2(address _lib, address payable _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {
        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) {
            revert Worker_OnlyMessageLib();
        }
        ILayerZeroUltraLightNodeV2(_lib).withdrawNative(_to, _amount);
    }

    // ========================= OnlyMessageLib =========================

    /// @dev for ULN301, ULN302 and more to assign job
    /// @dev dvn network can reject job from _sender by adding/removing them from allowlist/denylist
    /// @param _param assign job param
    /// @param _options dvn options
    function assignJob(
        AssignJobParam calldata _param,
        bytes calldata _options
    ) external payable onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_param.sender) returns (uint256 totalFee) {
        IDVNFeeLib.FeeParams memory feeParams = IDVNFeeLib.FeeParams(
            priceFeed,
            _param.dstEid,
            _param.confirmations,
            _param.sender,
            quorum,
            defaultMultiplierBps
        );
        totalFee = IDVNFeeLib(workerFeeLib).getFeeOnSend(feeParams, dstConfig[_param.dstEid], _options);
    }

    /// @dev to support ULNv2
    /// @dev dvn network can reject job from _sender by adding/removing them from allowlist/denylist
    /// @param _dstEid destination EndpointId
    /// @param //_outboundProofType outbound proof type
    /// @param _confirmations block confirmations
    /// @param _sender message sender address
    function assignJob(
        uint16 _dstEid,
        uint16 /*_outboundProofType*/,
        uint64 _confirmations,
        address _sender
    ) external onlyRole(MESSAGE_LIB_ROLE) onlyAcl(_sender) returns (uint256 totalFee) {
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            priceFeed,
            _dstEid,
            _confirmations,
            _sender,
            quorum,
            defaultMultiplierBps
        );
        // ULNV2 does not have dvn options
        totalFee = IDVNFeeLib(workerFeeLib).getFeeOnSend(params, dstConfig[_dstEid], bytes(""));
        emit VerifierFeePaid(totalFee);
    }

    // ========================= View =========================

    /// @dev getFee can revert if _sender doesn't pass ACL
    /// @param _dstEid destination EndpointId
    /// @param _confirmations block confirmations
    /// @param _sender message sender address
    /// @param _options dvn options
    /// @return fee fee in native amount
    function getFee(
        uint32 _dstEid,
        uint64 _confirmations,
        address _sender,
        bytes calldata _options
    ) external view onlyAcl(_sender) returns (uint256 fee) {
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            priceFeed,
            _dstEid,
            _confirmations,
            _sender,
            quorum,
            defaultMultiplierBps
        );
        return IDVNFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], _options);
    }

    /// @dev to support ULNv2
    /// @dev getFee can revert if _sender doesn't pass ACL
    /// @param _dstEid destination EndpointId
    /// @param //_outboundProofType outbound proof type
    /// @param _confirmations block confirmations
    /// @param _sender message sender address
    function getFee(
        uint16 _dstEid,
        uint16 /*_outboundProofType*/,
        uint64 _confirmations,
        address _sender
    ) public view onlyAcl(_sender) returns (uint256 fee) {
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            priceFeed,
            _dstEid,
            _confirmations,
            _sender,
            quorum,
            defaultMultiplierBps
        );
        return IDVNFeeLib(workerFeeLib).getFee(params, dstConfig[_dstEid], bytes(""));
    }

    /// @param _target target address
    /// @param _callData call data
    /// @param _expiration expiration timestamp
    /// @return hash of above
    function hashCallData(
        uint32 _vid,
        address _target,
        bytes calldata _callData,
        uint256 _expiration
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_vid, _target, _expiration, _callData));
    }

    // ========================= Internal =========================

    /// @dev to save gas, we don't check hash for some functions (where replaying won't change the state)
    /// @dev for example, some administrative functions like changing signers, the contract should check hash to double spending
    /// @dev should ensure that all onlySelf functions have unique functionSig
    /// @param _functionSig function signature
    /// @return true if should check hash
    function _shouldCheckHash(bytes4 _functionSig) internal pure returns (bool) {
        // never check for these selectors to save gas
        return
            _functionSig != IReceiveUlnE2.verify.selector && // 0x0223536e, replaying won't change the state
            _functionSig != ILayerZeroUltraLightNodeV2.updateHash.selector; // 0x704316e5, replaying will be revert at uln
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/DVNFeeLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { ILayerZeroPriceFeed } from "../../interfaces/ILayerZeroPriceFeed.sol";
import { IDVN } from "../interfaces/IDVN.sol";
import { IDVNFeeLib } from "../interfaces/IDVNFeeLib.sol";
import { DVNOptions } from "../libs/DVNOptions.sol";

contract DVNFeeLib is Ownable, IDVNFeeLib {
    using DVNOptions for bytes;

    uint16 internal constant EXECUTE_FIXED_BYTES = 68; // encoded: funcSigHash + params -> 4  + (32 * 2)
    uint16 internal constant SIGNATURE_RAW_BYTES = 65; // not encoded
    // callData(updateHash) = 132 (4 + 32 * 4), padded to 32 = 160 and encoded as bytes with an 64 byte overhead = 224
    uint16 internal constant UPDATE_HASH_BYTES = 224;

    uint256 private immutable nativeDecimalsRate;

    constructor(uint256 _nativeDecimalsRate) {
        nativeDecimalsRate = _nativeDecimalsRate;
    }

    // ================================ OnlyOwner ================================
    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {
        // transfers native if _token is address(0x0)
        Transfer.nativeOrToken(_token, _to, _amount);
    }

    // ========================= External =========================
    /// @dev get fee function that can change state. e.g. paying priceFeed
    /// @param _params fee params
    /// @param _dstConfig dst config
    /// @param //_options options
    function getFeeOnSend(
        FeeParams calldata _params,
        IDVN.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external payable returns (uint256) {
        if (_dstConfig.gas == 0) revert DVN_EidNotSupported(_params.dstEid);

        _decodeDVNOptions(_options); // todo: validate options

        uint256 callDataSize = _getCallDataSize(_params.quorum);

        // for future versions where priceFeed charges a fee
        //        uint256 priceFeedFee = ILayerZeroPriceFeed(_params.priceFeed).getFee(_params.dstEid, callDataSize, _dstConfig.gas);
        //        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeOnSend{
        //            value: priceFeedFee
        //        }(_params.dstEid, callDataSize, _dstConfig.gas);

        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeOnSend(
            _params.dstEid,
            callDataSize,
            _dstConfig.gas
        );

        return
            _applyPremium(
                fee,
                _dstConfig.multiplierBps,
                _params.defaultMultiplierBps,
                _dstConfig.floorMarginUSD,
                nativePriceUSD
            );
    }

    // ========================= View =========================
    /// @dev get fee view function
    /// @param _params fee params
    /// @param _dstConfig dst config
    /// @param //_options options
    function getFee(
        FeeParams calldata _params,
        IDVN.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external view returns (uint256) {
        if (_dstConfig.gas == 0) revert DVN_EidNotSupported(_params.dstEid);

        _decodeDVNOptions(_options); // validate options

        uint256 callDataSize = _getCallDataSize(_params.quorum);
        (uint256 fee, , , uint128 nativePriceUSD) = ILayerZeroPriceFeed(_params.priceFeed).estimateFeeByEid(
            _params.dstEid,
            callDataSize,
            _dstConfig.gas
        );
        return
            _applyPremium(
                fee,
                _dstConfig.multiplierBps,
                _params.defaultMultiplierBps,
                _dstConfig.floorMarginUSD,
                nativePriceUSD
            );
    }

    // ========================= Internal =========================
    function _getCallDataSize(uint256 _quorum) internal pure returns (uint256) {
        uint256 totalSignatureBytes = _quorum * SIGNATURE_RAW_BYTES;
        if (totalSignatureBytes % 32 != 0) {
            totalSignatureBytes = totalSignatureBytes - (totalSignatureBytes % 32) + 32;
        }
        // getFee should charge on execute(updateHash)
        // totalSignatureBytesPadded also has 64 overhead for bytes
        return uint256(EXECUTE_FIXED_BYTES) + UPDATE_HASH_BYTES + totalSignatureBytes + 64;
    }

    function _applyPremium(
        uint256 _fee,
        uint16 _bps,
        uint16 _defaultBps,
        uint128 _marginUSD,
        uint128 _nativePriceUSD
    ) internal view returns (uint256) {
        uint16 multiplierBps = _bps == 0 ? _defaultBps : _bps;

        uint256 feeWithMultiplier = (_fee * multiplierBps) / 10000;
        if (_nativePriceUSD == 0 || _marginUSD == 0) {
            return feeWithMultiplier;
        }

        uint256 feeWithFloorMargin = _fee + (_marginUSD * nativeDecimalsRate) / _nativePriceUSD;

        return feeWithFloorMargin > feeWithMultiplier ? feeWithFloorMargin : feeWithMultiplier;
    }

    function _decodeDVNOptions(bytes calldata _options) internal pure returns (uint256) {
        uint256 cursor;
        while (cursor < _options.length) {
            (uint8 optionType, , uint256 newCursor) = _options.nextDVNOption(cursor);
            cursor = newCursor;
            revert DVN_UnsupportedOptionType(optionType);
        }
        if (cursor != _options.length) revert DVNOptions.DVN_InvalidDVNOptions(cursor);

        return 0; // todo: precrime fee model
    }

    // send funds here to pay for price feed directly
    receive() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/MultiSig.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { ECDSA } from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

abstract contract MultiSig {
    enum Errors {
        NoError,
        SignatureError,
        DuplicatedSigner,
        SignerNotInCommittee
    }

    mapping(address signer => bool active) public signers;
    uint64 public signerSize;
    uint64 public quorum;

    error MultiSig_OnlySigner();
    error MultiSig_QuorumIsZero();
    error MultiSig_SignersSizeIsLessThanQuorum(uint64 signersSize, uint64 quorum);
    error MultiSig_UnorderedSigners();
    error MultiSig_StateAlreadySet(address signer, bool active);

    event UpdateSigner(address _signer, bool _active);
    event UpdateQuorum(uint64 _quorum);

    modifier onlySigner() {
        if (!signers[msg.sender]) {
            revert MultiSig_OnlySigner();
        }
        _;
    }

    constructor(address[] memory _signers, uint64 _quorum) {
        if (_quorum == 0) {
            revert MultiSig_QuorumIsZero();
        }
        if (_signers.length < _quorum) {
            revert MultiSig_SignersSizeIsLessThanQuorum(uint64(_signers.length), _quorum);
        }
        address lastSigner = address(0);
        for (uint256 i = 0; i < _signers.length; i++) {
            address signer = _signers[i];
            if (signer <= lastSigner) {
                revert MultiSig_UnorderedSigners();
            }
            signers[signer] = true;
            lastSigner = signer;
        }
        signerSize = uint64(_signers.length);
        quorum = _quorum;
    }

    function _setSigner(address _signer, bool _active) internal {
        if (signers[_signer] == _active) {
            revert MultiSig_StateAlreadySet(_signer, _active);
        }
        signers[_signer] = _active;
        uint64 _signerSize = _active ? signerSize + 1 : signerSize - 1;
        uint64 _quorum = quorum;
        if (_signerSize < _quorum) {
            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);
        }
        signerSize = _signerSize;
        emit UpdateSigner(_signer, _active);
    }

    function _setQuorum(uint64 _quorum) internal {
        if (_quorum == 0) {
            revert MultiSig_QuorumIsZero();
        }
        uint64 _signerSize = signerSize;
        if (_signerSize < _quorum) {
            revert MultiSig_SignersSizeIsLessThanQuorum(_signerSize, _quorum);
        }
        quorum = _quorum;
        emit UpdateQuorum(_quorum);
    }

    function verifySignatures(bytes32 _hash, bytes calldata _signatures) public view returns (bool, Errors) {
        if (_signatures.length != uint256(quorum) * 65) {
            return (false, Errors.SignatureError);
        }

        bytes32 messageDigest = _getEthSignedMessageHash(_hash);

        address lastSigner = address(0); // There cannot be a signer with address 0.
        for (uint256 i = 0; i < quorum; i++) {
            bytes calldata signature = _signatures[i * 65:(i + 1) * 65];
            (address currentSigner, ECDSA.RecoverError error) = ECDSA.tryRecover(messageDigest, signature);

            if (error != ECDSA.RecoverError.NoError) return (false, Errors.SignatureError);
            if (currentSigner <= lastSigner) return (false, Errors.DuplicatedSigner); // prevent duplicate signatures
            if (!signers[currentSigner]) return (false, Errors.SignerNotInCommittee); // signature is not in committee
            lastSigner = currentSigner;
        }
        return (true, Errors.NoError);
    }

    function _getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash));
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/adapters/CCIP/CCIPDVNAdapter.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IRouterClient } from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";
import { IAny2EVMMessageReceiver } from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol";
import { Client } from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";

import { DVNAdapterBase } from "../DVNAdapterBase.sol";
import { ICCIPDVNAdapter } from "../../../interfaces/adapters/ICCIPDVNAdapter.sol";
import { ICCIPDVNAdapterFeeLib } from "../../../interfaces/adapters/ICCIPDVNAdapterFeeLib.sol";

/// @title CCIPDVNAdapter
/// @dev How CCIP DVN Adapter works:
/// 1. Estimate gas cost for the message on-chain by calling `getFee` on the Router contract.
///     refer to https://docs.chain.link/ccip/api-reference/i-router-client#getfee
/// 2. Call `ccipSend` on the Router contract to send the message.
///     refer to https://docs.chain.link/ccip/api-reference/i-router-client#ccipsend
/// @dev Recovery:
/// 1. If not enough gas paid, the message will be failed to execute on the destination chain, you can manually retry by calling `manuallyExecute` on the `OffRamp` contract.
///     refer to https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/offRamp/EVM2EVMOffRamp.sol#L222
contract CCIPDVNAdapter is DVNAdapterBase, IAny2EVMMessageReceiver, ICCIPDVNAdapter {
    address private constant NATIVE_GAS_TOKEN_ADDRESS = address(0);

    IRouterClient public router;

    mapping(uint32 dstEid => DstConfig config) public dstConfig;
    mapping(uint64 chainSelector => bytes peer) public peers;

    constructor(address[] memory _admins, address _router) DVNAdapterBase(msg.sender, _admins, 12000) {
        router = IRouterClient(_router);
    }

    // ========================= OnlyAdmin =========================
    /// @notice sets configuration for destination chains
    /// @param _params array of chain configurations
    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; i++) {
            DstConfigParam calldata param = _params[i];

            delete peers[dstConfig[param.dstEid].chainSelector]; // delete old peer in case chain by dstEid is updated
            peers[param.chainSelector] = param.peer;

            dstConfig[param.dstEid] = DstConfig({
                chainSelector: param.chainSelector,
                multiplierBps: param.multiplierBps,
                gas: param.gas,
                peer: param.peer
            });
        }

        emit DstConfigSet(_params);
    }

    function setRouter(address _router) external onlyRole(ADMIN_ROLE) {
        router = IRouterClient(_router);
        emit RouterSet(_router);
    }

    // ========================= OnlyMessageLib =========================
    function assignJob(
        AssignJobParam calldata _param,
        bytes calldata _options
    ) external payable override onlyAcl(_param.sender) returns (uint256 totalFee) {
        bytes32 receiveLib = _getAndAssertReceiveLib(msg.sender, _param.dstEid);

        ICCIPDVNAdapterFeeLib.Param memory feeLibParam = ICCIPDVNAdapterFeeLib.Param(
            _param.dstEid,
            _param.confirmations,
            _param.sender,
            defaultMultiplierBps
        );

        DstConfig memory config = dstConfig[_param.dstEid];

        bytes memory data = _encode(receiveLib, _param.packetHeader, _param.payloadHash);
        Client.EVM2AnyMessage memory message = _createCCIPMessage(data, config.peer, config.gas);

        IRouterClient ccipRouter = router;
        uint256 ccipFee;
        (ccipFee, totalFee) = ICCIPDVNAdapterFeeLib(workerFeeLib).getFeeOnSend(
            feeLibParam,
            config,
            message,
            _options,
            ccipRouter
        );

        _assertBalanceAndWithdrawFee(msg.sender, ccipFee);

        ccipRouter.ccipSend{ value: ccipFee }(config.chainSelector, message);
    }

    // ========================= OnlyRouter =========================
    function ccipReceive(Client.Any2EVMMessage calldata _message) external {
        if (msg.sender != address(router)) revert CCIPDVNAdapter_InvalidRouter(msg.sender);

        _assertPeer(_message.sourceChainSelector, _message.sender);

        _decodeAndVerify(_message.data);
    }

    // ========================= View =========================
    function getFee(
        uint32 _dstEid,
        uint64 _confirmations,
        address _sender,
        bytes calldata _options
    ) external view override onlyAcl(_sender) returns (uint256 totalFee) {
        ICCIPDVNAdapterFeeLib.Param memory feeLibParam = ICCIPDVNAdapterFeeLib.Param(
            _dstEid,
            _confirmations,
            _sender,
            defaultMultiplierBps
        );

        DstConfig memory config = dstConfig[_dstEid];

        bytes memory data = _encodeEmpty();
        Client.EVM2AnyMessage memory message = _createCCIPMessage(data, config.peer, config.gas);

        totalFee = ICCIPDVNAdapterFeeLib(workerFeeLib).getFee(feeLibParam, config, message, _options, router);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || super.supportsInterface(interfaceId);
    }

    // ========================= Internal =========================
    function _createCCIPMessage(
        bytes memory _data,
        bytes memory _receiver,
        uint256 _gas
    ) private pure returns (Client.EVM2AnyMessage memory message) {
        message = Client.EVM2AnyMessage({
            receiver: _receiver,
            data: _data,
            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent
            extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({ gasLimit: _gas, strict: false })),
            feeToken: NATIVE_GAS_TOKEN_ADDRESS
        });
    }

    function _assertPeer(uint64 _sourceChainSelector, bytes memory _sourceAddress) private view {
        bytes memory sourcePeer = peers[_sourceChainSelector];
        if (keccak256(_sourceAddress) != keccak256(sourcePeer)) {
            revert CCIPDVNAdapter_UntrustedPeer(_sourceChainSelector, _sourceAddress);
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/adapters/CCIP/CCIPDVNAdapterFeeLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";
import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import { Client } from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import { IRouterClient } from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";

import { ICCIPDVNAdapter } from "../../../interfaces/adapters/ICCIPDVNAdapter.sol";
import { ICCIPDVNAdapterFeeLib } from "../../../interfaces/adapters/ICCIPDVNAdapterFeeLib.sol";

contract CCIPDVNAdapterFeeLib is OwnableUpgradeable, Proxied, ICCIPDVNAdapterFeeLib {
    uint16 internal constant BPS_DENOMINATOR = 10000;

    mapping(uint32 dstEid => DstConfig) public dstConfig;

    function initialize() external proxied initializer {
        __Ownable_init();
    }

    // ================================ OnlyOwner ===============================
    function setDstConfig(DstConfigParam[] calldata _param) external onlyOwner {
        for (uint256 i = 0; i < _param.length; i++) {
            DstConfigParam calldata param = _param[i];

            dstConfig[param.dstEid] = DstConfig({ floorMarginUSD: param.floorMarginUSD });
        }

        emit DstConfigSet(_param);
    }

    // ================================ External ================================
    function getFeeOnSend(
        Param calldata _params,
        ICCIPDVNAdapter.DstConfig calldata _dstConfig,
        Client.EVM2AnyMessage calldata _message,
        bytes calldata _options,
        IRouterClient _router
    ) external payable returns (uint256 ccipFee, uint256 totalFee) {
        if (_dstConfig.gas == 0) revert CCIPDVNAdapter_EidNotSupported(_params.dstEid);
        if (_options.length > 0) revert CCIPDVNAdapter_OptionsUnsupported();

        ccipFee = _router.getFee(_dstConfig.chainSelector, _message);
        totalFee = _applyPremium(_dstConfig.multiplierBps, _params.defaultMultiplierBps, ccipFee);
    }

    function getFee(
        Param calldata _params,
        ICCIPDVNAdapter.DstConfig calldata _dstConfig,
        Client.EVM2AnyMessage calldata _message,
        bytes calldata _options,
        IRouterClient _router
    ) external view returns (uint256 totalFee) {
        if (_dstConfig.gas == 0) revert CCIPDVNAdapter_EidNotSupported(_params.dstEid);
        if (_options.length > 0) revert CCIPDVNAdapter_OptionsUnsupported();

        totalFee = _router.getFee(_dstConfig.chainSelector, _message);
        totalFee = _applyPremium(_dstConfig.multiplierBps, _params.defaultMultiplierBps, totalFee);
    }

    // ================================ Internal ================================
    function _applyPremium(
        uint16 _multiplierBps,
        uint16 _defaultMultiplierBps,
        uint256 _fee
    ) internal pure returns (uint256 fee) {
        uint256 multiplier = _multiplierBps == 0 ? _defaultMultiplierBps : _multiplierBps;
        fee = (_fee * multiplier) / BPS_DENOMINATOR;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/adapters/DVNAdapterBase.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";
import { ISendLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";

import { ILayerZeroDVN } from "../../interfaces/ILayerZeroDVN.sol";
import { Worker } from "../../../Worker.sol";
import { DVNAdapterMessageCodec } from "./libs/DVNAdapterMessageCodec.sol";

interface ISendLibBase {
    function fees(address _worker) external view returns (uint256);
}

interface IReceiveUln {
    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;
}

struct ReceiveLibParam {
    address sendLib;
    uint32 dstEid;
    bytes32 receiveLib;
}

/// @title SendDVNAdapterBase
/// @notice base contract for DVN adapters
/// @dev limitations:
///  - doesn't accept alt token
///  - doesn't respect block confirmations
abstract contract DVNAdapterBase is Worker, ILayerZeroDVN {
    // --- Errors ---
    error DVNAdapter_InsufficientBalance(uint256 actual, uint256 requested);
    error DVNAdapter_NotImplemented();
    error DVNAdapter_MissingRecieveLib(address sendLib, uint32 dstEid);

    event ReceiveLibsSet(ReceiveLibParam[] params);

    /// @dev on change of application config, dvn adapters will not perform any additional verification
    /// @dev to avoid messages from being stuck, all verifications from adapters will be done with the maximum possible confirmations
    uint64 internal constant MAX_CONFIRMATIONS = type(uint64).max;

    /// @dev receive lib to call verify() on at destination
    mapping(address sendLib => mapping(uint32 dstEid => bytes32 receiveLib)) public receiveLibs;

    constructor(
        address _roleAdmin,
        address[] memory _admins,
        uint16 _defaultMultiplierBps
    ) Worker(new address[](0), address(0x0), _defaultMultiplierBps, _roleAdmin, _admins) {}

    // ========================= OnlyAdmin =========================
    /// @notice sets receive lib for destination chains
    /// @dev DEFAULT_ADMIN_ROLE can set MESSAGE_LIB_ROLE for sendLibs and use below function to set receiveLibs
    function setReceiveLibs(ReceiveLibParam[] calldata _params) external onlyRole(DEFAULT_ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; i++) {
            ReceiveLibParam calldata param = _params[i];
            receiveLibs[param.sendLib][param.dstEid] = param.receiveLib;
        }

        emit ReceiveLibsSet(_params);
    }

    // ========================= Internal =========================
    function _getAndAssertReceiveLib(address _sendLib, uint32 _dstEid) internal view returns (bytes32 lib) {
        lib = receiveLibs[_sendLib][_dstEid];
        if (lib == bytes32(0)) revert DVNAdapter_MissingRecieveLib(_sendLib, _dstEid);
    }

    function _encode(
        bytes32 _receiveLib,
        bytes memory _packetHeader,
        bytes32 _payloadHash
    ) internal pure returns (bytes memory) {
        return DVNAdapterMessageCodec.encode(_receiveLib, _packetHeader, _payloadHash);
    }

    function _encodeEmpty() internal pure returns (bytes memory) {
        return
            DVNAdapterMessageCodec.encode(bytes32(0), new bytes(DVNAdapterMessageCodec.PACKET_HEADER_SIZE), bytes32(0));
    }

    function _decodeAndVerify(bytes calldata _payload) internal {
        (address receiveLib, bytes memory packetHeader, bytes32 payloadHash) = DVNAdapterMessageCodec.decode(_payload);

        IReceiveUln(receiveLib).verify(packetHeader, payloadHash, MAX_CONFIRMATIONS);
    }

    function _withdrawFeeFromSendLib(address _sendLib, address _to) internal {
        uint256 fee = ISendLibBase(_sendLib).fees(address(this));
        if (fee > 0) {
            ISendLib(_sendLib).withdrawFee(_to, fee);
            emit Withdraw(_sendLib, _to, fee);
        }
    }

    function _assertBalanceAndWithdrawFee(address _sendLib, uint256 _messageFee) internal {
        uint256 balance = address(this).balance;
        if (balance < _messageFee) {
            // withdraw all fees from the sendLib if balance is insufficient
            _withdrawFeeFromSendLib(_sendLib, address(this));

            // check balance again
            balance = address(this).balance;
            // revert if balance is still insufficient, need to transfer more funds manually to the adapter
            if (balance < _messageFee) revert DVNAdapter_InsufficientBalance(balance, _messageFee);
        }
    }

    /// @dev to receive refund
    receive() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/adapters/axelar/AxelarDVNAdapter.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { AxelarExecutable } from "@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol";
import { ISendLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";

import { DVNAdapterBase } from "../DVNAdapterBase.sol";
import { IAxelarDVNAdapter } from "../../../interfaces/adapters/IAxelarDVNAdapter.sol";
import { IAxelarDVNAdapterFeeLib } from "../../../interfaces/adapters/IAxelarDVNAdapterFeeLib.sol";

interface ISendLibBase {
    function fees(address _worker) external view returns (uint256);
}

/// @title AxelarDVNAdapter
/// @dev How Axelar DVN Adapter works:
///  1. Estimate gas fee off-chain using the Axelar SDK.
///     refer to https://docs.axelar.dev/dev/axelarjs-sdk/axelar-query-api#estimategasfee
///  2. Pay gas fee by calling `payNativeGasForContractCall` on the AxelarGasService contract.
///     refer to https://docs.axelar.dev/dev/general-message-passing/gas-services/pay-gas#paynativegasforcontractcall
///  3. Send message by calling `callContract` on the AxelarGateway contract.
///     refer to https://docs.axelar.dev/dev/general-message-passing/gmp-messages#call-a-contract-on-chain-b-from-chain-a
///  4. Refund surplus gas fee asynchronously.
///     refer to https://docs.axelar.dev/dev/general-message-passing/gas-services/refund
/// @dev Recovery:
///  1. If not enough gas fee is paid, the message will be hangup on source chain and can `add gas` to retry.
///     refer to https://docs.axelar.dev/dev/general-message-passing/recovery#increase-gas-payment-to-the-gas-receiver-on-the-source-chain
///  2. If the message is not executed on the destination chain, you can manually retry by calling `execute` on the `ReceiveAxelarDVNAdapter` contract.
///     refer to https://docs.axelar.dev/dev/general-message-passing/recovery#manually-execute-a-transfer
/// @dev As the Gas is estimated off-chain, we need to update the gas fee periodically on-chain by calling `setNativeGasFee` with the new fee.
contract AxelarDVNAdapter is DVNAdapterBase, AxelarExecutable, IAxelarDVNAdapter {
    mapping(string axelarChain => string peer) public peers; // by chain name
    mapping(uint32 dstEid => DstConfig) public dstConfig; // by dstEid

    // set default multiplier to 2.5x
    constructor(
        address[] memory _admins,
        address _gateway
    ) AxelarExecutable(_gateway) DVNAdapterBase(msg.sender, _admins, 12000) {}

    // ========================= OnlyAdmin =========================
    function setDstConfig(DstConfigParam[] calldata _params) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; i++) {
            DstConfigParam calldata param = _params[i];

            delete peers[dstConfig[param.dstEid].chainName]; // delete old peer in case chain name by dstEid is updated
            peers[param.chainName] = param.peer; // update peer

            dstConfig[param.dstEid] = DstConfig(param.chainName, param.peer, param.multiplierBps, param.nativeGasFee); // update config by dstEid
        }

        emit DstConfigSet(_params);
    }

    /// @notice sets message fee in native gas for destination chains.
    /// @dev Axelar does not support quoting fee on-chain. Instead, the fee needs to be obtained off-chain by querying through the Axelar SDK.
    /// @dev The fee may change over time when token prices change, requiring admins to monitor and make necessary updates to reflect the actual fee.
    /// @dev Adding a buffer to the required fee is advisable. Any surplus fee will be refunded asynchronously if it exceeds the necessary amount.
    /// https://docs.axelar.dev/dev/general-message-passing/gas-services/pay-gas
    /// https://github.com/axelarnetwork/axelarjs/blob/070c8fe061f1082e79772fdc5c4675c0237bbba2/packages/api/src/axelar-query/isomorphic.ts#L54
    /// https://github.com/axelarnetwork/axelar-cgp-solidity/blob/d4536599321774927bf9716178a9e360f8e0efac/contracts/gas-service/AxelarGasService.sol#L403
    function setNativeGasFee(NativeGasFeeParam[] calldata _params) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < _params.length; i++) {
            NativeGasFeeParam calldata param = _params[i];
            dstConfig[param.dstEid].nativeGasFee = param.nativeGasFee;
        }
        emit NativeGasFeeSet(_params);
    }

    // ========================= OnlyWorkerFeeLib =========================
    function withdrawToFeeLib(address _sendLib) external {
        if (msg.sender != workerFeeLib) revert AxelarDVNAdapter_OnlyWorkerFeeLib();

        _withdrawFeeFromSendLib(_sendLib, workerFeeLib);
    }

    // ========================= OnlyMessageLib =========================
    function assignJob(
        AssignJobParam calldata _param,
        bytes calldata _options
    ) external payable override onlyAcl(_param.sender) returns (uint totalFee) {
        bytes32 receiveLib = _getAndAssertReceiveLib(msg.sender, _param.dstEid);

        IAxelarDVNAdapterFeeLib.Param memory feeLibParam = IAxelarDVNAdapterFeeLib.Param({
            dstEid: _param.dstEid,
            confirmations: _param.confirmations,
            sender: _param.sender,
            defaultMultiplierBps: defaultMultiplierBps
        });
        DstConfig memory config = dstConfig[_param.dstEid];

        bytes memory payload = _encode(receiveLib, _param.packetHeader, _param.payloadHash);

        totalFee = IAxelarDVNAdapterFeeLib(workerFeeLib).getFeeOnSend(
            feeLibParam,
            config,
            payload,
            _options,
            msg.sender
        );

        gateway.callContract(config.chainName, config.peer, payload);
    }

    // ========================= View =========================
    function getFee(
        uint32 _dstEid,
        uint64 _confirmations,
        address _sender,
        bytes calldata _options
    ) external view override returns (uint256 totalFee) {
        IAxelarDVNAdapterFeeLib.Param memory feeLibParam = IAxelarDVNAdapterFeeLib.Param(
            _dstEid,
            _confirmations,
            _sender,
            defaultMultiplierBps
        );

        totalFee = IAxelarDVNAdapterFeeLib(workerFeeLib).getFee(feeLibParam, dstConfig[_dstEid], _options);
    }

    // ========================= Internal =========================
    function _execute(
        string calldata _sourceChain,
        string calldata _sourceAddress,
        bytes calldata _payload
    ) internal override {
        // assert peer is the same as the source chain
        _assertPeer(_sourceChain, _sourceAddress);

        _decodeAndVerify(_payload);
    }

    function _assertPeer(string memory _sourceChain, string memory _sourceAddress) private view {
        string memory sourcePeer = peers[_sourceChain];
        if (keccak256(bytes(_sourceAddress)) != keccak256(bytes(sourcePeer))) {
            revert AxelarDVNAdapter_UntrustedPeer(_sourceChain, _sourceAddress);
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/adapters/axelar/AxelarDVNAdapterFeeLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";
import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import { IAxelarGasService } from "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { IAxelarDVNAdapter } from "../../../interfaces/adapters/IAxelarDVNAdapter.sol";
import { IAxelarDVNAdapterFeeLib } from "../../../interfaces/adapters/IAxelarDVNAdapterFeeLib.sol";
import { ILayerZeroPriceFeed } from "../../../../interfaces/ILayerZeroPriceFeed.sol";

contract AxelarDVNAdapterFeeLib is OwnableUpgradeable, Proxied, IAxelarDVNAdapterFeeLib {
    uint16 internal constant BPS_DENOMINATOR = 10000;

    /// @dev to be applied to native gas fee before sending to Axelar Gas Service
    uint16 public nativeGasFeeMultiplierBps;

    IAxelarDVNAdapter public dvn;
    IAxelarGasService public gasService;
    ILayerZeroPriceFeed public priceFeed;

    mapping(uint32 dstEid => DstConfig) public dstConfig;

    function initialize(
        address _gasService,
        address _dvn,
        uint16 _nativeGasFeeMultiplierBps
    ) external proxied initializer {
        __Ownable_init();
        gasService = IAxelarGasService(_gasService);
        dvn = IAxelarDVNAdapter(_dvn);
        nativeGasFeeMultiplierBps = _nativeGasFeeMultiplierBps;
    }

    // ================================ OnlyOwner ================================
    function withdrawToken(address _token, address _to, uint256 _amount) external onlyOwner {
        // transfers native if _token is address(0x0)
        Transfer.nativeOrToken(_token, _to, _amount);
        emit TokenWithdrawn(_token, _to, _amount);
    }

    function setGasService(address _gasService) external onlyOwner {
        gasService = IAxelarGasService(_gasService);
        emit GasServiceSet(_gasService);
    }

    function setPriceFeed(address _priceFeed) external onlyOwner {
        priceFeed = ILayerZeroPriceFeed(_priceFeed);
        emit PriceFeedSet(_priceFeed);
    }

    function setDstConfig(DstConfigParam[] calldata _param) external onlyOwner {
        for (uint256 i = 0; i < _param.length; i++) {
            DstConfigParam calldata param = _param[i];
            dstConfig[param.dstEid] = DstConfig({ gas: param.gas, floorMarginUSD: param.floorMarginUSD });
        }
        emit DstConfigSet(_param);
    }

    function setNativeGasFeeMultiplierBps(uint16 _multiplierBps) external onlyOwner {
        nativeGasFeeMultiplierBps = _multiplierBps;
        emit NativeGasFeeMultiplierBpsSet(_multiplierBps);
    }

    // ================================ External ================================
    function getFeeOnSend(
        Param calldata _param,
        IAxelarDVNAdapter.DstConfig calldata _dstConfig,
        bytes memory _payload,
        bytes calldata _options,
        address _sendLib
    ) external payable returns (uint256 totalFee) {
        if (_dstConfig.nativeGasFee == 0) revert AxelarDVNAdapter_EidNotSupported(_param.dstEid);
        if (_options.length > 0) revert AxelarDVNAdapter_OptionsUnsupported();

        uint256 axelarFee = _getAxelarFee(_dstConfig.nativeGasFee);
        totalFee = _applyPremium(_dstConfig.multiplierBps, _param.defaultMultiplierBps, axelarFee);

        // withdraw from uln to fee lib if not enough balance
        uint256 balance = address(this).balance;
        if (balance < axelarFee) {
            dvn.withdrawToFeeLib(_sendLib);

            // revert if still not enough
            balance = address(this).balance;
            if (balance < axelarFee) revert AxelarDVNAdapter_InsufficientBalance(balance, axelarFee);
        }

        // pay axelar gas service
        gasService.payNativeGasForContractCall{ value: axelarFee }(
            address(this), // sender
            _dstConfig.chainName, // destinationChain
            _dstConfig.peer, // destinationAddress
            _payload, // payload
            address(this) // refundAddress
        );
    }

    function getFee(
        Param calldata _param,
        IAxelarDVNAdapter.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external view returns (uint256 totalFee) {
        if (_dstConfig.nativeGasFee == 0) revert AxelarDVNAdapter_EidNotSupported(_param.dstEid);
        if (_options.length > 0) revert AxelarDVNAdapter_OptionsUnsupported();

        uint256 axelarFee = _getAxelarFee(_dstConfig.nativeGasFee);
        totalFee = _applyPremium(_dstConfig.multiplierBps, _param.defaultMultiplierBps, axelarFee);
    }

    // ================================ Internal ================================
    function _getAxelarFee(uint256 _nativeGasFee) internal view returns (uint256) {
        return (_nativeGasFee * nativeGasFeeMultiplierBps) / BPS_DENOMINATOR;
    }

    function _applyPremium(
        uint16 multiplierBps,
        uint16 defaultMultiplierBps,
        uint256 fee
    ) internal pure returns (uint256) {
        uint256 multiplier = multiplierBps == 0 ? defaultMultiplierBps : multiplierBps;
        return (fee * multiplier) / BPS_DENOMINATOR;
    }

    receive() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/dvn/adapters/libs/DVNAdapterMessageCodec.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { AddressCast } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol";

library DVNAdapterMessageCodec {
    using AddressCast for bytes32;

    error DVNAdapter_InvalidMessageSize();

    uint256 private constant RECEIVE_LIB_OFFSET = 0;
    uint256 private constant PAYLOAD_HASH_OFFSET = 32;
    uint256 private constant PACKET_HEADER_OFFSET = 64;

    uint256 internal constant PACKET_HEADER_SIZE = 81; // version(uint8) + nonce(uint64) + path(uint32,bytes32,uint32,bytes32)
    uint256 internal constant MESSAGE_SIZE = 32 + 32 + PACKET_HEADER_SIZE; // receive_lib(bytes32) + payloadHash(bytes32) + packetHeader

    function encode(
        bytes32 _receiveLib,
        bytes memory _packetHeader,
        bytes32 _payloadHash
    ) internal pure returns (bytes memory payload) {
        return abi.encodePacked(_receiveLib, _payloadHash, _packetHeader);
    }

    function decode(
        bytes calldata _message
    ) internal pure returns (address receiveLib, bytes memory packetHeader, bytes32 payloadHash) {
        if (_message.length != MESSAGE_SIZE) revert DVNAdapter_InvalidMessageSize();

        receiveLib = bytes32(_message[RECEIVE_LIB_OFFSET:PAYLOAD_HASH_OFFSET]).toAddress();
        payloadHash = bytes32(_message[PAYLOAD_HASH_OFFSET:PACKET_HEADER_OFFSET]);
        packetHeader = _message[PACKET_HEADER_OFFSET:];
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/IDVN.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { IWorker } from "../../interfaces/IWorker.sol";
import { ILayerZeroDVN } from "./ILayerZeroDVN.sol";

interface IDVN is IWorker, ILayerZeroDVN {
    struct DstConfigParam {
        uint32 dstEid;
        uint64 gas;
        uint16 multiplierBps;
        uint128 floorMarginUSD;
    }

    struct DstConfig {
        uint64 gas;
        uint16 multiplierBps;
        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR
    }

    event SetDstConfig(DstConfigParam[] params);

    function dstConfig(uint32 _dstEid) external view returns (uint64, uint16, uint128);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/IDVNFeeLib.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { IDVN } from "./IDVN.sol";

interface IDVNFeeLib {
    struct FeeParams {
        address priceFeed;
        uint32 dstEid;
        uint64 confirmations;
        address sender;
        uint64 quorum;
        uint16 defaultMultiplierBps;
    }

    error DVN_UnsupportedOptionType(uint8 optionType);
    error DVN_EidNotSupported(uint32 eid);

    function getFeeOnSend(
        FeeParams calldata _params,
        IDVN.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external payable returns (uint256 fee);

    function getFee(
        FeeParams calldata _params,
        IDVN.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external view returns (uint256 fee);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/ILayerZeroDVN.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface ILayerZeroDVN {
    struct AssignJobParam {
        uint32 dstEid;
        bytes packetHeader;
        bytes32 payloadHash;
        uint64 confirmations;
        address sender;
    }

    // @notice query price and assign jobs at the same time
    // @param _dstEid - the destination endpoint identifier
    // @param _packetHeader - version + nonce + path
    // @param _payloadHash - hash of guid + message
    // @param _confirmations - block confirmation delay before relaying blocks
    // @param _sender - the source sending contract address
    // @param _options - options
    function assignJob(AssignJobParam calldata _param, bytes calldata _options) external payable returns (uint256 fee);

    // @notice query the dvn fee for relaying block information to the destination chain
    // @param _dstEid the destination endpoint identifier
    // @param _confirmations - block confirmation delay before relaying blocks
    // @param _sender - the source sending contract address
    // @param _options - options
    function getFee(
        uint32 _dstEid,
        uint64 _confirmations,
        address _sender,
        bytes calldata _options
    ) external view returns (uint256 fee);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/IReceiveUlnE2.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

/// @dev should be implemented by the ReceiveUln302 contract and future ReceiveUln contracts on EndpointV2
interface IReceiveUlnE2 {
    /// @notice for each dvn to verify the payload
    /// @dev this function signature 0x0223536e
    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external;

    /// @notice verify the payload at endpoint, will check if all DVNs verified
    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external;
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/adapters/IAxelarDVNAdapter.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface IAxelarDVNAdapter {
    struct MultiplierParam {
        uint32 dstEid;
        uint16 multiplierBps;
    }

    struct FloorMarginUSDParam {
        uint32 dstEid;
        uint128 floorMarginUSD;
    }

    struct NativeGasFeeParam {
        uint32 dstEid;
        uint256 nativeGasFee;
    }

    struct DstConfigParam {
        uint32 dstEid;
        string chainName;
        string peer;
        uint16 multiplierBps;
        uint256 nativeGasFee;
    }

    struct DstConfig {
        string chainName;
        string peer;
        uint16 multiplierBps;
        uint256 nativeGasFee;
    }

    event DstConfigSet(DstConfigParam[] params);
    event NativeGasFeeSet(NativeGasFeeParam[] params);
    event MultiplierSet(MultiplierParam[] params);
    event FloorMarginUSDSet(FloorMarginUSDParam[] params);

    error AxelarDVNAdapter_UntrustedPeer(string chainName, string peer);
    error AxelarDVNAdapter_OnlyWorkerFeeLib();

    function withdrawToFeeLib(address _sendLib) external;
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/adapters/IAxelarDVNAdapterFeeLib.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { IAxelarDVNAdapter } from "./IAxelarDVNAdapter.sol";

interface IAxelarDVNAdapterFeeLib {
    struct Param {
        uint32 dstEid;
        uint64 confirmations;
        address sender;
        uint16 defaultMultiplierBps;
    }

    struct DstConfig {
        uint64 gas;
        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR
    }

    struct DstConfigParam {
        uint32 dstEid;
        uint64 gas;
        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR
    }

    event DstConfigSet(DstConfigParam[] params);
    event TokenWithdrawn(address token, address to, uint256 amount);
    event GasServiceSet(address gasService);
    event PriceFeedSet(address priceFeed);
    event NativeGasFeeMultiplierBpsSet(uint16 multiplierBps);

    error AxelarDVNAdapter_OptionsUnsupported();
    error AxelarDVNAdapter_InsufficientBalance(uint256 actual, uint256 requested);
    error AxelarDVNAdapter_EidNotSupported(uint32 eid);

    function getFeeOnSend(
        Param calldata _params,
        IAxelarDVNAdapter.DstConfig calldata _dstConfig,
        bytes memory _payload,
        bytes calldata _options,
        address _sendLib
    ) external payable returns (uint256 totalFee);

    function getFee(
        Param calldata _params,
        IAxelarDVNAdapter.DstConfig calldata _dstConfig,
        bytes calldata _options
    ) external view returns (uint256 totalFee);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/adapters/ICCIPDVNAdapter.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface ICCIPDVNAdapter {
    struct DstConfigParam {
        uint32 dstEid;
        uint16 multiplierBps;
        uint64 chainSelector;
        uint256 gas;
        bytes peer;
    }

    struct DstConfig {
        // https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet#ethereum-sepolia
        // https://docs.chain.link/ccip/supported-networks/v1_0_0/mainnet
        uint64 chainSelector;
        uint16 multiplierBps;
        // https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/libraries/Client.sol#L22C51-L22C51
        // for destination is evm chain, need to use `abi.encode(address)` to get the peer
        bytes peer;
        uint256 gas;
    }

    event DstConfigSet(DstConfigParam[] params);
    event RouterSet(address router);

    error CCIPDVNAdapter_UntrustedPeer(uint64 chainSelector, bytes peer);
    error CCIPDVNAdapter_InvalidRouter(address router);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/interfaces/adapters/ICCIPDVNAdapterFeeLib.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { Client } from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import { IRouterClient } from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";
import { ICCIPDVNAdapter } from "./ICCIPDVNAdapter.sol";

interface ICCIPDVNAdapterFeeLib {
    struct Param {
        uint32 dstEid;
        uint64 confirmations;
        address sender;
        uint16 defaultMultiplierBps;
    }

    struct DstConfig {
        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR
    }

    struct DstConfigParam {
        uint32 dstEid;
        uint128 floorMarginUSD; // uses priceFeed PRICE_RATIO_DENOMINATOR
    }

    event DstConfigSet(DstConfigParam[] params);

    error CCIPDVNAdapter_OptionsUnsupported();
    error CCIPDVNAdapter_EidNotSupported(uint32 eid);

    function getFeeOnSend(
        Param calldata _params,
        ICCIPDVNAdapter.DstConfig calldata _dstConfig,
        Client.EVM2AnyMessage calldata _message,
        bytes calldata _options,
        IRouterClient _router
    ) external payable returns (uint256 ccipFee, uint256 totalFee);

    function getFee(
        Param calldata _params,
        ICCIPDVNAdapter.DstConfig calldata _dstConfig,
        Client.EVM2AnyMessage calldata _message,
        bytes calldata _options,
        IRouterClient _router
    ) external view returns (uint256 totalFee);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/libs/DVNOptions.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { BitMap256 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/BitMaps.sol";
import { CalldataBytesLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/CalldataBytesLib.sol";

library DVNOptions {
    using CalldataBytesLib for bytes;
    using BytesLib for bytes;

    uint8 internal constant WORKER_ID = 2;
    uint8 internal constant OPTION_TYPE_PRECRIME = 1;

    error DVN_InvalidDVNIdx();
    error DVN_InvalidDVNOptions(uint256 cursor);

    /// @dev group dvn options by its idx
    /// @param _options [dvn_id][dvn_option][dvn_id][dvn_option]...
    ///        dvn_option = [option_size][dvn_idx][option_type][option]
    ///        option_size = len(dvn_idx) + len(option_type) + len(option)
    ///        dvn_id: uint8, dvn_idx: uint8, option_size: uint16, option_type: uint8, option: bytes
    /// @return dvnOptions the grouped options, still share the same format of _options
    /// @return dvnIndices the dvn indices
    function groupDVNOptionsByIdx(
        bytes memory _options
    ) internal pure returns (bytes[] memory dvnOptions, uint8[] memory dvnIndices) {
        if (_options.length == 0) return (dvnOptions, dvnIndices);

        uint8 numDVNs = getNumDVNs(_options);

        // if there is only 1 dvn, we can just return the whole options
        if (numDVNs == 1) {
            dvnOptions = new bytes[](1);
            dvnOptions[0] = _options;

            dvnIndices = new uint8[](1);
            dvnIndices[0] = _options.toUint8(3); // dvn idx
            return (dvnOptions, dvnIndices);
        }

        // otherwise, we need to group the options by dvn_idx
        dvnIndices = new uint8[](numDVNs);
        dvnOptions = new bytes[](numDVNs);
        unchecked {
            uint256 cursor = 0;
            uint256 start = 0;
            uint8 lastDVNIdx = 255; // 255 is an invalid dvn_idx

            while (cursor < _options.length) {
                ++cursor; // skip worker_id

                // optionLength asserted in getNumDVNs (skip check)
                uint16 optionLength = _options.toUint16(cursor);
                cursor += 2;

                // dvnIdx asserted in getNumDVNs (skip check)
                uint8 dvnIdx = _options.toUint8(cursor);

                // dvnIdx must equal to the lastDVNIdx for the first option
                // so it is always skipped in the first option
                // this operation slices out options whenever the scan finds a different lastDVNIdx
                if (lastDVNIdx == 255) {
                    lastDVNIdx = dvnIdx;
                } else if (dvnIdx != lastDVNIdx) {
                    uint256 len = cursor - start - 3; // 3 is for worker_id and option_length
                    bytes memory opt = _options.slice(start, len);
                    _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, opt);

                    // reset the start and lastDVNIdx
                    start += len;
                    lastDVNIdx = dvnIdx;
                }

                cursor += optionLength;
            }

            // skip check the cursor here because the cursor is asserted in getNumDVNs
            // if we have reached the end of the options, we need to process the last dvn
            uint256 size = cursor - start;
            bytes memory op = _options.slice(start, size);
            _insertDVNOptions(dvnOptions, dvnIndices, lastDVNIdx, op);

            // revert dvnIndices to start from 0
            for (uint8 i = 0; i < numDVNs; ++i) {
                --dvnIndices[i];
            }
        }
    }

    function _insertDVNOptions(
        bytes[] memory _dvnOptions,
        uint8[] memory _dvnIndices,
        uint8 _dvnIdx,
        bytes memory _newOptions
    ) internal pure {
        // dvnIdx starts from 0 but default value of dvnIndices is 0,
        // so we tell if the slot is empty by adding 1 to dvnIdx
        if (_dvnIdx == 255) revert DVN_InvalidDVNIdx();
        uint8 dvnIdxAdj = _dvnIdx + 1;

        for (uint256 j = 0; j < _dvnIndices.length; ++j) {
            uint8 index = _dvnIndices[j];
            if (dvnIdxAdj == index) {
                _dvnOptions[j] = abi.encodePacked(_dvnOptions[j], _newOptions);
                break;
            } else if (index == 0) {
                // empty slot, that means it is the first time we see this dvn
                _dvnIndices[j] = dvnIdxAdj;
                _dvnOptions[j] = _newOptions;
                break;
            }
        }
    }

    /// @dev get the number of unique dvns
    /// @param _options the format is the same as groupDVNOptionsByIdx
    function getNumDVNs(bytes memory _options) internal pure returns (uint8 numDVNs) {
        uint256 cursor = 0;
        BitMap256 bitmap;

        // find number of unique dvn_idx
        unchecked {
            while (cursor < _options.length) {
                ++cursor; // skip worker_id

                uint16 optionLength = _options.toUint16(cursor);
                cursor += 2;
                if (optionLength < 2) revert DVN_InvalidDVNOptions(cursor); // at least 1 byte for dvn_idx and 1 byte for option_type

                uint8 dvnIdx = _options.toUint8(cursor);

                // if dvnIdx is not set, increment numDVNs
                // max num of dvns is 255, 255 is an invalid dvn_idx
                // The order of the dvnIdx is not required to be sequential, as enforcing the order may weaken
                // the composability of the options. e.g. if we refrain from enforcing the order, an OApp that has
                // already enforced certain options can append additional options to the end of the enforced
                // ones without restrictions.
                if (dvnIdx == 255) revert DVN_InvalidDVNIdx();
                if (!bitmap.get(dvnIdx)) {
                    ++numDVNs;
                    bitmap = bitmap.set(dvnIdx);
                }

                cursor += optionLength;
            }
        }
        if (cursor != _options.length) revert DVN_InvalidDVNOptions(cursor);
    }

    /// @dev decode the next dvn option from _options starting from the specified cursor
    /// @param _options the format is the same as groupDVNOptionsByIdx
    /// @param _cursor the cursor to start decoding
    /// @return optionType the type of the option
    /// @return option the option
    /// @return cursor the cursor to start decoding the next option
    function nextDVNOption(
        bytes calldata _options,
        uint256 _cursor
    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {
        unchecked {
            // skip worker id
            cursor = _cursor + 1;

            // read option size
            uint16 size = _options.toU16(cursor);
            cursor += 2;

            // read option type
            optionType = _options.toU8(cursor + 1); // skip dvn_idx

            // startCursor and endCursor are used to slice the option from _options
            uint256 startCursor = cursor + 2; // skip option type and dvn_idx
            uint256 endCursor = cursor + size;
            option = _options[startCursor:endCursor];
            cursor += size;
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/libs/UlnOptions.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";

import { ExecutorOptions } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol";

import { DVNOptions } from "./DVNOptions.sol";

library UlnOptions {
    using SafeCast for uint256;

    uint16 internal constant TYPE_1 = 1; // legacy options type 1
    uint16 internal constant TYPE_2 = 2; // legacy options type 2
    uint16 internal constant TYPE_3 = 3;

    error LZ_ULN_InvalidWorkerOptions(uint256 cursor);
    error LZ_ULN_InvalidWorkerId(uint8 workerId);
    error LZ_ULN_InvalidLegacyType1Option();
    error LZ_ULN_InvalidLegacyType2Option();
    error LZ_ULN_UnsupportedOptionType(uint16 optionType);

    /// @dev decode the options into executorOptions and dvnOptions
    /// @param _options the options can be either legacy options (type 1 or 2) or type 3 options
    /// @return executorOptions the executor options, share the same format of type 3 options
    /// @return dvnOptions the dvn options, share the same format of type 3 options
    function decode(
        bytes calldata _options
    ) internal pure returns (bytes memory executorOptions, bytes memory dvnOptions) {
        // at least 2 bytes for the option type, but can have no options
        if (_options.length < 2) revert LZ_ULN_InvalidWorkerOptions(0);

        uint16 optionsType = uint16(bytes2(_options[0:2]));
        uint256 cursor = 2;

        // type3 options: [worker_option][worker_option]...
        // worker_option: [worker_id][option_size][option]
        // worker_id: uint8, option_size: uint16, option: bytes
        if (optionsType == TYPE_3) {
            unchecked {
                uint256 start = cursor;
                uint8 lastWorkerId; // worker_id starts from 1, so 0 is an invalid worker_id

                // heuristic: we assume that the options are mostly EXECUTOR options only
                // checking the workerID can reduce gas usage for most cases
                while (cursor < _options.length) {
                    uint8 workerId = uint8(bytes1(_options[cursor:cursor + 1]));
                    if (workerId == 0) revert LZ_ULN_InvalidWorkerId(0);

                    // workerId must equal to the lastWorkerId for the first option
                    // so it is always skipped in the first option
                    // this operation slices out options whenever the the scan finds a different workerId
                    if (lastWorkerId == 0) {
                        lastWorkerId = workerId;
                    } else if (workerId != lastWorkerId) {
                        bytes calldata op = _options[start:cursor]; // slice out the last worker's options
                        (executorOptions, dvnOptions) = _insertWorkerOptions(
                            executorOptions,
                            dvnOptions,
                            lastWorkerId,
                            op
                        );

                        // reset the start cursor and lastWorkerId
                        start = cursor;
                        lastWorkerId = workerId;
                    }

                    ++cursor; // for workerId

                    uint16 size = uint16(bytes2(_options[cursor:cursor + 2]));
                    if (size == 0) revert LZ_ULN_InvalidWorkerOptions(cursor);
                    cursor += size + 2;
                }

                // the options length must be the same as the cursor at the end
                if (cursor != _options.length) revert LZ_ULN_InvalidWorkerOptions(cursor);

                // if we have reached the end of the options and the options are not empty
                // we need to process the last worker's options
                if (_options.length > 2) {
                    bytes calldata op = _options[start:cursor];
                    (executorOptions, dvnOptions) = _insertWorkerOptions(executorOptions, dvnOptions, lastWorkerId, op);
                }
            }
        } else {
            executorOptions = decodeLegacyOptions(optionsType, _options);
        }
    }

    function _insertWorkerOptions(
        bytes memory _executorOptions,
        bytes memory _dvnOptions,
        uint8 _workerId,
        bytes calldata _newOptions
    ) private pure returns (bytes memory, bytes memory) {
        if (_workerId == ExecutorOptions.WORKER_ID) {
            _executorOptions = _executorOptions.length == 0
                ? _newOptions
                : abi.encodePacked(_executorOptions, _newOptions);
        } else if (_workerId == DVNOptions.WORKER_ID) {
            _dvnOptions = _dvnOptions.length == 0 ? _newOptions : abi.encodePacked(_dvnOptions, _newOptions);
        } else {
            revert LZ_ULN_InvalidWorkerId(_workerId);
        }
        return (_executorOptions, _dvnOptions);
    }

    /// @dev decode the legacy options (type 1 or 2) into executorOptions
    /// @param _optionType the legacy option type
    /// @param _options the legacy options, which still has the option type in the first 2 bytes
    /// @return executorOptions the executor options, share the same format of type 3 options
    /// Data format:
    /// legacy type 1: [extraGas]
    /// legacy type 2: [extraGas][dstNativeAmt][dstNativeAddress]
    /// extraGas: uint256, dstNativeAmt: uint256, dstNativeAddress: bytes
    function decodeLegacyOptions(
        uint16 _optionType,
        bytes calldata _options
    ) internal pure returns (bytes memory executorOptions) {
        if (_optionType == TYPE_1) {
            if (_options.length != 34) revert LZ_ULN_InvalidLegacyType1Option();

            // execution gas
            uint128 executionGas = uint256(bytes32(_options[2:2 + 32])).toUint128();

            // dont use the encode function in the ExecutorOptions lib for saving gas by calling abi.encodePacked once
            // the result is a lzReceive option: [executor_id][option_size][option_type][execution_gas]
            // option_type: uint8, execution_gas: uint128
            // option_size = len(option_type) + len(execution_gas) = 1 + 16 = 17
            executorOptions = abi.encodePacked(
                ExecutorOptions.WORKER_ID,
                uint16(17), // 16 + 1, 16 for option_length, + 1 for option_type
                ExecutorOptions.OPTION_TYPE_LZRECEIVE,
                executionGas
            );
        } else if (_optionType == TYPE_2) {
            // receiver size <= 32
            if (_options.length <= 66 || _options.length > 98) revert LZ_ULN_InvalidLegacyType2Option();

            // execution gas
            uint128 executionGas = uint256(bytes32(_options[2:2 + 32])).toUint128();

            // nativeDrop (amount + receiver)
            uint128 amount = uint256(bytes32(_options[34:34 + 32])).toUint128(); // offset 2 + 32
            bytes32 receiver;
            unchecked {
                uint256 receiverLen = _options.length - 66; // offset 2 + 32 + 32
                receiver = bytes32(_options[66:]);
                receiver = receiver >> (8 * (32 - receiverLen)); // padding 0 to the left
            }

            // dont use the encode function in the ExecutorOptions lib for saving gas by calling abi.encodePacked once
            // the result has one lzReceive option and one nativeDrop option:
            //      [executor_id][lzReceive_option_size][option_type][execution_gas] +
            //      [executor_id][nativeDrop_option_size][option_type][nativeDrop_amount][receiver]
            // option_type: uint8, execution_gas: uint128, nativeDrop_amount: uint128, receiver: bytes32
            // lzReceive_option_size = len(option_type) + len(execution_gas) = 1 + 16 = 17
            // nativeDrop_option_size = len(option_type) + len(nativeDrop_amount) + len(receiver) = 1 + 16 + 32 = 49
            executorOptions = abi.encodePacked(
                ExecutorOptions.WORKER_ID,
                uint16(17), // 16 + 1, 16 for option_length, + 1 for option_type
                ExecutorOptions.OPTION_TYPE_LZRECEIVE,
                executionGas,
                ExecutorOptions.WORKER_ID,
                uint16(49), // 48 + 1, 32 + 16 for option_length, + 1 for option_type
                ExecutorOptions.OPTION_TYPE_NATIVE_DROP,
                amount,
                receiver
            );
        } else {
            revert LZ_ULN_UnsupportedOptionType(_optionType);
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/AddressSizeConfig.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

abstract contract AddressSizeConfig is Ownable {
    // EndpointV1 is using bytes as address. this map is for address length assertion
    mapping(uint32 dstEid => uint256 size) public addressSizes;

    event AddressSizeSet(uint16 eid, uint256 size);

    error AddressSizeConfig_InvalidAddressSize();
    error AddressSizeConfig_AddressSizeAlreadySet();

    function setAddressSize(uint16 _eid, uint256 _size) external onlyOwner {
        if (_size > 32) revert AddressSizeConfig_InvalidAddressSize();
        if (addressSizes[_eid] != 0) revert AddressSizeConfig_AddressSizeAlreadySet();
        addressSizes[_eid] = _size;
        emit AddressSizeSet(_eid, _size);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/ReceiveLibBaseE1.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";
import { AddressCast } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol";

import { AddressSizeConfig } from "./AddressSizeConfig.sol";
import { MessageLibBase } from "../../MessageLibBase.sol";

// only receiver function from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol"
// because we are separating the send and receive libraries
interface ILayerZeroReceiveLibrary {
    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion
    function setConfig(uint16 _chainId, address _userApplication, uint256 _configType, bytes calldata _config) external;

    function getConfig(
        uint16 _chainId,
        address _userApplication,
        uint256 _configType
    ) external view returns (bytes memory);
}

struct SetDefaultExecutorParam {
    uint32 eid;
    address executor;
}

/// @dev receive-side message library base contract on endpoint v1.
/// design:
/// 1/ it provides an internal execute function that calls the endpoint. It enforces the path definition on V1.
/// 2/ it provides interfaces to configure executors that is whitelisted to execute the msg to prevent grieving
abstract contract ReceiveLibBaseE1 is MessageLibBase, AddressSizeConfig, ILayerZeroReceiveLibrary {
    using AddressCast for bytes32;

    mapping(address oapp => mapping(uint32 eid => address executor)) public executors;
    mapping(uint32 eid => address executor) public defaultExecutors;

    // this event is the same as the PacketDelivered event on EndpointV2
    event PacketDelivered(Origin origin, address receiver);
    event InvalidDst(
        uint16 indexed srcChainId,
        bytes32 srcAddress,
        address indexed dstAddress,
        uint64 nonce,
        bytes32 payloadHash
    );
    event DefaultExecutorsSet(SetDefaultExecutorParam[] params);
    event ExecutorSet(address oapp, uint32 eid, address executor);

    error LZ_MessageLib_InvalidExecutor();
    error LZ_MessageLib_OnlyExecutor();

    constructor(address _endpoint, uint32 _localEid) MessageLibBase(_endpoint, _localEid) {}

    function setDefaultExecutors(SetDefaultExecutorParam[] calldata _params) external onlyOwner {
        for (uint256 i = 0; i < _params.length; ++i) {
            SetDefaultExecutorParam calldata param = _params[i];
            if (param.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();
            defaultExecutors[param.eid] = param.executor;
        }
        emit DefaultExecutorsSet(_params);
    }

    function getExecutor(address _oapp, uint32 _remoteEid) public view returns (address) {
        address executor = executors[_oapp][_remoteEid];
        return executor != address(0x0) ? executor : defaultExecutors[_remoteEid];
    }

    function _setExecutor(uint32 _remoteEid, address _oapp, address _executor) internal {
        executors[_oapp][_remoteEid] = _executor;
        emit ExecutorSet(_oapp, _remoteEid, _executor);
    }

    /// @dev this function change pack the path as required for EndpointV1
    function _execute(
        uint16 _srcEid,
        bytes32 _sender,
        address _receiver,
        uint64 _nonce,
        bytes memory _message,
        uint256 _gasLimit
    ) internal {
        // if the executor is malicious, it can make the msg as a storedPayload or fail in the nonBlockingApp
        // which might result in unintended behaviour and risks, like grieving.
        // to err on the safe side, we should assert the executor here.
        if (msg.sender != getExecutor(_receiver, _srcEid)) revert LZ_MessageLib_OnlyExecutor();

        if (_receiver.code.length == 0) {
            /// on chains where EOA has no codes, it will early return and emit InvalidDst event
            // on chains where all address have codes, this will be skipped
            emit InvalidDst(_srcEid, _sender, _receiver, _nonce, keccak256(_message));
            return;
        }

        bytes memory pathData = abi.encodePacked(_sender.toBytes(addressSizes[_srcEid]), _receiver);
        ILayerZeroEndpoint(endpoint).receivePayload(_srcEid, pathData, _receiver, _nonce, _gasLimit, _message);

        Origin memory origin = Origin(_srcEid, _sender, _nonce);
        emit PacketDelivered(origin, _receiver);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/ReceiveUln301.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { IUltraLightNode301 } from "./interfaces/IUltraLightNode301.sol";
import { ReceiveLibBaseE1 } from "./ReceiveLibBaseE1.sol";
import { ReceiveUlnBase } from "../ReceiveUlnBase.sol";
import { UlnConfig } from "../UlnBase.sol";

/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302
/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.
/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE1
contract ReceiveUln301 is IUltraLightNode301, ReceiveUlnBase, ReceiveLibBaseE1 {
    using PacketV1Codec for bytes;
    using SafeCast for uint32; // for chain ID uint32 to uint16 conversion

    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;
    uint256 internal constant CONFIG_TYPE_ULN = 2;

    error LZ_ULN_InvalidConfigType(uint256 configType);

    constructor(address _endpoint, uint32 _localEid) ReceiveLibBaseE1(_endpoint, _localEid) {}

    // ============================ OnlyEndpoint ===================================

    function setConfig(
        uint16 _eid,
        address _oapp,
        uint256 _configType,
        bytes calldata _config
    ) external override onlyEndpoint {
        _assertSupportedEid(_eid);
        if (_configType == CONFIG_TYPE_EXECUTOR) {
            _setExecutor(_eid, _oapp, abi.decode(_config, (address)));
        } else if (_configType == CONFIG_TYPE_ULN) {
            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));
        } else {
            revert LZ_ULN_InvalidConfigType(_configType);
        }
    }

    // ============================ External ===================================

    /// @dev in 301, this is equivalent to execution as in Endpoint V2
    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.
    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external {
        bytes calldata header = _packet.header();
        _assertHeader(header, localEid);

        // cache these values to save gas
        address receiver = _packet.receiverB20();
        uint16 srcEid = _packet.srcEid().toUint16();

        UlnConfig memory config = getUlnConfig(receiver, srcEid);
        _verifyAndReclaimStorage(config, keccak256(header), _packet.payloadHash());

        // endpoint will revert if nonce != ++inboundNonce
        _execute(srcEid, _packet.sender(), receiver, _packet.nonce(), _packet.message(), _gasLimit);
    }

    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {
        _verify(_packetHeader, _payloadHash, _confirmations);
    }

    // ============================ View ===================================

    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {
        if (_configType == CONFIG_TYPE_EXECUTOR) {
            return abi.encode(getExecutor(_oapp, _eid));
        } else if (_configType == CONFIG_TYPE_ULN) {
            return abi.encode(getUlnConfig(_oapp, _eid));
        } else {
            revert LZ_ULN_InvalidConfigType(_configType);
        }
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (3, 0, 1);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/ReceiveUln301View.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";
import { Initializable } from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";
import { AddressCast } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { ExecutionState, EndpointV2View } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2View.sol";

import { UlnConfig } from "../UlnBase.sol";

enum VerificationState {
    Verifying,
    Verifiable,
    Verified
}

interface IReceiveUln301 {
    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure;

    function addressSizes(uint32 _dstEid) external view returns (uint256);

    function endpoint() external view returns (address);

    function verifiable(
        UlnConfig memory _config,
        bytes32 _headerHash,
        bytes32 _payloadHash
    ) external view returns (bool);

    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);
}

contract ReceiveUln301View is Initializable, Proxied {
    using PacketV1Codec for bytes;
    using AddressCast for bytes32;
    using SafeCast for uint32;

    ILayerZeroEndpoint public endpoint;
    IReceiveUln301 public receiveUln301;
    uint32 internal localEid;

    function initialize(address _endpoint, uint32 _localEid, address _receiveUln301) external proxied initializer {
        receiveUln301 = IReceiveUln301(_receiveUln301);
        endpoint = ILayerZeroEndpoint(_endpoint);
        localEid = _localEid;
    }

    function executable(bytes calldata _packetHeader, bytes32 _payloadHash) public view returns (ExecutionState) {
        receiveUln301.assertHeader(_packetHeader, localEid);

        address receiver = _packetHeader.receiverB20();
        uint16 srcEid = _packetHeader.srcEid().toUint16();
        uint64 nonce = _packetHeader.nonce();

        // executed if nonce less than or equal to inboundNonce
        bytes memory path = abi.encodePacked(
            _packetHeader.sender().toBytes(receiveUln301.addressSizes(srcEid)),
            receiver
        );
        if (nonce <= endpoint.getInboundNonce(srcEid, path)) return ExecutionState.Executed;

        // executable if not executed and _verified
        if (
            receiveUln301.verifiable(
                receiveUln301.getUlnConfig(receiver, srcEid),
                keccak256(_packetHeader),
                _payloadHash
            )
        ) {
            return ExecutionState.Executable;
        }

        return ExecutionState.NotExecutable;
    }

    /// @dev keeping the same interface as 302
    /// @dev a verifiable message requires it to be ULN verifiable only, excluding the endpoint verifiable check
    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState) {
        if (executable(_packetHeader, _payloadHash) == ExecutionState.NotExecutable) {
            return VerificationState.Verifying;
        }
        return VerificationState.Verified;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/SendLibBaseE1.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { AddressCast } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol";
import { GUID } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/GUID.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { IMessageLibE1 } from "./interfaces/IMessageLibE1.sol";
import { ITreasuryFeeHandler } from "./interfaces/ITreasuryFeeHandler.sol";
import { INonceContract } from "./interfaces/INonceContract.sol";
import { SendLibBase, WorkerOptions, ExecutorConfig } from "../../SendLibBase.sol";
import { AddressSizeConfig } from "./AddressSizeConfig.sol";

/// @dev send-side message library base contract on endpoint v1.
/// design:
/// 1/ it enforces the path definition on V1 and interacts with the nonce contract
/// 2/ quote: first executor, then verifier (e.g. DVNs), then treasury
/// 3/ send: first executor, then verifier (e.g. DVNs), then treasury. the treasury pay much be DoS-proof
abstract contract SendLibBaseE1 is SendLibBase, AddressSizeConfig, IMessageLibE1 {
    INonceContract public immutable nonceContract;
    ITreasuryFeeHandler public immutable treasuryFeeHandler;

    // config
    address internal lzToken;

    // this event should be identical to the one on Endpoint V2
    event PacketSent(bytes encodedPayload, bytes options, uint256 nativeFee, uint256 lzTokenFee);
    event NativeFeeWithdrawn(address user, address receiver, uint256 amount);
    event LzTokenSet(address token);

    constructor(
        address _endpoint,
        uint256 _treasuryGasLimit,
        uint256 _treasuryNativeFeeCap,
        address _nonceContract,
        uint32 _localEid,
        address _treasuryFeeHandler
    ) SendLibBase(_endpoint, _localEid, _treasuryGasLimit, _treasuryNativeFeeCap) {
        nonceContract = INonceContract(_nonceContract);
        treasuryFeeHandler = ITreasuryFeeHandler(_treasuryFeeHandler);
    }

    // ======================= OnlyEndpoint =======================
    /// @dev the abstract process for send() is:
    /// 1/ pay workers, which includes the executor and the validation workers
    /// 2/ pay treasury
    /// 3/ in EndpointV1, here we handle the fees and refunds
    function send(
        address _sender,
        uint64, // _nonce
        uint16 _dstEid,
        bytes calldata _path, // remoteAddress + localAddress
        bytes calldata _message,
        address payable _refundAddress,
        address _lzTokenPaymentAddress,
        bytes calldata _options
    ) external payable onlyEndpoint {
        (bytes memory encodedPacket, uint256 totalNativeFee) = _payWorkers(_sender, _dstEid, _path, _message, _options);

        // quote treasury fee
        uint32 dstEid = _dstEid; // stack too deep
        address sender = _sender; // stack too deep
        bool payInLzToken = _lzTokenPaymentAddress != address(0x0) && address(lzToken) != address(0x0);
        (uint256 treasuryNativeFee, uint256 lzTokenFee) = _payTreasury(sender, dstEid, totalNativeFee, payInLzToken);
        totalNativeFee += treasuryNativeFee;

        // pay native fee
        // assert the user has attached enough native token for this address
        if (msg.value < totalNativeFee) revert LZ_MessageLib_InsufficientMsgValue();
        // refund if they send too much
        uint256 refundAmt = msg.value - totalNativeFee;
        if (refundAmt > 0) {
            Transfer.native(_refundAddress, refundAmt);
        }

        // pay lz token fee if needed
        if (lzTokenFee > 0) {
            // in v2, we let user pass a payInLzToken boolean but always charging the sender
            // likewise in v1, if _lzTokenPaymentAddress is passed, it must be the sender
            if (_lzTokenPaymentAddress != sender) revert LZ_MessageLib_LzTokenPaymentAddressMustBeSender();
            _payLzTokenFee(sender, lzTokenFee);
        }

        emit PacketSent(encodedPacket, _options, totalNativeFee, lzTokenFee);
    }

    // ======================= OnlyOwner =======================
    function setLzToken(address _lzToken) external onlyOwner {
        lzToken = _lzToken;
        emit LzTokenSet(_lzToken);
    }

    function setTreasury(address _treasury) external onlyOwner {
        _setTreasury(_treasury);
    }

    // ======================= External =======================
    function withdrawFee(address _to, uint256 _amount) external {
        _debitFee(_amount);
        Transfer.native(_to, _amount);
        emit NativeFeeWithdrawn(msg.sender, _to, _amount);
    }

    // ======================= View =======================
    function estimateFees(
        uint16 _dstEid,
        address _sender,
        bytes calldata _message,
        bool _payInLzToken,
        bytes calldata _options
    ) external view returns (uint256 nativeFee, uint256 lzTokenFee) {
        return _quote(_sender, _dstEid, _message.length, _payInLzToken, _options);
    }

    // ======================= Internal =======================
    /// @dev path = remoteAddress + localAddress.
    function _assertPath(address _sender, bytes calldata _path, uint256 remoteAddressSize) internal pure {
        if (_path.length != 20 + remoteAddressSize) revert LZ_MessageLib_InvalidPath();
        address srcInPath = AddressCast.toAddress(_path[remoteAddressSize:]);
        if (_sender != srcInPath) revert LZ_MessageLib_InvalidSender();
    }

    function _payLzTokenFee(address _sender, uint256 _lzTokenFee) internal {
        treasuryFeeHandler.payFee(
            lzToken,
            _sender,
            _lzTokenFee, // the supplied fee is always equal to the required fee
            _lzTokenFee,
            treasury
        );
    }

    /// @dev outbound does three things
    /// @dev 1) asserts path
    /// @dev 2) increments the nonce
    /// @dev 3) assemble packet
    /// @return packet to be sent to workers
    function _outbound(
        address _sender,
        uint16 _dstEid,
        bytes calldata _path,
        bytes calldata _message
    ) internal returns (Packet memory packet) {
        // assert toAddress size
        uint256 remoteAddressSize = addressSizes[_dstEid];
        if (remoteAddressSize == 0) revert LZ_MessageLib_InvalidPath();
        _assertPath(_sender, _path, remoteAddressSize);

        // increment nonce
        uint64 nonce = nonceContract.increment(_dstEid, _sender, _path);

        bytes32 receiver = AddressCast.toBytes32(_path[0:remoteAddressSize]);

        bytes32 guid = GUID.generate(nonce, localEid, _sender, _dstEid, receiver);

        // assemble packet
        packet = Packet(nonce, localEid, _sender, _dstEid, receiver, guid, _message);
    }

    /// 1/ handle executor
    /// 2/ handle other workers
    function _payWorkers(
        address _sender,
        uint16 _dstEid,
        bytes calldata _path,
        bytes calldata _message,
        bytes calldata _options
    ) internal returns (bytes memory encodedPacket, uint256 totalNativeFee) {
        Packet memory packet = _outbound(_sender, _dstEid, _path, _message);

        // split workers options
        (bytes memory executorOptions, WorkerOptions[] memory verificationOptions) = _splitOptions(_options);

        // handle executor
        ExecutorConfig memory config = getExecutorConfig(_sender, _dstEid);
        uint256 msgSize = packet.message.length;
        _assertMessageSize(msgSize, config.maxMessageSize);
        totalNativeFee += _payExecutor(config.executor, packet.dstEid, packet.sender, msgSize, executorOptions);

        // handle other workers
        (uint256 verifierFee, bytes memory packetBytes) = _payVerifier(packet, verificationOptions);
        totalNativeFee += verifierFee;

        encodedPacket = packetBytes;
    }

    // ======================= Virtual =======================
    function _payVerifier(
        Packet memory _packet, // packet is assembled in memory for endpoint-v1. so the location can not be calldata
        WorkerOptions[] memory _options
    ) internal virtual returns (uint256 otherWorkerFees, bytes memory encodedPacket);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/SendUln301.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";

import { ExecutorConfig, WorkerOptions } from "../../SendLibBase.sol";
import { SendLibBaseE1 } from "./SendLibBaseE1.sol";
import { SendUlnBase } from "../SendUlnBase.sol";
import { UlnConfig } from "../UlnBase.sol";

/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302
/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.
/// @dev In this case, it combines the logic of SendUlnBase and SendLibBaseE1
contract SendUln301 is SendUlnBase, SendLibBaseE1 {
    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;
    uint256 internal constant CONFIG_TYPE_ULN = 2;

    error LZ_ULN_InvalidConfigType(uint256 configType);

    constructor(
        address _endpoint,
        uint256 _treasuryGasLimit,
        uint256 _treasuryGasForFeeCap,
        address _nonceContract,
        uint32 _localEid,
        address _treasuryFeeHandler
    )
        SendLibBaseE1(
            _endpoint,
            _treasuryGasLimit,
            _treasuryGasForFeeCap,
            _nonceContract,
            _localEid,
            _treasuryFeeHandler
        )
    {}

    // ============================ OnlyEndpoint ===================================

    function setConfig(
        uint16 _eid,
        address _oapp,
        uint256 _configType,
        bytes calldata _config
    ) external override onlyEndpoint {
        _assertSupportedEid(_eid);
        if (_configType == CONFIG_TYPE_EXECUTOR) {
            _setExecutorConfig(_eid, _oapp, abi.decode(_config, (ExecutorConfig)));
        } else if (_configType == CONFIG_TYPE_ULN) {
            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));
        } else {
            revert LZ_ULN_InvalidConfigType(_configType);
        }
    }

    // ============================ View ===================================

    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {
        if (_configType == CONFIG_TYPE_EXECUTOR) {
            return abi.encode(getExecutorConfig(_oapp, _eid));
        } else if (_configType == CONFIG_TYPE_ULN) {
            return abi.encode(getUlnConfig(_oapp, _eid));
        } else {
            revert LZ_ULN_InvalidConfigType(_configType);
        }
    }

    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (3, 0, 1);
    }

    function isSupportedEid(uint32 _eid) external view returns (bool) {
        return _isSupportedEid(_eid);
    }

    // ============================ Internal ===================================

    function _quoteVerifier(
        address _sender,
        uint32 _dstEid,
        WorkerOptions[] memory _options
    ) internal view override returns (uint256) {
        return _quoteDVNs(_sender, _dstEid, _options);
    }

    function _payVerifier(
        Packet memory _packet,
        WorkerOptions[] memory _options
    ) internal virtual override returns (uint256 otherWorkerFees, bytes memory encodedPacket) {
        (otherWorkerFees, encodedPacket) = _payDVNs(fees, _packet, _options);
    }

    function _splitOptions(
        bytes calldata _options
    ) internal pure override returns (bytes memory, WorkerOptions[] memory) {
        return _splitUlnOptions(_options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/TreasuryFeeHandler.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";

import { ITreasuryFeeHandler } from "./interfaces/ITreasuryFeeHandler.sol";

contract TreasuryFeeHandler is ITreasuryFeeHandler {
    using SafeERC20 for IERC20;

    ILayerZeroEndpoint public immutable endpoint;

    error LZ_TreasuryFeeHandler_OnlySendLibrary();
    error LZ_TreasuryFeeHandler_OnlyOnSending();
    error LZ_TreasuryFeeHandler_InvalidAmount(uint256 required, uint256 supplied);

    constructor(address _endpoint) {
        endpoint = ILayerZeroEndpoint(_endpoint);
    }

    // @dev payer of layerzero token must be sender
    function payFee(
        address _lzToken,
        address _sender,
        uint256 _required,
        uint256 _supplied,
        address _treasury
    ) external {
        // only sender's message library can call this function and only when sending a payload
        if (endpoint.getSendLibraryAddress(_sender) != msg.sender) revert LZ_TreasuryFeeHandler_OnlySendLibrary();
        if (!endpoint.isSendingPayload()) revert LZ_TreasuryFeeHandler_OnlyOnSending();
        if (_required > _supplied) revert LZ_TreasuryFeeHandler_InvalidAmount(_required, _supplied);

        // send lz token fee to the treasury directly
        IERC20(_lzToken).safeTransferFrom(_sender, _treasury, _required);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/interfaces/IMessageLibE1.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { ILayerZeroMessagingLibrary } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol";

/// extends ILayerZeroMessagingLibrary instead of ILayerZeroMessagingLibraryV2 for reducing the contract size
interface IMessageLibE1 is ILayerZeroMessagingLibrary {
    error LZ_MessageLib_InvalidPath();
    error LZ_MessageLib_InvalidSender();
    error LZ_MessageLib_InsufficientMsgValue();
    error LZ_MessageLib_LzTokenPaymentAddressMustBeSender();

    function setLzToken(address _lzToken) external;

    function setTreasury(address _treasury) external;

    function withdrawFee(address _to, uint256 _amount) external;

    // message libs of same major version are compatible
    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/interfaces/INonceContract.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface INonceContract {
    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64);
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/interfaces/ITreasuryFeeHandler.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface ITreasuryFeeHandler {
    function payFee(
        address _lzToken,
        address _sender,
        uint256 _required,
        uint256 _supplied,
        address _treasury
    ) external;
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/interfaces/IUltraLightNode301.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface IUltraLightNode301 {
    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external;
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln301/mocks/NonceContractMock.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";

contract NonceContractMock {
    error OnlySendLibrary();

    ILayerZeroEndpoint public immutable endpoint;
    mapping(uint16 dstEid => mapping(bytes path => uint64 nonce)) public outboundNonce;

    constructor(address _endpoint) {
        endpoint = ILayerZeroEndpoint(_endpoint);
    }

    function increment(uint16 _chainId, address _ua, bytes calldata _path) external returns (uint64) {
        if (msg.sender != endpoint.getSendLibraryAddress(_ua)) {
            revert OnlySendLibrary();
        }
        return ++outboundNonce[_chainId][_path];
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln302/ReceiveUln302.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";
import { ILayerZeroEndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";

import { IReceiveUlnE2 } from "../interfaces/IReceiveUlnE2.sol";
import { ReceiveUlnBase } from "../ReceiveUlnBase.sol";
import { ReceiveLibBaseE2 } from "../../ReceiveLibBaseE2.sol";
import { UlnConfig } from "../UlnBase.sol";

/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.
/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE2
contract ReceiveUln302 is IReceiveUlnE2, ReceiveUlnBase, ReceiveLibBaseE2 {
    using PacketV1Codec for bytes;

    /// @dev CONFIG_TYPE_ULN=2 here to align with SendUln302/ReceiveUln302/ReceiveUln301
    uint32 internal constant CONFIG_TYPE_ULN = 2;

    error LZ_ULN_InvalidConfigType(uint32 configType);

    constructor(address _endpoint) ReceiveLibBaseE2(_endpoint) {}

    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {
        return _interfaceId == type(IReceiveUlnE2).interfaceId || super.supportsInterface(_interfaceId);
    }

    // ============================ OnlyEndpoint ===================================

    // only the ULN config on the receive side
    function setConfig(address _oapp, SetConfigParam[] calldata _params) external override onlyEndpoint {
        for (uint256 i = 0; i < _params.length; i++) {
            SetConfigParam calldata param = _params[i];
            _assertSupportedEid(param.eid);
            if (param.configType == CONFIG_TYPE_ULN) {
                _setUlnConfig(param.eid, _oapp, abi.decode(param.config, (UlnConfig)));
            } else {
                revert LZ_ULN_InvalidConfigType(param.configType);
            }
        }
    }

    // ============================ External ===================================

    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.
    function commitVerification(bytes calldata _packetHeader, bytes32 _payloadHash) external {
        _assertHeader(_packetHeader, localEid);

        // cache these values to save gas
        address receiver = _packetHeader.receiverB20();
        uint32 srcEid = _packetHeader.srcEid();

        UlnConfig memory config = getUlnConfig(receiver, srcEid);
        _verifyAndReclaimStorage(config, keccak256(_packetHeader), _payloadHash);

        Origin memory origin = Origin(srcEid, _packetHeader.sender(), _packetHeader.nonce());
        // endpoint will revert if nonce <= lazyInboundNonce
        ILayerZeroEndpointV2(endpoint).verify(origin, receiver, _payloadHash);
    }

    /// @dev for dvn to verify the payload
    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {
        _verify(_packetHeader, _payloadHash, _confirmations);
    }

    // ============================ View ===================================

    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view override returns (bytes memory) {
        if (_configType == CONFIG_TYPE_ULN) {
            return abi.encode(getUlnConfig(_oapp, _eid));
        } else {
            revert LZ_ULN_InvalidConfigType(_configType);
        }
    }

    function isSupportedEid(uint32 _eid) external view override returns (bool) {
        return _isSupportedEid(_eid);
    }

    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (3, 0, 2);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln302/ReceiveUln302View.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { EndpointV2ViewUpgradeable } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2ViewUpgradeable.sol";
import { UlnConfig } from "../UlnBase.sol";

enum VerificationState {
    Verifying,
    Verifiable,
    Verified,
    NotInitializable
}

interface IReceiveUln302 {
    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure;

    function verifiable(
        UlnConfig memory _config,
        bytes32 _headerHash,
        bytes32 _payloadHash
    ) external view returns (bool);

    function getUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory rtnConfig);
}

contract ReceiveUln302View is EndpointV2ViewUpgradeable, Proxied {
    using PacketV1Codec for bytes;

    IReceiveUln302 public receiveUln302;
    uint32 internal localEid;

    function initialize(address _endpoint, address _receiveUln302) external proxied initializer {
        __EndpointV2View_init(_endpoint);
        receiveUln302 = IReceiveUln302(_receiveUln302);
        localEid = endpoint.eid();
    }

    /// @dev a ULN verifiable requires it to be endpoint verifiable and committable
    function verifiable(bytes calldata _packetHeader, bytes32 _payloadHash) external view returns (VerificationState) {
        receiveUln302.assertHeader(_packetHeader, localEid);

        address receiver = _packetHeader.receiverB20();

        Origin memory origin = Origin(_packetHeader.srcEid(), _packetHeader.sender(), _packetHeader.nonce());

        // check endpoint initializable
        if (!initializable(origin, receiver)) {
            return VerificationState.NotInitializable;
        }

        // check endpoint verifiable
        if (!_endpointVerifiable(origin, receiver, _payloadHash)) {
            return VerificationState.Verified;
        }

        // check uln verifiable
        if (
            receiveUln302.verifiable(
                receiveUln302.getUlnConfig(receiver, origin.srcEid),
                keccak256(_packetHeader),
                _payloadHash
            )
        ) {
            return VerificationState.Verifiable;
        }
        return VerificationState.Verifying;
    }

    /// @dev checks for endpoint verifiable and endpoint has payload hash
    function _endpointVerifiable(
        Origin memory origin,
        address _receiver,
        bytes32 _payloadHash
    ) internal view returns (bool) {
        // check endpoint verifiable
        if (!verifiable(origin, _receiver, address(receiveUln302), _payloadHash)) return false;

        // if endpoint.verifiable, also check if the payload hash matches
        // endpoint allows re-verify, check if this payload has already been verified
        if (endpoint.inboundPayloadHash(_receiver, origin.srcEid, origin.sender, origin.nonce) == _payloadHash)
            return false;

        return true;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/uln/uln302/SendUln302.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";

import { ExecutorConfig } from "../../SendLibBase.sol";
import { SendLibBaseE2, WorkerOptions } from "../../SendLibBaseE2.sol";
import { UlnConfig } from "../UlnBase.sol";
import { SendUlnBase } from "../SendUlnBase.sol";

/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.
/// @dev In this case, it combines the logic of SendUlnBase and SendLibBaseE2
contract SendUln302 is SendUlnBase, SendLibBaseE2 {
    uint32 internal constant CONFIG_TYPE_EXECUTOR = 1;
    uint32 internal constant CONFIG_TYPE_ULN = 2;

    error LZ_ULN_InvalidConfigType(uint32 configType);

    constructor(
        address _endpoint,
        uint256 _treasuryGasLimit,
        uint256 _treasuryGasForFeeCap
    ) SendLibBaseE2(_endpoint, _treasuryGasLimit, _treasuryGasForFeeCap) {}

    // ============================ OnlyEndpoint ===================================

    // on the send side the user can config both the executor and the ULN
    function setConfig(address _oapp, SetConfigParam[] calldata _params) external override onlyEndpoint {
        for (uint256 i = 0; i < _params.length; i++) {
            SetConfigParam calldata param = _params[i];
            _assertSupportedEid(param.eid);
            if (param.configType == CONFIG_TYPE_EXECUTOR) {
                _setExecutorConfig(param.eid, _oapp, abi.decode(param.config, (ExecutorConfig)));
            } else if (param.configType == CONFIG_TYPE_ULN) {
                _setUlnConfig(param.eid, _oapp, abi.decode(param.config, (UlnConfig)));
            } else {
                revert LZ_ULN_InvalidConfigType(param.configType);
            }
        }
    }

    // ============================ View ===================================

    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view override returns (bytes memory) {
        if (_configType == CONFIG_TYPE_EXECUTOR) {
            return abi.encode(getExecutorConfig(_oapp, _eid));
        } else if (_configType == CONFIG_TYPE_ULN) {
            return abi.encode(getUlnConfig(_oapp, _eid));
        } else {
            revert LZ_ULN_InvalidConfigType(_configType);
        }
    }

    function version() external pure override returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (3, 0, 2);
    }

    function isSupportedEid(uint32 _eid) external view override returns (bool) {
        return _isSupportedEid(_eid);
    }

    // ============================ Internal ===================================

    function _quoteVerifier(
        address _sender,
        uint32 _dstEid,
        WorkerOptions[] memory _options
    ) internal view override returns (uint256) {
        return _quoteDVNs(_sender, _dstEid, _options);
    }

    function _payVerifier(
        Packet calldata _packet,
        WorkerOptions[] memory _options
    ) internal override returns (uint256 otherWorkerFees, bytes memory encodedPacket) {
        (otherWorkerFees, encodedPacket) = _payDVNs(fees, _packet, _options);
    }

    function _splitOptions(
        bytes calldata _options
    ) internal pure override returns (bytes memory, WorkerOptions[] memory) {
        return _splitUlnOptions(_options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/upgradeable/WorkerUpgradeable.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { PausableUpgradeable } from "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import { AccessControlUpgradeable } from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import { Initializable } from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import { ISendLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

import { IWorker } from "../interfaces/IWorker.sol";

abstract contract WorkerUpgradeable is Initializable, AccessControlUpgradeable, PausableUpgradeable, IWorker {
    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256("MESSAGE_LIB_ROLE");
    bytes32 internal constant ALLOWLIST = keccak256("ALLOWLIST");
    bytes32 internal constant DENYLIST = keccak256("DENYLIST");
    bytes32 internal constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    address public workerFeeLib;

    uint64 public allowlistSize;
    uint16 public defaultMultiplierBps;
    address public priceFeed;

    mapping(uint32 eid => uint8[] optionTypes) internal supportedOptionTypes;

    /// @param _messageLibs array of message lib addresses that are granted the MESSAGE_LIB_ROLE
    /// @param _priceFeed price feed address
    /// @param _defaultMultiplierBps default multiplier for worker fee
    /// @param _roleAdmin address that is granted the DEFAULT_ADMIN_ROLE (can grant and revoke all roles)
    /// @param _admins array of admin addresses that are granted the ADMIN_ROLE
    function __Worker_init(
        address[] memory _messageLibs,
        address _priceFeed,
        uint16 _defaultMultiplierBps,
        address _roleAdmin,
        address[] memory _admins
    ) internal onlyInitializing {
        __Context_init_unchained();
        __AccessControl_init_unchained();
        __Pausable_init_unchained();
        __Worker_init_unchained(_messageLibs, _priceFeed, _defaultMultiplierBps, _roleAdmin, _admins);
    }

    function __Worker_init_unchained(
        address[] memory _messageLibs,
        address _priceFeed,
        uint16 _defaultMultiplierBps,
        address _roleAdmin,
        address[] memory _admins
    ) internal onlyInitializing {
        defaultMultiplierBps = _defaultMultiplierBps;
        priceFeed = _priceFeed;

        if (_roleAdmin != address(0x0)) {
            _grantRole(DEFAULT_ADMIN_ROLE, _roleAdmin); // _roleAdmin can grant and revoke all roles
        }

        for (uint256 i = 0; i < _messageLibs.length; ++i) {
            _grantRole(MESSAGE_LIB_ROLE, _messageLibs[i]);
        }

        for (uint256 i = 0; i < _admins.length; ++i) {
            _grantRole(ADMIN_ROLE, _admins[i]);
        }
    }

    // ========================= Modifier =========================

    modifier onlyAcl(address _sender) {
        if (!hasAcl(_sender)) {
            revert Worker_NotAllowed();
        }
        _;
    }

    /// @dev Access control list using allowlist and denylist
    /// @dev 1) if one address is in the denylist -> deny
    /// @dev 2) else if address in the allowlist OR allowlist is empty (allows everyone)-> allow
    /// @dev 3) else deny
    /// @param _sender address to check
    function hasAcl(address _sender) public view returns (bool) {
        if (hasRole(DENYLIST, _sender)) {
            return false;
        } else if (allowlistSize == 0 || hasRole(ALLOWLIST, _sender)) {
            return true;
        } else {
            return false;
        }
    }

    // ========================= OnyDefaultAdmin =========================

    /// @dev flag to pause execution of workers (if used with whenNotPaused modifier)
    /// @param _paused true to pause, false to unpause
    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_paused) {
            _pause();
        } else {
            _unpause();
        }
    }

    // ========================= OnlyAdmin =========================

    /// @param _priceFeed price feed address
    function setPriceFeed(address _priceFeed) external onlyRole(ADMIN_ROLE) {
        priceFeed = _priceFeed;
        emit SetPriceFeed(_priceFeed);
    }

    /// @param _workerFeeLib worker fee lib address
    function setWorkerFeeLib(address _workerFeeLib) external onlyRole(ADMIN_ROLE) {
        workerFeeLib = _workerFeeLib;
        emit SetWorkerLib(_workerFeeLib);
    }

    /// @param _multiplierBps default multiplier for worker fee
    function setDefaultMultiplierBps(uint16 _multiplierBps) external onlyRole(ADMIN_ROLE) {
        defaultMultiplierBps = _multiplierBps;
        emit SetDefaultMultiplierBps(_multiplierBps);
    }

    /// @dev supports withdrawing fee from ULN301, ULN302 and more
    /// @param _lib message lib address
    /// @param _to address to withdraw fee to
    /// @param _amount amount to withdraw
    function withdrawFee(address _lib, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {
        if (!hasRole(MESSAGE_LIB_ROLE, _lib)) revert Worker_OnlyMessageLib();
        ISendLib(_lib).withdrawFee(_to, _amount);
        emit Withdraw(_lib, _to, _amount);
    }

    /// @dev supports withdrawing token from the contract
    /// @param _token token address
    /// @param _to address to withdraw token to
    /// @param _amount amount to withdraw
    function withdrawToken(address _token, address _to, uint256 _amount) external onlyRole(ADMIN_ROLE) {
        // transfers native if _token is address(0x0)
        Transfer.nativeOrToken(_token, _to, _amount);
    }

    function setSupportedOptionTypes(uint32 _eid, uint8[] calldata _optionTypes) external onlyRole(ADMIN_ROLE) {
        supportedOptionTypes[_eid] = _optionTypes;
    }

    // ========================= View Functions =========================
    function getSupportedOptionTypes(uint32 _eid) external view returns (uint8[] memory) {
        return supportedOptionTypes[_eid];
    }

    // ========================= Internal Functions =========================

    /// @dev overrides AccessControl to allow for counting of allowlistSize
    /// @param _role role to grant
    /// @param _account address to grant role to
    function _grantRole(bytes32 _role, address _account) internal override {
        if (_role == ALLOWLIST && !hasRole(_role, _account)) {
            ++allowlistSize;
        }
        super._grantRole(_role, _account);
    }

    /// @dev overrides AccessControl to allow for counting of allowlistSize
    /// @param _role role to revoke
    /// @param _account address to revoke role from
    function _revokeRole(bytes32 _role, address _account) internal override {
        if (_role == ALLOWLIST && hasRole(_role, _account)) {
            --allowlistSize;
        }
        super._revokeRole(_role, _account);
    }

    /// @dev overrides AccessControl to disable renouncing of roles
    function renounceRole(bytes32 /*role*/, address /*account*/) public pure override {
        revert Worker_RoleRenouncingDisabled();
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[47] private __gap;
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/upgradeable/proxy/ProxyAdmin.sol
================================================================================

// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)

pragma solidity ^0.8.0;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { TransparentUpgradeableProxy } from "./TransparentUpgradeableProxy.sol";

/**
 * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/ProxyAdmin.sol
 * to support custom errors and `initialOwner` constructor parameter.
 * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an
 * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.
 */
contract ProxyAdmin is Ownable {
    error ImplementationCallFailed();
    error AdminCallFailed();

    constructor(address initialOwner) {
        _transferOwnership(initialOwner);
    }

    /**
     * @dev Returns the current implementation of `proxy`.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256("implementation()")) == 0x5c60da1b
        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b");
        if (!success) {
            revert ImplementationCallFailed();
        }
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Returns the current admin of `proxy`.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256("admin()")) == 0xf851a440
        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440");
        if (!success) {
            revert AdminCallFailed();
        }
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Changes the admin of `proxy` to `newAdmin`.
     *
     * Requirements:
     *
     * - This contract must be the current admin of `proxy`.
     */
    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {
        proxy.changeAdmin(newAdmin);
    }

    /**
     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {
        proxy.upgradeTo(implementation);
    }

    /**
     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See
     * {TransparentUpgradeableProxy-upgradeToAndCall}.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function upgradeAndCall(
        TransparentUpgradeableProxy proxy,
        address implementation,
        bytes memory data
    ) public payable virtual onlyOwner {
        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/contracts/upgradeable/proxy/TransparentUpgradeableProxy.sol
================================================================================

// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)

pragma solidity ^0.8.0;

import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @author OpenZeppelin. Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/proxy/transparent/TransparentUpgradeableProxy.sol
 * to support custom errors.
 * @dev This contract implements a proxy that is upgradeable by an admin.
 *
 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
 * clashing], which can potentially be used in an attack, this contract uses the
 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
 * things that go hand in hand:
 *
 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
 * that call matches one of the admin functions exposed by the proxy itself.
 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the
 * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating
 * the proxy admin cannot fallback to the target implementation.
 *
 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing
 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due
 * to sudden errors when trying to call a function from the proxy implementation.
 *
 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,
 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.
 */
contract TransparentUpgradeableProxy is ERC1967Proxy {
    /**
     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.
     */
    error AdminAccessDenied();

    /**
     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and
     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.
     */
    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _changeAdmin(admin_);
    }

    /**
     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.
     */
    modifier ifAdmin() {
        if (msg.sender == _getAdmin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @dev Returns the current admin.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
     */
    function admin() external ifAdmin returns (address admin_) {
        admin_ = _getAdmin();
    }

    /**
     * @dev Returns the current implementation.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
     */
    function implementation() external ifAdmin returns (address implementation_) {
        implementation_ = _implementation();
    }

    /**
     * @dev Changes the admin of the proxy.
     *
     * Emits an {AdminChanged} event.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.
     */
    function changeAdmin(address newAdmin) external virtual ifAdmin {
        _changeAdmin(newAdmin);
    }

    /**
     * @dev Upgrade the implementation of the proxy.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeToAndCall(newImplementation, bytes(""), false);
    }

    /**
     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified
     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the
     * proxied contract.
     *
     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.
     */
    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {
        _upgradeToAndCall(newImplementation, data, true);
    }

    /**
     * @dev Returns the current admin.
     */
    function _admin() internal view virtual returns (address) {
        return _getAdmin();
    }

    /**
     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.
     */
    function _beforeFallback() internal virtual override {
        if (msg.sender == _getAdmin()) {
            revert AdminAccessDenied();
        }
        super._beforeFallback();
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/AddressSizeConfig.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { AddressSizeConfig } from "../contracts/uln/uln301/AddressSizeConfig.sol";

contract AddressSizeConfigTest is AddressSizeConfig, Test {
    function test_setAddressSize() public {
        vm.startPrank(owner());

        // can not set address size more than 32
        vm.expectRevert(AddressSizeConfig_InvalidAddressSize.selector);
        this.setAddressSize(1, 33);

        this.setAddressSize(1, 32);
        assertEq(addressSizes[1], 32);

        // can not set address size twice
        vm.expectRevert(AddressSizeConfig_AddressSizeAlreadySet.selector);
        this.setAddressSize(1, 31);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/DVN.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { Strings } from "@openzeppelin/contracts/utils/Strings.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { IWorker } from "../contracts/interfaces/IWorker.sol";
import { DVN } from "../contracts/uln/dvn/DVN.sol";
import { ExecuteParam } from "../contracts/uln/dvn/DVN.sol";
import { IReceiveUlnE2 } from "../contracts/uln/interfaces/IReceiveUlnE2.sol";
import { IDVN } from "../contracts/uln/interfaces/IDVN.sol";
import { IDVNFeeLib } from "../contracts/uln/interfaces/IDVNFeeLib.sol";
import { ILayerZeroDVN } from "../contracts/uln/interfaces/ILayerZeroDVN.sol";

import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { Constant } from "./util/Constant.sol";

contract DVNTest is Test {
    using BytesLib for bytes;

    bytes32 internal constant MESSAGE_LIB_ROLE = keccak256("MESSAGE_LIB_ROLE");
    bytes32 internal constant ALLOWLIST = keccak256("ALLOWLIST");
    bytes32 internal constant DENYLIST = keccak256("DENYLIST");
    bytes32 internal constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    event SetDstConfig(IDVN.DstConfigParam[] params);
    event AssignJob(uint32 dstEid, address oapp, uint64 confirmations, uint256 totalFee);
    event SetWorkerLib(address workerLib);
    event SetPriceFeed(address priceFeed);
    event SetDefaultMultiplierBps(uint16 multiplierBps);
    event Withdraw(address lib, address to, uint256 amount);

    Setup.FixtureV2 internal fixtureV2;
    DVN internal dvn;
    uint32 internal eid;

    address internal alice = address(0x1);
    address internal bob = address(0x2);
    address internal charlie = address(0x3);

    function setUp() public {
        fixtureV2 = Setup.loadFixtureV2(Constant.EID_ETHEREUM);
        dvn = fixtureV2.dvn;
        eid = fixtureV2.eid;
    }

    function test_SetAdmin() public {
        bool isAdmin = dvn.hasRole(ADMIN_ROLE, alice);
        assertTrue(!isAdmin, "alice is not admin");

        dvn.grantRole(ADMIN_ROLE, alice); // address(this) is admin, so it can set others to be admin
        isAdmin = dvn.hasRole(ADMIN_ROLE, alice);
        assertTrue(isAdmin, "alice is admin");
    }

    function test_Revert_SetAdmin_NotByAdmin() public {
        vm.expectRevert(
            abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(bob),
                " is missing role ",
                Strings.toHexString(uint256(ADMIN_ROLE), 32)
            )
        );
        vm.prank(bob);
        dvn.grantRole(ADMIN_ROLE, alice); // bob is not admin, so it cannot set others to be admin
    }

    function test_AddSigner() public {
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(alice, true);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(bob, true);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(charlie, true);

        assertEq(dvn.signers(alice), true, "alice is signer");
        assertEq(dvn.signers(bob), true, "bob is signer");
        assertEq(dvn.signers(charlie), true, "charlie is signer");
    }

    function test_Revert_SetSigner_NotBySelf() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.setSigner(alice, true);
    }

    function test_SetQuorum() public {
        // add 2 signers before setting quorum
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(alice, true);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(bob, true);

        // set quorum to 2
        vm.prank(address(dvn)); // only self can set quorum
        dvn.setQuorum(2);

        assertEq(dvn.quorum(), 2, "quorum is 2");
    }

    function test_Revert_SetQuorum_NotBySelf() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.setQuorum(2);
    }

    function test_GrantRole_MessageLib() public {
        // only self can grant MessageLib role
        vm.prank(address(dvn));
        dvn.grantRole(MESSAGE_LIB_ROLE, alice);
        assertTrue(dvn.hasRole(MESSAGE_LIB_ROLE, alice), "alice has message lib role");
    }

    function test_Revert_GrantRole_MessageLib_NotBySelf() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.grantRole(MESSAGE_LIB_ROLE, alice);
    }

    function test_Revert_GrantRole_MessageLib_IfAdmin() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        dvn.grantRole(MESSAGE_LIB_ROLE, alice); // address(this) is admin
    }

    function test_GrantRevokeRole_AllowList() public {
        // only self can grant AllowList role
        vm.prank(address(dvn));
        dvn.grantRole(ALLOWLIST, alice);
        assertTrue(dvn.hasRole(ALLOWLIST, alice), "alice has AllowList role");

        uint256 allowlistSize = dvn.allowlistSize();
        assertEq(allowlistSize, 1, "allowlist size is 1");

        // only self can grant AllowList role
        vm.prank(address(dvn));
        dvn.revokeRole(ALLOWLIST, alice);
        assertTrue(!dvn.hasRole(ALLOWLIST, alice), "alice has no AllowList role");

        allowlistSize = dvn.allowlistSize();
        assertEq(allowlistSize, 0, "allowlist size is 0");
    }

    function test_Revert_GrantRevokeRole_AllowList_NotBySelf() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.grantRole(ALLOWLIST, alice);

        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.revokeRole(ALLOWLIST, alice);
    }

    function test_Revert_GrantRevokeRole_AllowList_IfAdmin() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        dvn.grantRole(ALLOWLIST, alice); // address(this) is admin

        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        dvn.revokeRole(ALLOWLIST, alice); // address(this) is admin
    }

    function test_GrantRevokeRole_DENYLIST() public {
        // only self can grant DENYLIST role
        vm.prank(address(dvn));
        dvn.grantRole(DENYLIST, alice);
        assertTrue(dvn.hasRole(DENYLIST, alice), "alice has DENYLIST role");

        // only self can grant DENYLIST role
        vm.prank(address(dvn));
        dvn.revokeRole(DENYLIST, alice);
        assertTrue(!dvn.hasRole(DENYLIST, alice), "alice has no DENYLIST role");
    }

    function test_Revert_GrantRevokeRole_DENYLIST_NotBySelf() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.grantRole(DENYLIST, alice);

        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        vm.prank(bob);
        dvn.revokeRole(DENYLIST, alice);
    }

    function test_Revert_GrantRevokeRole_DENYLIST_IfAdmin() public {
        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        dvn.grantRole(DENYLIST, alice); // address(this) is admin

        vm.expectRevert(DVN.DVN_OnlySelf.selector);
        dvn.revokeRole(DENYLIST, alice); // address(this) is admin
    }

    function test_GrantRevokeRole_ADMIN() public {
        // only admin can grant ADMIN_ROLE role
        dvn.grantRole(ADMIN_ROLE, alice);
        assertTrue(dvn.hasRole(ADMIN_ROLE, alice), "alice has ADMIN_ROLE role");

        // only admin can grant ADMIN_ROLE role
        dvn.revokeRole(ADMIN_ROLE, alice);
        assertTrue(!dvn.hasRole(ADMIN_ROLE, alice), "alice has no ADMIN_ROLE role");
    }

    function test_Revert_GrantRevokeRole_ADMIN_NotByAdmin() public {
        vm.expectRevert(
            abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(bob),
                " is missing role ",
                Strings.toHexString(uint256(ADMIN_ROLE), 32)
            )
        );
        vm.prank(bob);
        dvn.grantRole(ADMIN_ROLE, alice);

        vm.expectRevert(
            abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(bob),
                " is missing role ",
                Strings.toHexString(uint256(ADMIN_ROLE), 32)
            )
        );
        vm.prank(bob);
        dvn.revokeRole(ADMIN_ROLE, alice);
    }

    function test_Revert_GrantRevokeRole_ADMIN_IfSelf() public {
        vm.expectRevert(
            abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(address(dvn)),
                " is missing role ",
                Strings.toHexString(uint256(ADMIN_ROLE), 32)
            )
        );
        vm.prank(address(dvn));
        dvn.grantRole(ADMIN_ROLE, alice);

        vm.expectRevert(
            abi.encodePacked(
                "AccessControl: account ",
                Strings.toHexString(address(dvn)),
                " is missing role ",
                Strings.toHexString(uint256(ADMIN_ROLE), 32)
            )
        );
        vm.prank(address(dvn));
        dvn.revokeRole(ADMIN_ROLE, alice);
    }

    function test_Revert_GrantRevokeRole_UnknownRole() public {
        bytes32 unknownRole = bytes32(uint256(123));
        vm.expectRevert(abi.encodeWithSelector(DVN.DVN_InvalidRole.selector, unknownRole));
        dvn.grantRole(unknownRole, alice);

        vm.expectRevert(abi.encodeWithSelector(DVN.DVN_InvalidRole.selector, unknownRole));
        dvn.revokeRole(unknownRole, alice);
    }

    function test_SetDstConfig() public {
        IDVN.DstConfigParam[] memory params = new IDVN.DstConfigParam[](1);
        params[0] = IDVN.DstConfigParam(1, 1, 1, 1);
        vm.expectEmit(true, false, false, true);
        emit SetDstConfig(params);
        dvn.setDstConfig(params);
    }

    function test_Revert_SetDstConfig_NotByAdmin() public {
        IDVN.DstConfigParam[] memory params = new IDVN.DstConfigParam[](1);
        params[0] = IDVN.DstConfigParam(1, 1, 1, 1);
        // not admin
        vm.expectRevert();
        vm.prank(bob);
        dvn.setDstConfig(params);
    }

    function test_QuorumChangeAdmin() public {
        // add signer first
        address signer = vm.addr(1);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(signer, true);

        bool isAdmin = dvn.hasRole(ADMIN_ROLE, alice);
        assertTrue(!isAdmin, "alice is not admin");

        bytes memory data = abi.encode(alice);
        bytes memory signatures;
        {
            bytes32 hash = dvn.hashCallData(eid, address(dvn), data, 1000);
            bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // sign by signer
            signatures = abi.encodePacked(r, s, v);
        }
        dvn.quorumChangeAdmin(ExecuteParam(eid, address(dvn), data, 1000, signatures));

        isAdmin = dvn.hasRole(ADMIN_ROLE, alice);
        assertTrue(isAdmin, "alice is admin");
    }

    function test_Revert_QuorumChangeAdmin_Expired() public {
        // add signer first
        address signer = vm.addr(1);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(signer, true);

        bytes memory data = abi.encode(alice);
        bytes memory signatures;
        {
            bytes32 hash = dvn.hashCallData(eid, address(dvn), data, 0);
            bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // sign by signer
            signatures = abi.encodePacked(r, s, v);
        }
        vm.expectRevert(DVN.DVN_InstructionExpired.selector);
        dvn.quorumChangeAdmin(ExecuteParam(eid, address(dvn), data, 0, signatures));
    }

    function test_Revert_QuorumChangeAdmin_InvalidVid() public {
        // add signer first
        address signer = vm.addr(1);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(signer, true);

        uint32 invalidVid = 123;
        bytes memory data = abi.encode(alice);
        bytes memory signatures;
        {
            bytes32 hash = dvn.hashCallData(invalidVid, address(dvn), data, 1000);
            bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // sign by signer
            signatures = abi.encodePacked(r, s, v);
        }
        vm.expectRevert(abi.encodeWithSelector(DVN.DVN_InvalidVid.selector, invalidVid));
        dvn.quorumChangeAdmin(ExecuteParam(invalidVid, address(dvn), data, 1000, signatures));
    }

    function test_Revert_QuorumChangeAdmin_InvalidTarget() public {
        // add signer first
        address signer = vm.addr(1);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(signer, true);

        address invalidTarget = address(this);
        bytes memory data = abi.encode(alice);
        bytes memory signatures;
        {
            bytes32 hash = dvn.hashCallData(eid, invalidTarget, data, 1000);
            bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // sign by signer
            signatures = abi.encodePacked(r, s, v);
        }
        vm.expectRevert(abi.encodeWithSelector(DVN.DVN_InvalidTarget.selector, invalidTarget));
        dvn.quorumChangeAdmin(ExecuteParam(eid, invalidTarget, data, 1000, signatures));
    }

    function test_Execute() public {
        // add signer first
        address signer = vm.addr(1);
        vm.prank(address(dvn)); // only self can set signer
        dvn.setSigner(signer, true);

        bytes memory data = abi.encodeWithSelector(DVN.setSigner.selector, alice, true); // proposal: set alice as signer
        bytes memory signatures;
        {
            bytes32 hash = dvn.hashCallData(eid, address(dvn), data, 1000);
            bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
            (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // sign by signer
            signatures = abi.encodePacked(r, s, v);
        }
        ExecuteParam[] memory params = new ExecuteParam[](1);
        params[0] = ExecuteParam(eid, address(dvn), data, 1000, signatures);
        dvn.execute(params);

        assertEq(dvn.signers(alice), true, "alice is signer");
    }

    function test_Revert_Execute_NotByAdmin() public {
        ExecuteParam[] memory params = new ExecuteParam[](1);
        params[0] = ExecuteParam(eid, address(dvn), "", 1000, "");
        // not admin
        vm.expectRevert();
        vm.prank(bob);
        dvn.execute(params);
    }

    function test_Revert_AssignJob_NotByMessageLib() public {
        vm.expectRevert();
        dvn.assignJob(ILayerZeroDVN.AssignJobParam(0, "", "", 0, address(0)), "");
    }

    function test_Revert_AssignJob_UlnV2_NotByMessageLib() public {
        vm.expectRevert();
        dvn.assignJob(0, 0, 0, address(0));
    }

    function test_Revert_AssignJob_NotAcl_Denied() public {
        // set deniedSender to denylist
        address deniedSender = address(1);
        vm.prank(address(dvn));
        dvn.grantRole(DENYLIST, deniedSender);

        vm.expectRevert(IWorker.Worker_NotAllowed.selector);
        vm.prank(address(fixtureV2.sendUln302));
        dvn.assignJob(ILayerZeroDVN.AssignJobParam(0, "", "", 0, deniedSender), "");
    }

    function test_Revert_AssignJob_NotAcl_NotInAllowList() public {
        // set allowed sender to allowlist
        address allowedSender = address(1);
        vm.prank(address(dvn));
        dvn.grantRole(ALLOWLIST, allowedSender);

        address sender = address(2);
        vm.expectRevert(IWorker.Worker_NotAllowed.selector);
        vm.prank(address(fixtureV2.sendUln302));
        dvn.assignJob(ILayerZeroDVN.AssignJobParam(0, "", "", 0, sender), "");
    }

    function test_GetFee() public {
        // mock feeLib getFee
        address workerFeeLib = dvn.workerFeeLib();
        vm.mockCall(workerFeeLib, abi.encodeWithSelector(IDVNFeeLib.getFee.selector), abi.encode(100));
        assertEq(dvn.getFee(0, 0, address(0), ""), 100, "fee is mocked by 100");
    }

    function test_GetFee_UlnV2() public {
        // mock feeLib getFee
        address workerFeeLib = dvn.workerFeeLib();
        vm.mockCall(workerFeeLib, abi.encodeWithSelector(IDVNFeeLib.getFee.selector), abi.encode(100));
        assertEq(dvn.getFee(0, 0, 0, address(0)), 100, "fee is mocked by 100");
    }

    function test_Revert_GetFee_NotAcl_Denied() public {
        // set deniedSender to denylist
        address deniedSender = address(1);
        vm.prank(address(dvn));
        dvn.grantRole(DENYLIST, deniedSender);

        vm.expectRevert(IWorker.Worker_NotAllowed.selector);
        dvn.getFee(0, 0, deniedSender, "");
    }

    function test_Revert_GetFee_NotAcl_NotInAllowList() public {
        // set allowed sender to allowlist
        address allowedSender = address(1);
        vm.prank(address(dvn));
        dvn.grantRole(ALLOWLIST, allowedSender);

        address sender = address(2);
        vm.expectRevert(IWorker.Worker_NotAllowed.selector);
        dvn.getFee(0, 0, sender, "");
    }

    function test_WithdrawFee() public {
        // mock
        vm.mockCall(
            address(fixtureV2.sendUln302),
            abi.encodeWithSelector(fixtureV2.sendUln302.withdrawFee.selector),
            ""
        );
        vm.expectEmit(true, false, false, true);
        emit Withdraw(address(fixtureV2.sendUln302), address(1), 100);
        dvn.withdrawFee(address(fixtureV2.sendUln302), address(1), 100);
    }

    function test_Revert_WithdrawFee_NotByAdmin() public {
        vm.expectRevert();
        vm.prank(bob);
        dvn.withdrawFee(address(0), address(0), 0);
    }

    function test_Revert_WithdrawFee_NotUlnLib() public {
        address unknownUlnLib = address(1);
        vm.expectRevert(IWorker.Worker_OnlyMessageLib.selector);
        dvn.withdrawFee(unknownUlnLib, address(1), 0);
    }

    function test_SetPriceFeed() public {
        vm.expectEmit(true, false, false, true);
        emit SetPriceFeed(address(1));
        dvn.setPriceFeed(address(1));
    }

    function test_Revert_SetPriceFeed_NotByAdmin() public {
        vm.expectRevert();
        vm.prank(bob);
        dvn.setPriceFeed(address(1));
    }

    function test_SetWorkerFeeLib() public {
        vm.expectEmit(true, false, false, true);
        emit SetWorkerLib(address(1));
        dvn.setWorkerFeeLib(address(1));
    }

    function test_Revert_SetWorkerFeeLib_NotByAdmin() public {
        vm.expectRevert();
        vm.prank(bob);
        dvn.setWorkerFeeLib(address(1));
    }

    function test_SetDefaultMultiplierBps() public {
        vm.expectEmit(true, false, false, true);
        emit SetDefaultMultiplierBps(100);
        dvn.setDefaultMultiplierBps(100);
    }

    function test_Revert_SetDefaultMultiplierBps_NotByAdmin() public {
        vm.expectRevert();
        vm.prank(bob);
        dvn.setDefaultMultiplierBps(100);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/DVNFeeLib.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { IDVN } from "../contracts/uln/interfaces/IDVN.sol";
import { IDVNFeeLib } from "../contracts/uln/interfaces/IDVNFeeLib.sol";
import { DVNFeeLib } from "../contracts/uln/dvn/DVNFeeLib.sol";

import { PriceFeedMock } from "./mocks/PriceFeedMock.sol";

contract DVNFeeLibTest is Test {
    uint16 constant EXECUTE_FIXED_BYTES = 68;
    uint16 constant SIGNATURE_RAW_BYTES = 65;
    uint16 constant UPDATE_HASH_BYTES = 224;

    DVNFeeLib dvnFeeLib;
    PriceFeedMock priceFeed;
    IDVN.DstConfig config;
    uint16 defaultMultiplierBps = 12000;
    uint32 dstEid = 101;
    uint256 gasFee = 100;
    uint128 priceRatio = 1e10;
    uint128 nativePriceUSD = 2000e10;
    uint64 gas = 1;
    uint16 multiplierBps = 10000;
    uint128 floorMarginUSD = 3e10;
    uint64 quorum = 3;
    address oapp = address(0);
    uint64 confirmations = 15;

    function setUp() public {
        priceFeed = new PriceFeedMock();
        dvnFeeLib = new DVNFeeLib(1e18);
        priceFeed.setup(gasFee, priceRatio, nativePriceUSD);
    }

    // quorum * signatureRawBytes == 0
    function test_getFee_notPadded_defaultMultiplier() public {
        quorum = 32;
        config = IDVN.DstConfig(gas, 0, 0);

        uint256 expected = (gasFee * defaultMultiplierBps) / 10000;
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            confirmations,
            oapp,
            quorum,
            defaultMultiplierBps
        );
        uint256 actual = dvnFeeLib.getFee(params, config, "");

        assertEq(actual, expected);
    }

    // quorum * signatureRawBytes != 0
    function test_getFee_padded_defaultMultiplier() public {
        config = IDVN.DstConfig(gas, 0, 0);

        uint256 expected = (gasFee * defaultMultiplierBps) / 10000;
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            confirmations,
            oapp,
            quorum,
            defaultMultiplierBps
        );
        uint256 actual = dvnFeeLib.getFee(params, config, "");

        assertEq(actual, expected);
    }

    function test_getFee_specificMultiplier() public {
        config = IDVN.DstConfig(gas, multiplierBps, 0);

        uint256 expected = (gasFee * multiplierBps) / 10000;
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            confirmations,
            oapp,
            quorum,
            defaultMultiplierBps
        );
        uint256 actual = dvnFeeLib.getFee(params, config, "");

        assertEq(actual, expected);
    }

    function test_getFee_floorMargin() public {
        config = IDVN.DstConfig(gas, multiplierBps, floorMarginUSD);

        uint256 expected = gasFee + (floorMarginUSD * 1e18) / nativePriceUSD;
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            confirmations,
            oapp,
            quorum,
            defaultMultiplierBps
        );
        uint256 actual = dvnFeeLib.getFee(params, config, "");

        assertEq(actual, expected);
    }

    function test_getFee_nativeTokenPriceZero_specificMultiplier() public {
        config = IDVN.DstConfig(gas, multiplierBps, floorMarginUSD);
        priceFeed.setup(gasFee, priceRatio, 0);

        uint256 expected = (gasFee * multiplierBps) / 10000;
        IDVNFeeLib.FeeParams memory params = IDVNFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            confirmations,
            oapp,
            quorum,
            defaultMultiplierBps
        );
        uint256 actual = dvnFeeLib.getFee(params, config, "");

        assertEq(actual, expected);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/DVNOptions.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { DVNOptions } from "../contracts/uln/libs/DVNOptions.sol";

import { OptionsUtil } from "./util/OptionsUtil.sol";

contract DVNOptionsTest is Test {
    using OptionsUtil for bytes;

    function test_getNumDVNs_failsOnDVNIdxGt254() public {
        bytes memory options = "";
        options = options.addDVNOption(255, 0, ""); // index 255

        vm.expectRevert(DVNOptions.DVN_InvalidDVNIdx.selector);
        DVNOptions.getNumDVNs(options);
    }

    function test_getNumDVNs_withOneDVNs() public {
        bytes memory options = "";
        options = options.addDVNPreCrimeOption(1); // dvn 1
        options = options.addDVNOption(1, type(uint8).max, abi.encodePacked(uint8(1))); // dvn 1, test a future option type
        options = options.addDVNPreCrimeOption(1); // dvn 1 overlap

        uint8 numDVNs = DVNOptions.getNumDVNs(options);
        assertEq(numDVNs, 1);
    }

    function test_getNumDVNs_withThreeDVNs() public {
        bytes memory options = "";
        options = options.addDVNPreCrimeOption(0); // dvn 0
        options = options.addDVNOption(2, type(uint8).max, abi.encodePacked(uint8(1))); // dvn 2, test a future option type
        options = options.addDVNPreCrimeOption(0); // dvn 0 overlap
        options = options.addDVNPreCrimeOption(1);

        uint8 numDVNs = DVNOptions.getNumDVNs(options);
        assertEq(numDVNs, 3);
    }

    function test_groupDVNOptionsByIdx_emptyOptions() public {
        bytes memory options;
        (bytes[] memory dvnOptions, uint8[] memory newDVNIndices) = DVNOptions.groupDVNOptionsByIdx(options);
        assertEq(dvnOptions.length, 0);
        assertEq(newDVNIndices.length, 0);
    }

    function test_groupDVNOptionsByIdx_onlyOneDVNs() public {
        bytes memory options = "";
        options = options.addDVNPreCrimeOption(5); // dvn 5

        (bytes[] memory dvnOptions, uint8[] memory newDVNIndices) = DVNOptions.groupDVNOptionsByIdx(options);
        assertEq(dvnOptions.length, 1);
        assertEq(dvnOptions[0], options);
        assertEq(newDVNIndices.length, 1);
        assertEq(newDVNIndices[0], 5);
    }

    function test_groupDVNOptionsByIdx() public {
        bytes memory options = "";
        options = options.addDVNPreCrimeOption(0); // dvn 0
        options = options.addDVNOption(2, type(uint8).max, abi.encodePacked(uint8(1))); // dvn 1, test a future option type
        options = options.addDVNPreCrimeOption(0); // dvn 0 overlap

        (bytes[] memory dvnOptions, uint8[] memory newDVNIndices) = DVNOptions.groupDVNOptionsByIdx(options);
        assertEq(newDVNIndices.length, 2);
        assertEq(newDVNIndices[0], 0);
        assertEq(newDVNIndices[1], 2);

        assertEq(dvnOptions.length, 2);
        assertEq(dvnOptions[0], hex"02000200010200020001"); // [02(dvn type), 0002(size), 00(dvn idx), 01(precrime type)] * 2
        assertEq(dvnOptions[1], hex"02000302ff01"); // 02(dvn type), 0003(size), 02(dvn idx), ff(future type), 01(future param)
    }

    function test_decodeDVNOptions() public {
        bytes memory options = "";
        options = options.addDVNPreCrimeOption(0); // dvn 0
        options = options.addDVNOption(0, type(uint8).max, abi.encodePacked(uint8(1))); // dvn 1, test a future option type
        options = options.addDVNPreCrimeOption(0); // dvn 0 overlap

        uint256 cursor;
        uint8 optionType;
        bytes memory option;

        // the first dvn option
        (optionType, option, cursor) = this.nextDVNOption(options, cursor);
        assertEq(optionType, 1);
        assertEq(option, bytes(""));
        assertEq(cursor, 5);

        // the second dvn option
        (optionType, option, cursor) = this.nextDVNOption(options, cursor);
        assertEq(optionType, type(uint8).max);
        assertEq(option, abi.encodePacked(uint8(1)));
        assertEq(cursor, 11);

        // the third dvn option
        (optionType, option, cursor) = this.nextDVNOption(options, cursor);
        assertEq(optionType, 1);
        assertEq(option, bytes(""));
        assertEq(cursor, 16);
        assertEq(cursor, options.length);
    }

    // a wrapper function for getting the calldata bytes by calling a external function
    function nextDVNOption(
        bytes calldata _options,
        uint256 _cursor
    ) external pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {
        return DVNOptions.nextDVNOption(_options, _cursor);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ExecutorFeeLib.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { IExecutorFeeLib } from "../contracts/interfaces/IExecutorFeeLib.sol";
import { IExecutor } from "../contracts/interfaces/IExecutor.sol";
import { ExecutorFeeLib } from "../contracts/ExecutorFeeLib.sol";

import { PriceFeedMock } from "./mocks/PriceFeedMock.sol";

contract ExecutorFeeLibTest is Test {
    ExecutorFeeLib executorFeeLib;
    PriceFeedMock priceFeed;
    IExecutor.DstConfig config;
    uint16 defaultMultiplierBps = 12000;
    uint32 dstEid = 30000;
    uint256 gasFee = 100;
    uint128 priceRatio = 1e10;
    uint128 nativePriceUSD = 2000e10;
    uint64 baseGas = 1;
    uint16 multiplierBps = 10000;
    uint128 floorMarginUSD = 3e10;
    uint128 nativeDropCap = 222000;
    uint256 calldataSize = 0;
    address oapp = address(0);
    uint128 dstGas = 200000;
    uint128 dstAmount = 5;
    uint16 index = 0;
    bytes32 nativeDropReceiver = bytes32("randomAddress");

    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;
    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;
    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;
    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;
    uint8 internal constant OPTION_TYPE_INVALID = 5;

    uint8 internal constant WORKER_ID = 1;

    function setUp() public {
        priceFeed = new PriceFeedMock();
        executorFeeLib = new ExecutorFeeLib(1e18);
        priceFeed.setup(gasFee, priceRatio, nativePriceUSD);
        config = IExecutor.DstConfig(baseGas, multiplierBps, floorMarginUSD, nativeDropCap, 0);
    }

    function test_getFee_noOptions_revert() public {
        vm.expectRevert(IExecutorFeeLib.Executor_NoOptions.selector);
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        executorFeeLib.getFee(params, config, "");
    }

    function test_getFee_invalidOption_revert() public {
        vm.expectRevert(
            abi.encodeWithSelector(IExecutorFeeLib.Executor_UnsupportedOptionType.selector, OPTION_TYPE_INVALID)
        );
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_INVALID, dstGas, dstAmount);
        executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
    }

    function test_getFee_lzReceiveOption_defaultMultiplier() public {
        config = IExecutor.DstConfig(baseGas, 0, 0, nativeDropCap, 0);
        uint256 dstFee = (dstAmount * priceRatio) / priceFeed.getPriceRatioDenominator();

        uint256 expected = ((gasFee + dstFee) * defaultMultiplierBps) / 10000;
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, dstAmount);
        uint256 actual = executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );

        assertEq(actual, expected);
    }

    function test_getFee_lzReceiveOption_specificMultiplier() public {
        config = IExecutor.DstConfig(baseGas, multiplierBps, 0, nativeDropCap, 0);
        uint256 dstFee = (dstAmount * priceRatio) / priceFeed.getPriceRatioDenominator();

        uint256 expected = ((gasFee + dstFee) * multiplierBps) / 10000;
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            multiplierBps
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, dstAmount);
        uint256 actual = executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );

        assertEq(actual, expected);
    }

    function test_getFee_lzComposeOption_floorMargin() public {
        uint256 floorMargin = (floorMarginUSD * 1e18) / priceFeed.nativeTokenPriceUSD();
        uint256 dstFee = (dstAmount * priceRatio) / priceFeed.getPriceRatioDenominator();

        uint256 expected = gasFee + dstFee + floorMargin;
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            multiplierBps
        );

        bytes memory lzComposeOption = abi.encodePacked(OPTION_TYPE_LZCOMPOSE, index, dstGas, dstAmount);
        bytes memory lzReceiveOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, uint128(0));
        bytes memory executorOption = abi.encodePacked(
            WORKER_ID,
            uint16(lzComposeOption.length),
            lzComposeOption,
            WORKER_ID,
            uint16(lzReceiveOption.length),
            lzReceiveOption
        );

        uint256 actual = executorFeeLib.getFee(params, config, executorOption);

        assertEq(actual, expected);
    }

    function test_getFee_nativeTokenPriceZero_specificMultiplier() public {
        priceFeed.setup(gasFee + gasFee, priceRatio, 0);
        uint256 dstFee = (dstAmount * priceRatio) / priceFeed.getPriceRatioDenominator();

        uint256 expected = ((gasFee + gasFee + dstFee) * multiplierBps) / 10000;
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            multiplierBps
        );

        bytes memory lzComposeOption = abi.encodePacked(OPTION_TYPE_LZCOMPOSE, index, dstGas, dstAmount);
        bytes memory lzReceiveOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, uint128(0));
        bytes memory executorOption = abi.encodePacked(
            WORKER_ID,
            uint16(lzComposeOption.length),
            lzComposeOption,
            WORKER_ID,
            uint16(lzReceiveOption.length),
            lzReceiveOption
        );

        uint256 actual = executorFeeLib.getFee(params, config, executorOption);

        assertEq(actual, expected);
    }

    function test_getFee_nativeDropAmountExceedsCap_revert() public {
        uint128 nativeDropAmount = nativeDropCap + 1;

        vm.expectRevert(
            abi.encodeWithSelector(
                IExecutorFeeLib.Executor_NativeAmountExceedsCap.selector,
                nativeDropAmount,
                nativeDropCap
            )
        );
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_NATIVE_DROP, nativeDropAmount, nativeDropReceiver);
        executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
    }

    function test_getFee_lzReceiveAndNativeDropOptions_floorMargin() public {
        uint128 nativeDropAmount = 1000;
        uint128 priceRatioDenominator = priceFeed.getPriceRatioDenominator();
        uint256 floorMargin = (floorMarginUSD * 1e18) / priceFeed.nativeTokenPriceUSD();
        uint256 nativeDropFee = (nativeDropAmount * priceRatio) / priceRatioDenominator;

        uint256 expected = gasFee + (dstAmount * priceRatio) / priceRatioDenominator + floorMargin + nativeDropFee;
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            dstEid,
            oapp,
            calldataSize,
            multiplierBps
        );

        bytes memory executorOption1 = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, dstAmount);
        bytes memory executorOption2 = abi.encodePacked(OPTION_TYPE_NATIVE_DROP, nativeDropAmount, nativeDropReceiver);
        uint256 actual = executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(
                WORKER_ID,
                uint16(executorOption1.length),
                executorOption1,
                WORKER_ID,
                uint16(executorOption2.length),
                executorOption2
            )
        );

        assertEq(actual, expected);
    }

    function test_getFee_UnsupportedOptionType_EndpointV1_LzReceiveWithValue_revert() public {
        // LzReceive with value
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            101,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        vm.expectRevert(
            abi.encodeWithSelector(IExecutorFeeLib.Executor_UnsupportedOptionType.selector, OPTION_TYPE_LZRECEIVE)
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, dstAmount);
        executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
    }

    function test_getFeeOnSend_UnsupportedOptionType_EndpointV1_LzReceiveWithValue_revert() public {
        // LzReceive with value
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            101,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        vm.expectRevert(
            abi.encodeWithSelector(IExecutorFeeLib.Executor_UnsupportedOptionType.selector, OPTION_TYPE_LZRECEIVE)
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, dstAmount);
        executorFeeLib.getFeeOnSend(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
    }

    function test_getFee_EndpointV1_LzReceive() public {
        // LzReceive
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            101,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        config = IExecutor.DstConfig(baseGas, defaultMultiplierBps, 0, 0, 0);

        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, uint128(0));
        uint256 actual = executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );

        uint256 expected = (gasFee * defaultMultiplierBps) / 10000;
        assertEq(actual, expected);
    }

    function test_getFeeOnSend_EndpoitnV1_LzReceive() public {
        // LzReceive
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            101,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        config = IExecutor.DstConfig(baseGas, defaultMultiplierBps, 0, 0, 0);

        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZRECEIVE, dstGas, uint128(0));
        uint256 actual = executorFeeLib.getFeeOnSend(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
        uint256 expected = (gasFee * defaultMultiplierBps) / 10000;
        assertEq(actual, expected);
    }

    function test_getFee_UnsupportedOptionType_EndpointV1_LzCompose_revert() public {
        // LzCompose
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            101,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        vm.expectRevert(
            abi.encodeWithSelector(IExecutorFeeLib.Executor_UnsupportedOptionType.selector, OPTION_TYPE_LZCOMPOSE)
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZCOMPOSE, index, dstGas, dstAmount);
        executorFeeLib.getFee(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
    }

    function test_getFeeOnSend_UnsupportedOptionType_EndpointV1_LzCompose_revert() public {
        // LzCompose
        IExecutorFeeLib.FeeParams memory params = IExecutorFeeLib.FeeParams(
            address(priceFeed),
            101,
            oapp,
            calldataSize,
            defaultMultiplierBps
        );
        vm.expectRevert(
            abi.encodeWithSelector(IExecutorFeeLib.Executor_UnsupportedOptionType.selector, OPTION_TYPE_LZCOMPOSE)
        );
        bytes memory executorOption = abi.encodePacked(OPTION_TYPE_LZCOMPOSE, index, dstGas, dstAmount);
        executorFeeLib.getFeeOnSend(
            params,
            config,
            abi.encodePacked(WORKER_ID, uint16(executorOption.length), executorOption)
        );
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/LzExecutor.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { ILayerZeroReceiver } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol";
import { ILayerZeroEndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { ExecutionState } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2View.sol";

import { ReceiveUln302 } from "../contracts/uln/uln302/ReceiveUln302.sol";
import { LzExecutor, LzReceiveParam, NativeDropParam } from "../contracts/uln/LzExecutor.sol";
import { VerificationState, ReceiveUln302View } from "../contracts/uln/uln302/ReceiveUln302View.sol";

import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { Constant } from "./util/Constant.sol";

contract LzExecutorTest is Test, ILayerZeroReceiver {
    Setup.FixtureV2 internal fixtureV2;
    ReceiveUln302 internal receiveUln302;
    ReceiveUln302View internal receiveUln302View;
    ILayerZeroEndpointV2 internal endpointV2;
    LzExecutor internal lzExecutor;
    uint32 internal EID;

    Origin origin;
    Packet packet;
    bytes packetHeader;
    bytes32 payloadHash;
    address receiver;

    address alice = address(0x1234);

    function setUp() public {
        fixtureV2 = Setup.loadFixtureV2(Constant.EID_ETHEREUM);
        endpointV2 = ILayerZeroEndpointV2(fixtureV2.endpointV2);
        receiveUln302 = fixtureV2.receiveUln302;
        receiveUln302View = new ReceiveUln302View();
        receiveUln302View.initialize(address(fixtureV2.endpointV2), address(receiveUln302));
        lzExecutor = new LzExecutor();
        lzExecutor.initialize(
            address(fixtureV2.receiveUln302),
            address(receiveUln302View),
            address(fixtureV2.endpointV2)
        );
        EID = fixtureV2.eid;

        // wire to self
        Setup.wireFixtureV2WithRemote(fixtureV2, fixtureV2.eid);

        // setup packet
        origin = Origin(EID, bytes32(uint256(uint160(address(this)))), 1);
        receiver = address(this);
        packet = PacketUtil.newPacket(1, EID, address(this), EID, receiver, abi.encodePacked("message"));
        origin = Origin(packet.srcEid, bytes32(uint256(uint160(packet.sender))), packet.nonce);
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        packetHeader = BytesLib.slice(encodedPacket, 0, 81);
        payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));

        origin = Origin(EID, bytes32(uint256(uint160(address(this)))), 1);
        receiver = address(this);
    }

    function test_CommitAndExecute_OnlyExecute() public {
        // verify
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(packetHeader, payloadHash, 1);
        receiveUln302.commitVerification(packetHeader, payloadHash);

        // verified
        assertEq(uint256(receiveUln302View.verifiable(packetHeader, payloadHash)), uint256(VerificationState.Verified));
        // executable
        assertEq(uint256(lzExecutor.executable(origin, receiver)), uint256(ExecutionState.Executable));

        // commit and execute
        NativeDropParam[] memory nativeDrop = new NativeDropParam[](0);
        lzExecutor.commitAndExecute(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 0),
            nativeDrop
        );

        // executed
        assertEq(uint256(lzExecutor.executable(origin, receiver)), uint256(ExecutionState.Executed));
    }

    function test_CommitAndExecute_NativeDropAndExecute() public {
        // verify
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(packetHeader, payloadHash, 1);
        receiveUln302.commitVerification(packetHeader, payloadHash);

        vm.deal(address(this), 1000);
        assertEq(alice.balance, 0); // alice had no funds
        // commit and execute
        NativeDropParam[] memory nativeDrop = new NativeDropParam[](1);
        nativeDrop[0] = NativeDropParam(alice, 1000);
        lzExecutor.commitAndExecute{ value: 1000 }(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 0),
            nativeDrop
        );
        assertEq(address(this).balance, 0);
        assertEq(address(lzExecutor).balance, 0);
        assertEq(alice.balance, 1000); // alice received funds

        // executed
        assertEq(uint256(lzExecutor.executable(origin, receiver)), uint256(ExecutionState.Executed));
    }

    function test_CommitAndExecute_ExecuteWithValue() public {
        // verify
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(packetHeader, payloadHash, 1);
        receiveUln302.commitVerification(packetHeader, payloadHash);

        vm.deal(address(this), 1000);
        // commit and execute
        NativeDropParam[] memory nativeDrop = new NativeDropParam[](0);
        lzExecutor.commitAndExecute{ value: 1000 }(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 1000),
            nativeDrop
        );
        assertEq(address(lzExecutor).balance, 0);
        assertEq(address(this).balance, 1000);

        // executed
        assertEq(uint256(lzExecutor.executable(origin, receiver)), uint256(ExecutionState.Executed));
    }

    function test_CommitAndExecute_VerifyAndExecute() public {
        // verifiable
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(packetHeader, payloadHash, 1);

        // verifiable
        assertEq(
            uint256(receiveUln302View.verifiable(packetHeader, payloadHash)),
            uint256(VerificationState.Verifiable)
        );
        // not executable
        assertEq(uint256(lzExecutor.executable(origin, receiver)), uint256(ExecutionState.NotExecutable));

        // commit and execute
        NativeDropParam[] memory nativeDrop = new NativeDropParam[](0);
        lzExecutor.commitAndExecute(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 0),
            nativeDrop
        );

        // verified
        assertEq(uint256(receiveUln302View.verifiable(packetHeader, payloadHash)), uint256(VerificationState.Verified));
        // executed
        assertEq(uint256(lzExecutor.executable(origin, receiver)), uint256(ExecutionState.Executed));
    }

    function test_CommitAndExecute_Revert_Verifying() public {
        assertEq(
            uint256(receiveUln302View.verifiable(packetHeader, payloadHash)),
            uint256(VerificationState.Verifying)
        );

        NativeDropParam[] memory nativeDrop = new NativeDropParam[](0);
        vm.expectRevert(LzExecutor.LzExecutor_Verifying.selector);
        lzExecutor.commitAndExecute(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 0),
            nativeDrop
        );
    }

    function test_CommitAndExecute_Revert_Executed() public {
        NativeDropParam[] memory nativeDrop = new NativeDropParam[](0);

        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(packetHeader, payloadHash, 1);
        lzExecutor.commitAndExecute(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 0),
            nativeDrop
        );

        // try again
        vm.expectRevert(LzExecutor.LzExecutor_Executed.selector);
        lzExecutor.commitAndExecute(
            address(receiveUln302),
            LzReceiveParam(origin, receiver, packet.guid, packet.message, "", 100000, 0),
            nativeDrop
        );
    }

    function test_WithdrawNative() public {
        vm.deal(address(lzExecutor), 1000);
        assertEq(address(lzExecutor).balance, 1000);
        assertEq(alice.balance, 0);

        lzExecutor.withdrawNative(address(0x1234), 1000);
        assertEq(address(lzExecutor).balance, 0);
        assertEq(alice.balance, 1000);
    }

    function test_WithdrawNative_Revert_OnlyOwner() public {
        vm.deal(address(lzExecutor), 1000);
        assertEq(address(lzExecutor).balance, 1000);

        vm.expectRevert("Ownable: caller is not the owner");
        vm.prank(alice);
        lzExecutor.withdrawNative(alice, 1000);
    }

    // implement ILayerZeroReceiver
    function allowInitializePath(Origin calldata) external pure override returns (bool) {
        return true;
    }

    function nextNonce(uint32, bytes32) external pure override returns (uint64) {
        return 0;
    }

    function lzReceive(Origin calldata, bytes32, bytes calldata, address, bytes calldata) external payable override {
        // do nothing
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/MultiSig.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { MultiSig } from "../contracts/uln/dvn/MultiSig.sol";

contract MultiSigTest is MultiSig, Test {
    constructor() MultiSig(_getSigners(), 2) {}

    function _getSigners() internal pure returns (address[] memory) {
        address[] memory signers = new address[](2);
        signers[0] = vm.addr(2); //0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF
        signers[1] = vm.addr(3); //0x6813Eb9362372EEF6200f3b1dbC3f819671cBA69
        return signers;
    }

    function test_setSigner() public {
        // only two signers
        assertEq(signers[vm.addr(2)], true);
        assertEq(signers[vm.addr(3)], true);
        assertEq(signers[vm.addr(4)], false);
        assertEq(signerSize, 2);

        // add a new signer
        address newSigner = vm.addr(4);
        bool active = true;
        _setSigner(newSigner, active);
        assertEq(signerSize, 3);

        // cant add a signer twice
        vm.expectRevert(abi.encodeWithSelector(MultiSig_StateAlreadySet.selector, newSigner, active));
        _setSigner(newSigner, active);

        // remove a signer
        _setSigner(newSigner, !active);
        assertEq(signerSize, 2);

        // signer size must be >= quorum after removing a signer
        vm.expectRevert(abi.encodeWithSelector(MultiSig_SignersSizeIsLessThanQuorum.selector, uint64(1), uint64(2)));
        _setSigner(vm.addr(3), false);
    }

    function test_setQuorum() public {
        assertEq(quorum, 2);

        // cant set quorum to 0
        vm.expectRevert(MultiSig_QuorumIsZero.selector);
        _setQuorum(0);

        // cant set quorum to more than signer size
        vm.expectRevert(abi.encodeWithSelector(MultiSig_SignersSizeIsLessThanQuorum.selector, uint64(2), uint64(3)));
        _setQuorum(3);

        // set quorum to 1
        _setQuorum(1);
        assertEq(quorum, 1);

        // set quorum to 2
        _setQuorum(2);
        assertEq(quorum, 2);
    }

    function test_verifySignatures() public {
        bytes32 hash = keccak256(bytes("message"));

        bytes memory sig1 = _generateSignature(2, hash); // sign with private key 2
        bytes memory sig2 = _generateSignature(3, hash); // sign with private key 3
        bytes memory sigNotInCommittee = _generateSignature(4, hash); // sign with private key 4

        // if only one signature is provided, it should fail for invalid size
        (bool verified, MultiSig.Errors error) = this.verifySignatures(hash, sig1);
        assertEq(verified, false);
        assertTrue(error == MultiSig.Errors.SignatureError);

        // if duplicate signatures are provided, it should fail
        bytes memory duplicateSignatures = bytes.concat(sig1, sig1);
        (verified, error) = this.verifySignatures(hash, duplicateSignatures);
        assertEq(verified, false);
        assertTrue(error == MultiSig.Errors.DuplicatedSigner);

        // if signatures are not in ascending order, it should fail
        bytes memory signaturesNotInOrder = bytes.concat(sig2, sig1);
        (verified, error) = this.verifySignatures(hash, signaturesNotInOrder);
        assertEq(verified, false);
        assertTrue(error == MultiSig.Errors.DuplicatedSigner);

        // if signatures are not from signers, it should fail
        bytes memory signaturesNotFromSigners = bytes.concat(sigNotInCommittee, sig1);
        (verified, error) = this.verifySignatures(hash, signaturesNotFromSigners);
        assertEq(verified, false);
        assertTrue(error == MultiSig.Errors.SignerNotInCommittee);

        // passes
        bytes memory signatures = bytes.concat(sig1, sig2);
        (verified, error) = this.verifySignatures(hash, signatures);
        assertEq(verified, true);
        assertTrue(error == MultiSig.Errors.NoError);
    }

    function _generateSignature(uint256 _privateKey, bytes32 _hash) internal pure returns (bytes memory signature) {
        bytes32 ethSignedMessageHash = _getEthSignedMessageHash(_hash);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(_privateKey, ethSignedMessageHash);
        signature = abi.encodePacked(r, s, v);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/PriceFeed.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { PriceFeed } from "../contracts/PriceFeed.sol";
import { ILayerZeroPriceFeed } from "../contracts/interfaces/ILayerZeroPriceFeed.sol";

contract PriceFeedTest is Test {
    PriceFeed internal priceFeed;
    uint128 constant PRICE_RATIO_DENOMINATOR = 1e20;

    function setUp() public {
        priceFeed = new PriceFeed();
        priceFeed.initialize(address(this));
    }

    function testFuzz_estimateFeeWithDefaultModel(uint128 aptosPriceUSD, uint128 ethPriceUSD) public {
        // uint128 aptosPriceUSD = 8 * 10000; // 8 USD per APTOS(multiple 10^4), 8 decimals, eid = 1
        // uint128 ethPriceUSD = 2000 * 10000; // 2000 USD per ETH, 18 decimals, eid = 2
        vm.assume(aptosPriceUSD > 0 && aptosPriceUSD < 10000 * 10000); // aptos price lest than 10000 USD
        vm.assume(ethPriceUSD > 0 && ethPriceUSD < 1000000 * 10000); // eth price lest than 1000000 USD
        uint8 aptosDecimals = 8;
        uint16 aptosEid = 1;
        uint8 ethDecimals = 18;
        uint16 ethEid = 2;
        // aptos to eth
        uint128 priceAptos = uint128(
            (PRICE_RATIO_DENOMINATOR * ethPriceUSD * 10 ** aptosDecimals) / (aptosPriceUSD * 10 ** ethDecimals)
        );
        ILayerZeroPriceFeed.UpdatePrice[] memory updatePrices = new ILayerZeroPriceFeed.UpdatePrice[](1);
        updatePrices[0] = ILayerZeroPriceFeed.UpdatePrice(
            ethEid,
            ILayerZeroPriceFeed.Price(priceAptos, 10 * 10 ** 9, 16) // gasPrice 10Gwei, gasPerByte 16
        );
        priceFeed.setPrice(updatePrices);
        (uint256 fee, , , ) = priceFeed.estimateFeeByEid(ethEid, 1000, 30000);
        // assertEq(fee, 11500000); // 0.115 Aptos

        // eth to aptos
        uint128 priceEth = uint128(
            (PRICE_RATIO_DENOMINATOR * aptosPriceUSD * 10 ** ethDecimals) / (ethPriceUSD * 10 ** aptosDecimals)
        );
        updatePrices[0] = ILayerZeroPriceFeed.UpdatePrice(
            aptosEid,
            ILayerZeroPriceFeed.Price(priceEth, 100, 16) // Gas Unit Price 0.000001 APT, gasPerByte 16
        );
        priceFeed.setPrice(updatePrices);
        (fee, , , ) = priceFeed.estimateFeeByEid(aptosEid, 1000, 100000); // 1000 bytes, 100000 gas
        // assertEq(fee, 464000000000000); // 0.000464 ETH
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ReceiveBaseE1.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";

import { ReceiveLibBaseE1 } from "../contracts/uln/uln301/ReceiveLibBaseE1.sol";

import { TokenMock } from "./mocks/TokenMock.sol";

contract ReceiveLibBaseE1Test is ReceiveLibBaseE1, Test {
    uint32 internal constant EID = 1;
    address internal constant ENDPOINT = address(0x11);

    constructor() ReceiveLibBaseE1(ENDPOINT, EID) {}

    function test_execute() public {
        // if the receiver is not the contract, just emit the event instead of calling the endpoint
        executors[address(0x22)][2] = address(0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38);
        vm.expectEmit(false, false, false, true, address(this));
        emit InvalidDst(2, bytes32(uint256(0x11)), address(0x22), 1, keccak256("message"));
        _execute(2, bytes32(uint256(0x11)), address(0x22), 1, "message", 0);

        // if the receiver is the contract, call the endpoint
        address receiver = address(new TokenMock()); // mock receiver is a contract
        executors[receiver][2] = address(0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38);
        addressSizes[2] = 20;
        vm.mockCall(ENDPOINT, abi.encodeWithSelector(ILayerZeroEndpoint.receivePayload.selector), "");
        _execute(2, bytes32(uint256(0x11)), receiver, 1, "message", 0);
    }

    function setConfig(uint16, address, uint256, bytes calldata) external {}

    function getConfig(uint16, address, uint256) external view returns (bytes memory) {}
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ReceiveUln301.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { IMessagingChannel } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol";
import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { EndpointV1 } from "./mocks/EndpointV1.sol";

import { Verification } from "../contracts/uln/ReceiveUlnBase.sol";
import { ReceiveUln301 } from "../contracts/uln/uln301/ReceiveUln301.sol";

import { Constant } from "./util/Constant.sol";
import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { OptionsUtil } from "./util/OptionsUtil.sol";

contract ReceiveUln301Test is Test {
    using OptionsUtil for bytes;
    Setup.FixtureV1 internal fixtureV1;
    ReceiveUln301 internal receiveUln301;
    EndpointV1 internal endpointV1;
    uint16 internal EID;

    // ULN301 sent event
    event PacketSent(bytes encodedPayload, bytes options, uint256 nativeFee, uint256 lzTokenFee);
    event PayloadVerified(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);
    event PacketDelivered(Origin origin, address receiver);
    event NativeFeeWithdrawn(address user, address receiver, uint256 amount);
    event PayloadStored(
        uint16 srcChainId,
        bytes srcAddress,
        address dstAddress,
        uint64 nonce,
        bytes payload,
        bytes reason
    );

    function setUp() public {
        vm.mockCall(address(0), abi.encodeWithSelector(IMessagingChannel.eid.selector), abi.encode(0));
        fixtureV1 = Setup.loadFixtureV1(Constant.EID_ETHEREUM);
        receiveUln301 = fixtureV1.receiveUln301;
        endpointV1 = fixtureV1.endpointV1;
        EID = fixtureV1.eid;
    }

    function test_verify() public {
        bytes32 payloadHash = keccak256("payload");
        vm.expectEmit(false, false, false, false, address(receiveUln301));
        emit PayloadVerified(address(this), "packetHeader", 1, payloadHash);
        receiveUln301.verify("packetHeader", payloadHash, 1);
        (bool submitted, uint64 confirmations_) = receiveUln301.hashLookup(
            keccak256("packetHeader"),
            payloadHash,
            address(this)
        );
        assertTrue(submitted);
        assertEq(confirmations_, 1);
    }

    function test_CommitVerification() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);

        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes memory payload = BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81);
        vm.prank(address(fixtureV1.dvn));
        receiveUln301.verify(header, keccak256(payload), 1);

        // commit verification
        vm.prank(address(fixtureV1.executor));
        Origin memory origin = Origin(0, bytes32(0), 0);
        vm.expectEmit(false, false, false, false, address(receiveUln301));
        emit PacketDelivered(origin, address(0));
        receiveUln301.commitVerification(encodedPacket, 10000000);
    }

    function test_Version() public {
        (uint64 major, uint64 minor, uint64 endpointVersion) = receiveUln301.version();
        assertEq(major, 3);
        assertEq(minor, 0);
        assertEq(endpointVersion, 1);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ReceiveUln301View.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { IMessagingChannel } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { EndpointV1 } from "./mocks/EndpointV1.sol";

import { ReceiveUln301 } from "../contracts/uln/uln301/ReceiveUln301.sol";
import { ReceiveUln301View, VerificationState } from "../contracts/uln/uln301/ReceiveUln301View.sol";

import { Constant } from "./util/Constant.sol";
import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";

contract ReceiveUln301ViewTest is Test {
    Setup.FixtureV1 internal fixtureV1;
    ReceiveUln301 internal receiveUln301;
    ReceiveUln301View internal receiveUln301View;
    EndpointV1 internal endpointV1;
    uint16 internal EID;

    function setUp() public {
        vm.mockCall(address(0), abi.encodeWithSelector(IMessagingChannel.eid.selector), abi.encode(0));
        fixtureV1 = Setup.loadFixtureV1(Constant.EID_ETHEREUM);
        receiveUln301 = fixtureV1.receiveUln301;
        endpointV1 = fixtureV1.endpointV1;
        EID = fixtureV1.eid;
        receiveUln301View = new ReceiveUln301View();
        receiveUln301View.initialize(address(endpointV1), EID, address(receiveUln301));
    }

    function test_Verifiable_Verifying() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));
        VerificationState status = receiveUln301View.verifiable(header, payloadHash);
        assertEq(uint256(status), uint256(VerificationState.Verifying));
    }

    function test_Verifiable_Verifiable() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);

        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes memory payload = BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81);
        vm.prank(address(fixtureV1.dvn));
        receiveUln301.verify(header, keccak256(payload), 1);

        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));
        VerificationState status = receiveUln301View.verifiable(header, payloadHash);
        // in 301, verifiable will return as Verified, because it is ready to be executed
        assertEq(uint256(status), uint256(VerificationState.Verified));
    }

    function test_Verifiable_Verified() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);

        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes memory payload = BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81);
        vm.prank(address(fixtureV1.dvn));
        receiveUln301.verify(header, keccak256(payload), 1);

        // verify
        vm.prank(address(fixtureV1.executor));
        receiveUln301.commitVerification(encodedPacket, 10000000);

        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));
        VerificationState status = receiveUln301View.verifiable(header, payloadHash);
        assertEq(uint256(status), uint256(VerificationState.Verified));
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ReceiveUln302.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { EndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { ReceiveUln302 } from "../contracts/uln/uln302/ReceiveUln302.sol";
import { ReceiveUlnBase, Verification } from "../contracts/uln/ReceiveUlnBase.sol";

import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { Constant } from "./util/Constant.sol";
import { OptionsUtil } from "./util/OptionsUtil.sol";

contract ReceiveUln302Test is Test {
    using OptionsUtil for bytes;
    Setup.FixtureV2 internal fixtureV2;
    ReceiveUln302 internal receiveUln302;
    EndpointV2 internal endpointV2;
    uint32 internal EID;

    event PayloadVerified(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);
    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);
    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);

    function setUp() public {
        fixtureV2 = Setup.loadFixtureV2(Constant.EID_ETHEREUM);
        receiveUln302 = fixtureV2.receiveUln302;
        endpointV2 = fixtureV2.endpointV2;
        EID = fixtureV2.eid;
    }

    function test_CommitVerification_Again() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));

        // dvn verify
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(header, payloadHash, 1);

        // commit verification
        receiveUln302.commitVerification(header, payloadHash);

        // dvn sign again
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(header, payloadHash, 1);

        // commit verification again
        vm.expectEmit(false, false, false, false, address(endpointV2));
        emit PacketVerified(Origin(0, bytes32(0), 0), address(0), bytes32(0));
        receiveUln302.commitVerification(header, payloadHash);
    }

    function test_CommitVerification() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);

        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes memory payload = BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81);
        vm.prank(address(fixtureV2.dvn));
        // dvn sign
        receiveUln302.verify(header, keccak256(payload), 1);

        // commit verification
        vm.expectEmit(false, false, false, false, address(endpointV2));
        emit PacketVerified(Origin(0, bytes32(0), 0), address(0), bytes32(0));
        receiveUln302.commitVerification(header, keccak256(payload));
    }

    function test_verify() public {
        bytes32 payloadHash = keccak256("payload");
        vm.expectEmit(false, false, false, false, address(receiveUln302));
        emit PayloadVerified(address(this), "packetHeader", 1, payloadHash);
        receiveUln302.verify("packetHeader", payloadHash, 1);
        (bool submitted, uint64 confirmations_) = receiveUln302.hashLookup(
            keccak256("packetHeader"),
            payloadHash,
            address(this)
        );
        assertTrue(submitted);
        assertEq(confirmations_, 1);
    }

    function test_Version() public {
        (uint64 major, uint64 minor, uint64 endpointVersion) = receiveUln302.version();
        assertEq(major, 3);
        assertEq(minor, 0);
        assertEq(endpointVersion, 2);
    }

    function allowInitializePath(Origin calldata) external pure returns (bool) {
        return true;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ReceiveUln302View.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { AddressCast } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol";
import { EndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { ReceiveUln302 } from "../contracts/uln/uln302/ReceiveUln302.sol";
import { ReceiveUln302View, VerificationState } from "../contracts/uln/uln302/ReceiveUln302View.sol";

import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { Constant } from "./util/Constant.sol";

contract ReceiveUln302ViewTest is Test {
    using AddressCast for address;

    Setup.FixtureV2 internal fixtureV2;
    ReceiveUln302 internal receiveUln302;
    ReceiveUln302View internal receiveUln302View;
    EndpointV2 internal endpointV2;
    uint32 internal EID;

    bool internal initializable = true;

    function setUp() public {
        fixtureV2 = Setup.loadFixtureV2(Constant.EID_ETHEREUM);
        receiveUln302 = fixtureV2.receiveUln302;
        endpointV2 = fixtureV2.endpointV2;
        EID = fixtureV2.eid;
        receiveUln302View = new ReceiveUln302View();
        receiveUln302View.initialize(address(endpointV2), address(receiveUln302));
    }

    function test_Verifiable_Verifying() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));
        VerificationState status = receiveUln302View.verifiable(header, payloadHash);
        assertEq(uint256(status), uint256(VerificationState.Verifying));
    }

    function test_Verifiable_Verified() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));

        // verify
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(header, payloadHash, 1);

        // endpoint verifiable
        Origin memory origin = Origin(EID, address(this).toBytes32(), 1);
        assertTrue(receiveUln302View.verifiable(origin, address(this), address(receiveUln302), payloadHash));
        assertEq(endpointV2.inboundPayloadHash(address(this), EID, address(this).toBytes32(), 1), bytes32(0));

        // commitVerification
        receiveUln302.commitVerification(header, payloadHash);

        // endpoint allow reverifying
        assertTrue(receiveUln302View.verifiable(origin, address(this), address(receiveUln302), payloadHash));
        assertEq(endpointV2.inboundPayloadHash(address(this), EID, address(this).toBytes32(), 1), payloadHash);

        VerificationState status = receiveUln302View.verifiable(header, payloadHash);
        assertEq(uint256(status), uint256(VerificationState.Verified));
    }

    function test_Verifiable_Verifiable() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));

        // dvn sign
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(header, payloadHash, 1);

        VerificationState status = receiveUln302View.verifiable(header, payloadHash);
        assertEq(uint256(status), uint256(VerificationState.Verifiable));
    }

    function test_Verifiable_NotInitializable() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        Packet memory packet = PacketUtil.newPacket(
            1,
            EID,
            address(this),
            EID,
            address(this),
            abi.encodePacked("message")
        );
        bytes memory encodedPacket = PacketV1Codec.encode(packet);
        bytes memory header = BytesLib.slice(encodedPacket, 0, 81);
        bytes32 payloadHash = keccak256(BytesLib.slice(encodedPacket, 81, encodedPacket.length - 81));

        // dvn sign
        vm.prank(address(fixtureV2.dvn));
        receiveUln302.verify(header, payloadHash, 1);

        // set app to not initializable
        initializable = false;

        VerificationState status = receiveUln302View.verifiable(header, payloadHash);
        assertEq(uint256(status), uint256(VerificationState.NotInitializable));
    }

    function allowInitializePath(Origin calldata) external view returns (bool) {
        return initializable;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/ReceiveUlnBase.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { UlnConfig } from "../contracts/uln/UlnBase.sol";
import { ReceiveUlnBase, Verification } from "../contracts/uln/ReceiveUlnBase.sol";

contract ReceiveUlnBaseTest is Test, ReceiveUlnBase {
    bytes32 internal headerHash = bytes32(uint256(0x1234));
    bytes32 internal payloadHash = bytes32(uint256(0x5678));
    address internal dvn1 = address(0x11);
    address internal dvn2 = address(0x22);
    address internal optionalDVN1 = address(0x33);
    address internal optionalDVN2 = address(0x44);
    address internal oapp = address(0x55);

    function test_verified(uint64 _confirmations) public {
        vm.assume(_confirmations > 0 && _confirmations < type(uint64).max);

        // mock the hashLookup state
        hashLookup[headerHash][payloadHash][dvn1] = Verification(true, _confirmations);
        assertEq(_verified(dvn1, headerHash, payloadHash, _confirmations - 1), true);

        hashLookup[headerHash][payloadHash][dvn1] = Verification(true, _confirmations);
        assertEq(_verified(dvn1, headerHash, payloadHash, _confirmations), true);

        hashLookup[headerHash][payloadHash][dvn1] = Verification(true, _confirmations);
        assertEq(_verified(dvn1, headerHash, payloadHash, _confirmations + 1), false);
    }

    function test_verifyConditionMet_onlyMustHaveDVNs() public {
        // 2 must-have dvns, 0 optional dvns
        uint64 confirmations = 10;
        UlnConfig memory config = UlnConfig(confirmations, 2, 0, 0, _newAddressArray(dvn1, dvn2), new address[](0));

        // only dvn1 submitted the hash, so the condition is not met
        hashLookup[headerHash][payloadHash][dvn1] = Verification(true, confirmations);
        assertFalse(_checkVerifiable(config, headerHash, payloadHash));

        // both dvns submitted the hash, so the condition is met
        hashLookup[headerHash][payloadHash][dvn2] = Verification(true, confirmations);
        assertTrue(_checkVerifiable(config, headerHash, payloadHash));
    }

    function test_verifyConditionMet_onlyOptionalDVNs() public {
        // 0 must-have dvns, 2 optional dvns, threshold is 1
        uint64 confirmations = 10;
        UlnConfig memory config = UlnConfig(
            confirmations,
            0,
            2,
            1,
            new address[](0),
            _newAddressArray(optionalDVN1, optionalDVN2)
        );

        // no optional dvn submitted the hash, so the condition is not met
        assertFalse(_checkVerifiable(config, headerHash, payloadHash));

        config = UlnConfig(confirmations, 0, 2, 1, new address[](0), _newAddressArray(optionalDVN1, optionalDVN2));

        // optionalDVN1 submitted the hash, so the condition is met
        hashLookup[headerHash][payloadHash][optionalDVN1] = Verification(true, confirmations);
        assertTrue(_checkVerifiable(config, headerHash, payloadHash));

        config = UlnConfig(confirmations, 0, 2, 1, new address[](0), _newAddressArray(optionalDVN1, optionalDVN2));

        // both optional dvns submitted the hash, so the condition is still met
        hashLookup[headerHash][payloadHash][optionalDVN1] = Verification(true, confirmations);
        hashLookup[headerHash][payloadHash][optionalDVN2] = Verification(true, confirmations);
        assertTrue(_checkVerifiable(config, headerHash, payloadHash));
    }

    function test_verifyConditionMet_mustHaveAndOptionalDVNs() public {
        // 2 must-have dvns, 2 optional dvns, threshold is 1
        uint64 confirmations = 10;
        UlnConfig memory config = UlnConfig(
            confirmations,
            2,
            2,
            1,
            _newAddressArray(dvn1, dvn2),
            _newAddressArray(optionalDVN1, optionalDVN2)
        );

        // only two dvns submitted the hash, so the condition is not met
        hashLookup[headerHash][payloadHash][dvn1] = Verification(true, confirmations);
        hashLookup[headerHash][payloadHash][dvn2] = Verification(true, confirmations);
        assertFalse(_checkVerifiable(config, headerHash, payloadHash));

        // optionalDVN1 submitted the hash, so the condition is met
        hashLookup[headerHash][payloadHash][optionalDVN1] = Verification(true, confirmations);
        assertTrue(_checkVerifiable(config, headerHash, payloadHash));
    }

    function _newAddressArray(address _addr1, address _addr2) internal pure returns (address[] memory) {
        address[] memory addrs = new address[](2);
        addrs[0] = _addr1;
        addrs[1] = _addr2;
        return addrs;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/SendLibBase.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import "forge-std/Test.sol";

import { SendLibBase, WorkerOptions, ExecutorConfig, SetDefaultExecutorConfigParam } from "../contracts/SendLibBase.sol";
import { ILayerZeroExecutor } from "../contracts/interfaces/ILayerZeroExecutor.sol";
import { ILayerZeroTreasury } from "../contracts/interfaces/ILayerZeroTreasury.sol";
import { Treasury } from "../contracts/Treasury.sol";

contract SendLibBaseTest is Test, SendLibBase {
    uint32 internal constant LOCAL_EID = 1;
    uint32 internal constant REMOTE_EID = 2;

    address private constant DEFAULT_CONFIG = address(0x0);
    address internal constant ENDPOINT = address(0x1234);
    address internal constant EXECUTOR = address(0x5678);
    uint256 internal constant OTHER_WORKER_FEE = 100;

    constructor() SendLibBase(ENDPOINT, LOCAL_EID, type(uint256).max, 0) {
        treasury = address(0xdead);
    }

    function test_setDefaultExecutorConfigs() public {
        vm.startPrank(owner());
        SetDefaultExecutorConfigParam[] memory params = new SetDefaultExecutorConfigParam[](1);

        // zero executor
        params[0] = SetDefaultExecutorConfigParam(1, ExecutorConfig(1, address(0)));
        vm.expectRevert(LZ_MessageLib_InvalidExecutor.selector);
        this.setDefaultExecutorConfigs(params);

        // zero message size
        params[0] = SetDefaultExecutorConfigParam(1, ExecutorConfig(0, EXECUTOR));
        vm.expectRevert(LZ_MessageLib_ZeroMessageSize.selector);
        this.setDefaultExecutorConfigs(params);

        // set default executor configs
        params[0] = SetDefaultExecutorConfigParam(1, ExecutorConfig(1, EXECUTOR));
        this.setDefaultExecutorConfigs(params);
        assertEq(executorConfigs[DEFAULT_CONFIG][1].maxMessageSize, 1);
        assertEq(executorConfigs[DEFAULT_CONFIG][1].executor, EXECUTOR);
    }

    function test_getExecutorConfig() public {
        // set default executor configs
        executorConfigs[DEFAULT_CONFIG][1] = ExecutorConfig(1, EXECUTOR);

        // get executor config
        ExecutorConfig memory config = this.getExecutorConfig(address(this), 1);
        assertEq(config.maxMessageSize, 1);
        assertEq(config.executor, EXECUTOR);

        // set custom executor
        executorConfigs[address(this)][1] = ExecutorConfig(2, address(1234));
        config = this.getExecutorConfig(address(this), 1);
        assertEq(config.maxMessageSize, 2);
        assertEq(config.executor, address(1234));
    }

    function test_assertMessageSize(uint256 _actual, uint256 _max) public {
        if (_actual > _max) {
            vm.expectRevert(abi.encodeWithSelector(LZ_MessageLib_InvalidMessageSize.selector, _actual, _max));
        }
        _assertMessageSize(_actual, _max);
    }

    function test_payExecutor(uint256 _fee) public {
        // mock executor.assignJob() and return the fee
        vm.mockCall(EXECUTOR, abi.encodeWithSelector(ILayerZeroExecutor.assignJob.selector), abi.encode(_fee));

        // check executor fee
        uint256 actualFee = _payExecutor(EXECUTOR, REMOTE_EID, address(this), 10, "");
        assertEq(actualFee, _fee);
        assertEq(fees[EXECUTOR], _fee); // bookkeeping
    }

    function test_payTreasury(uint256 _treasuryFee, uint256 _totalFee) public {
        vm.assume(_treasuryFee <= _totalFee);

        // mock treasury.getFee() and return the fee
        vm.mockCall(treasury, abi.encodeWithSelector(ILayerZeroTreasury.payFee.selector), abi.encode(_treasuryFee));

        // when pay treasury fee in native, nativeFee should be _treasuryFee and lzTokenFee should be 0
        (uint256 nativeFee, uint256 lzTokenFee) = _payTreasury(address(this), REMOTE_EID, _totalFee, false);
        assertEq(nativeFee, _treasuryFee);
        assertEq(lzTokenFee, 0);
        assertEq(fees[treasury], _treasuryFee); // bookkeeping
    }

    function test_quoteTreasury(uint256 _treasuryFee, uint256 _totalFee) public {
        // mock treasury.getFee() and return the fee
        vm.mockCall(treasury, abi.encodeWithSelector(ILayerZeroTreasury.getFee.selector), abi.encode(_treasuryFee));

        // pay treasury fee in lz token, the nativeFee should be 0, and lzTokenFee should be _treasuryFee
        (uint256 nativeFee, uint256 lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, _totalFee, true);
        assertEq(nativeFee, 0);
        assertEq(lzTokenFee, _treasuryFee);

        // when pay treasury fee in native, lzTokenFee should be 0
        // but the nativeFee should be the min of _treasuryFee and _totalFee
        (nativeFee, lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, _totalFee, false);
        uint256 expectedNativeFee = _treasuryFee < _totalFee ? _treasuryFee : _totalFee;
        assertEq(nativeFee, expectedNativeFee);
        assertEq(lzTokenFee, 0);
    }

    function test_quoteTreasuryRevert() public {
        // mock treasury.getFee() but revert
        vm.mockCallRevert(treasury, abi.encodeWithSelector(ILayerZeroTreasury.getFee.selector), "");

        // when fail to get treasury fee, quoteTreasuryFee should return (0, 0) instead of revert
        (uint256 nativeFee, uint256 lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, 10, false);
        assertEq(nativeFee, 0);
        assertEq(lzTokenFee, 0);
    }

    function test_quoteTreasuryEmptyReturn() public {
        // mock treasury.getFee() but no return value
        vm.mockCall(treasury, abi.encodeWithSelector(ILayerZeroTreasury.getFee.selector), "");

        (uint256 nativeFee, uint256 lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, 10, false);
        assertEq(nativeFee, 0);
        assertEq(lzTokenFee, 0);
    }

    function test_quoteTreasuryEOA() public {
        treasury = address(0x1234);

        (uint256 nativeFee, uint256 lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, 10, false);
        assertEq(nativeFee, 0);
        assertEq(lzTokenFee, 0);
    }

    //    function test_quoteTreasurySelfDestructed() public {
    //        Treasury treasuryContract = new Treasury();
    //        treasuryContract.setNativeFeeBP(1000); // 1/10
    //        treasury = address(treasuryContract);
    //
    //        (uint256 nativeFee, uint256 lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, 10, false);
    //        assertEq(nativeFee, 1);
    //        assertEq(lzTokenFee, 0);
    //
    //        // destroy treasury contract
    //        destroyAccount(address(treasuryContract), address(this));
    //
    //        (nativeFee, lzTokenFee) = _quoteTreasury(address(this), REMOTE_EID, 10, false);
    //        assertEq(nativeFee, 0);
    //        assertEq(lzTokenFee, 0);
    //    }

    function test_quote(uint256 _executorFee, uint256 _treasuryFee) public {
        vm.assume(_executorFee <= 10e10 && _treasuryFee <= 10e10 && _treasuryFee <= OTHER_WORKER_FEE + _executorFee);
        executorConfigs[DEFAULT_CONFIG][REMOTE_EID] = ExecutorConfig(1000, EXECUTOR);

        // mock executor.getFee()
        vm.mockCall(EXECUTOR, abi.encodeWithSelector(ILayerZeroExecutor.getFee.selector), abi.encode(_executorFee));

        // mock treasury.getFee()
        vm.mockCall(treasury, abi.encodeWithSelector(ILayerZeroTreasury.getFee.selector), abi.encode(_treasuryFee));

        (uint256 nativeFee, uint256 lzTokenFee) = this.quote(address(this), REMOTE_EID, 10, false, bytes("abc"));
        assertEq(nativeFee, OTHER_WORKER_FEE + _executorFee + _treasuryFee);
        assertEq(lzTokenFee, 0);
    }

    function test_debitFee(address _to, uint256 _amount, uint256 _maxAmount) public {
        vm.assume(_to != address(0x0));

        // mock that _to has _maxAmount fee
        fees[msg.sender] = _maxAmount;

        // if _amount > _maxAmount, assertAndDebitAmount should revert
        if (_amount > _maxAmount) {
            vm.expectRevert(abi.encodeWithSelector(LZ_MessageLib_InvalidAmount.selector, _amount, _maxAmount));
            _debitFee(_amount);
        } else {
            _debitFee(_amount);
            assertEq(fees[msg.sender], _maxAmount - _amount);
        }
    }

    // =================== override all abstract functions but do nothing ===================

    function _quoteVerifier(address, uint32, WorkerOptions[] memory) internal pure override returns (uint256) {
        return (OTHER_WORKER_FEE);
    }

    function _splitOptions(bytes calldata) internal pure override returns (bytes memory, WorkerOptions[] memory) {}

    function quote(
        address _sender,
        uint32 _dstEid,
        uint256 _msgSize,
        bool _payInLzToken,
        bytes calldata _options
    ) external view returns (uint256, uint256) {
        return _quote(_sender, _dstEid, _msgSize, _payInLzToken, _options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/SendLibBaseE1.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";

import { WorkerOptions, ExecutorConfig } from "../contracts/SendLibBase.sol";
import { SendLibBaseE1 } from "../contracts/uln/uln301/SendLibBaseE1.sol";
import { INonceContract } from "../contracts/uln/uln301/interfaces/INonceContract.sol";
import { ILayerZeroExecutor } from "../contracts/interfaces/ILayerZeroExecutor.sol";

contract SendLibBaseE1Test is SendLibBaseE1, Test {
    uint32 internal constant EID = 1;
    address internal constant ENDPOINT = address(0x11);
    address internal constant NONCE_CONTRACT = address(0x22);
    address internal constant TREASURY_FEE_HANDLER = address(0x33);
    address internal constant EXECUTOR = address(0x44);

    constructor() SendLibBaseE1(ENDPOINT, type(uint256).max, 0, NONCE_CONTRACT, EID, TREASURY_FEE_HANDLER) {}

    function test_withdrawFee() public {
        // mock alice has 1000 native fee
        address alice = address(0xabcd);
        fees[alice] = 1000;
        vm.deal(address(this), 1000);

        // withdraw 100 native fee
        vm.prank(alice);
        address receiver = address(0x1234);
        this.withdrawFee(receiver, 100);
        assertEq(fees[alice], 900);
        assertEq(receiver.balance, 100);
    }

    function test_assertPath(address _sender, bytes calldata _receiver) public {
        bytes memory path = abi.encodePacked(_receiver, _sender);
        this.assertPath(_sender, path, _receiver.length);

        // revert if address is wrong
        vm.expectRevert(LZ_MessageLib_InvalidPath.selector);
        this.assertPath(_sender, path, _receiver.length + 1);
    }

    function test_send() public {
        address sender = address(0xaa);
        uint16 dstEid = 2;
        address receiver = address(0xbb);
        bytes memory path = abi.encodePacked(receiver, sender);
        bytes memory message = "message";
        addressSizes[dstEid] = 20;
        executorConfigs[address(0x0)][dstEid] = ExecutorConfig(20, EXECUTOR);

        // mock calls
        vm.startPrank(ENDPOINT);
        vm.mockCall(NONCE_CONTRACT, abi.encodeWithSelector(INonceContract.increment.selector), abi.encode(uint64(1)));
        vm.mockCall(EXECUTOR, abi.encodeWithSelector(ILayerZeroExecutor.assignJob.selector), abi.encode(200));

        // the message fee is 300 (100 + 200)
        vm.deal(ENDPOINT, 300);
        vm.expectEmit(false, false, false, true, address(this));
        emit PacketSent("packet", "", 300, 0);
        this.send{ value: 300 }(sender, 0, dstEid, path, message, payable(sender), sender, "");

        // if send with 400 fee, 100 will be refunded to sender
        vm.deal(ENDPOINT, 400);
        this.send{ value: 400 }(sender, 0, dstEid, path, message, payable(sender), sender, "");
        assertEq(sender.balance, 100);
    }

    function _payVerifier(
        Packet memory,
        WorkerOptions[] memory
    ) internal pure override returns (uint256, bytes memory) {
        return (100, "packet");
    }

    function _quoteVerifier(address, uint32, WorkerOptions[] memory) internal view override returns (uint256) {}

    function version() external view returns (uint64, uint8, uint8) {}

    function _splitOptions(bytes calldata) internal view override returns (bytes memory, WorkerOptions[] memory) {}

    function setConfig(uint16, address, uint256, bytes calldata) external {}

    function getConfig(uint16, address, uint256) external view returns (bytes memory) {}

    function getDefaultConfig(uint32 _eid, uint32 _configType) external view returns (bytes memory) {}

    function assertPath(address _sender, bytes calldata _path, uint256 remoteAddressSize) external pure {
        _assertPath(_sender, _path, remoteAddressSize);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/SendLibBaseE2.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { IMessageLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol";
import { IMessagingChannel } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol";
import { ILayerZeroEndpointV2, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";

import { SendLibBaseE2 } from "../contracts/SendLibBaseE2.sol";
import { WorkerOptions } from "../contracts/SendLibBase.sol";

import { TokenMock } from "./mocks/TokenMock.sol";

contract SendLibBaseE2Test is Test {
    uint32 internal eid = 1;
    address internal endpoint = address(0x1234);
    SendLibBaseE2Mock internal msglib;
    SendLibBaseE2Mock internal msglibAlt;

    address internal treasury = address(0x5678);
    TokenMock internal lzToken = new TokenMock();
    TokenMock internal altToken = new TokenMock();
    address internal alice = address(0x1111);

    function setUp() public {
        // mock endpoint
        vm.mockCall(endpoint, abi.encodeWithSelector(IMessagingChannel.eid.selector), abi.encode(eid));
        vm.mockCall(
            endpoint,
            abi.encodeWithSelector(ILayerZeroEndpointV2.nativeToken.selector),
            abi.encode(address(0))
        );
        msglib = new SendLibBaseE2Mock(endpoint);
        msglib.setTreasury(treasury);

        vm.mockCall(
            endpoint,
            abi.encodeWithSelector(ILayerZeroEndpointV2.nativeToken.selector),
            abi.encode(address(altToken))
        );
        msglibAlt = new SendLibBaseE2Mock(endpoint);
        msglibAlt.setTreasury(treasury);

        // mock alice has 1000 altToken fee and 1000 native coin fee
        vm.deal(address(msglib), 1000); // 1000 native coin
        msglib.mockFee(alice, 1000); // 1000 altToken

        altToken.transfer(address(msglibAlt), 1000);
        msglibAlt.mockFee(alice, 1000); // 1000 altToken

        // treasury fee 1000
        lzToken.transfer(address(msglib), 1000);
    }

    function test_supportsInterface() public {
        assertEq(msglib.supportsInterface(type(IMessageLib).interfaceId), true);
        assertEq(msglib.supportsInterface(type(IERC165).interfaceId), true);
        assertEq(msglib.supportsInterface(type(IMessagingChannel).interfaceId), false);
    }

    function test_withdrawFee_nativeFee() public {
        address receiver = address(0x2222);

        // withdraw 100 native coin to receiver
        vm.prank(alice);

        // mock endpoint
        vm.mockCall(
            endpoint,
            abi.encodeWithSelector(ILayerZeroEndpointV2.nativeToken.selector),
            abi.encode(address(0))
        );
        msglib.withdrawFee(receiver, 100);
        assertEq(address(msglib).balance, 900);
        assertEq(receiver.balance, 100);
        assertEq(msglib.fees(alice), 900);
    }

    function test_withdrawFee_altTokenFee() public {
        address receiver = address(0x2222);

        // withdraw 100 native coin to receiver
        vm.prank(alice);
        msglibAlt.withdrawFee(receiver, 100);
        assertEq(msglibAlt.fees(alice), 900);
        assertEq(altToken.balanceOf(address(msglibAlt)), 900);
        assertEq(altToken.balanceOf(receiver), 100);
    }

    function test_withdrawLzTokenFee() public {
        address receiver = address(0x2222);

        // mock endpoint has altToken
        vm.mockCall(
            endpoint,
            abi.encodeWithSelector(ILayerZeroEndpointV2.nativeToken.selector),
            abi.encode(address(altToken))
        );

        // treasury cannot withdraw altToken
        vm.startPrank(treasury);
        vm.expectRevert(SendLibBaseE2.LZ_MessageLib_CannotWithdrawAltToken.selector);
        msglib.withdrawLzTokenFee(address(altToken), receiver, 100);

        // treasury can withdraw lzToken
        msglib.withdrawLzTokenFee(address(lzToken), receiver, 100);
        assertEq(lzToken.balanceOf(address(msglib)), 900);
        assertEq(lzToken.balanceOf(receiver), 100);
    }
}

contract SendLibBaseE2Mock is SendLibBaseE2 {
    constructor(address _endpoint) SendLibBaseE2(_endpoint, type(uint256).max, 0) {}

    function setConfig(address, SetConfigParam[] calldata) external {}

    function getConfig(uint32, address, uint32) external view returns (bytes memory) {}

    function getDefaultConfig(uint32 _eid, uint32 _configType) external view returns (bytes memory) {}

    function isSupportedEid(uint32 _eid) external view returns (bool) {}

    function _quoteVerifier(address, uint32, WorkerOptions[] memory) internal view override returns (uint256) {}

    function version() external view returns (uint64, uint8, uint8) {}

    function _splitOptions(bytes calldata) internal view override returns (bytes memory, WorkerOptions[] memory) {}

    function _payVerifier(Packet calldata, WorkerOptions[] memory) internal override returns (uint256, bytes memory) {}

    function mockFee(address _owner, uint256 _fee) external {
        fees[_owner] = _fee;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/SendUln301.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { IMessagingChannel } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol";
import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";
import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { EndpointV1 } from "./mocks/EndpointV1.sol";

import { UlnConfig } from "../contracts/uln/UlnBase.sol";
import { SendUln301 } from "../contracts/uln/uln301/SendUln301.sol";

import { Constant } from "./util/Constant.sol";
import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { OptionsUtil } from "./util/OptionsUtil.sol";

contract SendUln301Test is Test {
    using OptionsUtil for bytes;
    Setup.FixtureV1 internal fixtureV1;
    SendUln301 internal sendUln301;
    EndpointV1 internal endpointV1;
    uint16 internal EID;

    // ULN301 sent event
    event PacketSent(bytes encodedPayload, bytes options, uint256 nativeFee, uint256 lzTokenFee);
    event PayloadSigned(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);
    event PacketDelivered(Origin origin, address receiver);
    event NativeFeeWithdrawn(address user, address receiver, uint256 amount);
    event PayloadStored(
        uint16 srcChainId,
        bytes srcAddress,
        address dstAddress,
        uint64 nonce,
        bytes payload,
        bytes reason
    );

    function setUp() public {
        vm.mockCall(address(0), abi.encodeWithSelector(IMessagingChannel.eid.selector), abi.encode(0));
        fixtureV1 = Setup.loadFixtureV1(Constant.EID_ETHEREUM);
        sendUln301 = fixtureV1.sendUln301;
        endpointV1 = fixtureV1.endpointV1;
        EID = fixtureV1.eid;
    }

    function test_Send() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);

        // bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter
        vm.expectEmit(false, false, false, false, address(sendUln301));
        emit PacketSent("payload", "options", 0, 0);
        bytes memory option = OptionsUtil.newOptions().addExecutorLzReceiveOption(200000, 0);
        endpointV1.send(
            EID,
            abi.encodePacked(address(0x1), address(this)),
            "payload",
            payable(address(0x1)),
            address(0),
            option
        );
    }

    function test_EstimateFees() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);

        vm.txGasPrice(10);
        // mock treasury fee
        uint256 mockTreasuryFee = 1;
        vm.mockCall(
            address(fixtureV1.treasury),
            abi.encodeWithSelector(fixtureV1.treasury.getFee.selector),
            abi.encode(mockTreasuryFee)
        );
        // mock executor fee
        uint256 mockExecutorFee = 2;
        vm.mockCall(
            address(fixtureV1.executor),
            abi.encodeWithSelector(fixtureV1.executor.getFee.selector),
            abi.encode(mockExecutorFee)
        );

        // mock dvns fee
        uint256 mockDVNFee = 3;
        uint256 mockOptionalDVNFee = 4;

        UlnConfig memory ulnConfig;
        ulnConfig = UlnConfig(1, 1, 1, 1, new address[](1), new address[](1));
        ulnConfig.requiredDVNs[0] = address(0x1);
        ulnConfig.optionalDVNs[0] = address(0x2);

        vm.prank(address(endpointV1));
        sendUln301.setConfig(EID, address(this), Constant.CONFIG_TYPE_ULN, abi.encode(ulnConfig));

        vm.mockCall(
            address(0x1),
            abi.encodeWithSignature("getFee(uint32,uint64,address,bytes)"),
            abi.encode(mockDVNFee)
        );
        vm.mockCall(
            address(0x2),
            abi.encodeWithSignature("getFee(uint32,uint64,address,bytes)"),
            abi.encode(mockOptionalDVNFee)
        );

        // quote with nativeFee for treasury
        uint256 nativeFee;
        bytes memory option = OptionsUtil.newOptions().addExecutorLzReceiveOption(200000, 0);
        (nativeFee, ) = sendUln301.estimateFees(EID, address(this), "message", false, option);
        assertEq(nativeFee, mockTreasuryFee + mockExecutorFee + mockDVNFee + mockOptionalDVNFee);

        // quote with lzTokenFee for treasury
        uint256 lzTokenFee;
        (nativeFee, lzTokenFee) = sendUln301.estimateFees(EID, address(this), "message", true, option);
        assertEq(nativeFee, mockExecutorFee + mockDVNFee + mockOptionalDVNFee);
        assertEq(lzTokenFee, mockTreasuryFee);
    }

    function test_WithdrawFee() public {
        // wire to itself
        Setup.wireFixtureV1WithRemote(fixtureV1, EID);
        vm.txGasPrice(10);
        // mock treasury fee
        uint256 mockTreasuryFee = 1;
        vm.mockCall(
            address(fixtureV1.treasury),
            abi.encodeWithSelector(fixtureV1.treasury.payFee.selector),
            abi.encode(mockTreasuryFee)
        );
        bytes memory option = OptionsUtil.newOptions().addExecutorLzReceiveOption(200000, 0);
        endpointV1.send{ value: mockTreasuryFee }(
            EID,
            abi.encodePacked(address(0x1), address(this)),
            "payload",
            payable(address(0x1)),
            address(0),
            option
        );

        vm.expectEmit(false, false, false, true, address(sendUln301));
        emit NativeFeeWithdrawn(address(fixtureV1.treasury), address(0x1), mockTreasuryFee);
        vm.prank(address(fixtureV1.treasury));
        sendUln301.withdrawFee(address(0x1), mockTreasuryFee);
        assertEq(address(0x1).balance, mockTreasuryFee);
    }

    function test_Version() public {
        (uint64 major, uint64 minor, uint64 endpointVersion) = sendUln301.version();
        assertEq(major, 3);
        assertEq(minor, 0);
        assertEq(endpointVersion, 1);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/SendUln302.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { EndpointV2 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol";
import { MessagingParams, MessagingFee, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

import { UlnConfig } from "../contracts/uln/UlnBase.sol";
import { SendUln302 } from "../contracts/uln/uln302/SendUln302.sol";

import { Setup } from "./util/Setup.sol";
import { PacketUtil } from "./util/Packet.sol";
import { Constant } from "./util/Constant.sol";
import { OptionsUtil } from "./util/OptionsUtil.sol";

contract SendUln302Test is Test {
    using OptionsUtil for bytes;
    Setup.FixtureV2 internal fixtureV2;
    SendUln302 internal sendUln302;
    EndpointV2 internal endpointV2;
    uint32 internal EID;

    event PayloadSigned(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);
    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);
    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);

    function setUp() public {
        fixtureV2 = Setup.loadFixtureV2(Constant.EID_ETHEREUM);
        sendUln302 = fixtureV2.sendUln302;
        endpointV2 = fixtureV2.endpointV2;
        EID = fixtureV2.eid;
    }

    function test_Send() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        // bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter
        vm.expectEmit(false, false, false, false, address(endpointV2));
        emit PacketSent("payload", "options", address(0));
        bytes memory option = OptionsUtil.newOptions().addExecutorLzReceiveOption(200000, 0);
        MessagingParams memory messagingParams = MessagingParams(EID, bytes32(uint256(1)), "message", option, false);
        endpointV2.send(messagingParams, payable(address(this)));
    }

    function test_Quote() public {
        // wire to itself
        Setup.wireFixtureV2WithRemote(fixtureV2, EID);

        vm.txGasPrice(10);
        // mock treasury fee
        uint256 mockTreasuryFee = 1;
        vm.mockCall(
            address(fixtureV2.treasury),
            abi.encodeWithSelector(fixtureV2.treasury.getFee.selector),
            abi.encode(mockTreasuryFee)
        );
        // mock executor fee
        uint256 mockExecutorFee = 2;
        vm.mockCall(
            address(fixtureV2.executor),
            abi.encodeWithSelector(fixtureV2.executor.getFee.selector),
            abi.encode(mockExecutorFee)
        );

        // mock dvns fee
        uint256 mockDVNFee = 3;
        uint256 mockOptionalDVNFee = 4;

        UlnConfig memory ulnConfig;
        ulnConfig = UlnConfig(1, 1, 1, 1, new address[](1), new address[](1));
        ulnConfig.requiredDVNs[0] = address(0x1);
        ulnConfig.optionalDVNs[0] = address(0x2);

        SetConfigParam[] memory cfParams = new SetConfigParam[](1);
        cfParams[0] = SetConfigParam(EID, Constant.CONFIG_TYPE_ULN, abi.encode(ulnConfig));

        vm.prank(address(endpointV2));
        sendUln302.setConfig(address(this), cfParams);

        vm.mockCall(
            address(0x1),
            abi.encodeWithSignature("getFee(uint32,uint64,address,bytes)"),
            abi.encode(mockDVNFee)
        );
        vm.mockCall(
            address(0x2),
            abi.encodeWithSignature("getFee(uint32,uint64,address,bytes)"),
            abi.encode(mockOptionalDVNFee)
        );

        Packet memory p = PacketUtil.newPacket(1, EID, address(this), EID, address(this), "");
        MessagingFee memory msgFee = sendUln302.quote(
            p,
            OptionsUtil.newOptions().addExecutorLzReceiveOption(200000, 0),
            false
        );
        assertEq(msgFee.nativeFee, mockTreasuryFee + mockExecutorFee + mockDVNFee + mockOptionalDVNFee);
    }

    function test_Version() public {
        (uint64 major, uint64 minor, uint64 endpointVersion) = sendUln302.version();
        assertEq(major, 3);
        assertEq(minor, 0);
        assertEq(endpointVersion, 2);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/SendUlnBase.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { UlnConfig } from "../contracts/uln/UlnBase.sol";
import { SendUlnBase } from "../contracts/uln/SendUlnBase.sol";
import { ILayerZeroDVN } from "../contracts/uln/interfaces/ILayerZeroDVN.sol";

import { OptionsUtil } from "./util/OptionsUtil.sol";

contract SendUlnBaseTest is Test, SendUlnBase {
    using OptionsUtil for bytes;

    bytes32 internal headerHash = bytes32(uint256(0x1234));
    bytes32 internal payloadHash = bytes32(uint256(0x5678));
    address internal dvn1 = address(0x11);
    address internal dvn2 = address(0x22);
    address internal optionalDVN1 = address(0x33);
    address internal optionalDVN2 = address(0x44);
    address internal oapp = address(0x55);

    mapping(address => uint256) internal fees;

    function test_getFees() public {
        // 2 must-have dvns, 2 optional dvns
        uint64 confirmations = 10;
        UlnConfig memory config = UlnConfig(
            confirmations,
            2,
            2,
            1,
            _newAddressArray(dvn1, dvn2),
            _newAddressArray(optionalDVN1, optionalDVN2)
        );

        // mock the dvn fees, when the dvn has options, its fee is 200, otherwise 100
        // only dvn2 and optionalDVN1 have options
        bytes memory options = bytes("options");
        uint256 fee = 100;
        vm.mockCall(
            dvn1,
            abi.encodeWithSelector(ILayerZeroDVN.getFee.selector, 1, confirmations, address(this), ""),
            abi.encode(fee)
        );
        vm.mockCall(
            dvn2,
            abi.encodeWithSelector(ILayerZeroDVN.getFee.selector, 1, confirmations, address(this), options),
            abi.encode(fee * 2)
        );
        vm.mockCall(
            optionalDVN1,
            abi.encodeWithSelector(ILayerZeroDVN.getFee.selector, 1, confirmations, address(this), options),
            abi.encode(fee * 2)
        );
        vm.mockCall(
            optionalDVN2,
            abi.encodeWithSelector(ILayerZeroDVN.getFee.selector, 1, confirmations, address(this), ""),
            abi.encode(fee)
        );

        // mock the options array and dvn ids array
        bytes[] memory optionsArray = new bytes[](2);
        optionsArray[0] = options;
        optionsArray[1] = options;
        uint8[] memory dvnIds = new uint8[](2);
        dvnIds[0] = 1;
        dvnIds[1] = 2;

        uint256 totalFee = _getFees(config, 1, address(this), optionsArray, dvnIds);
        assertEq(totalFee, fee * 6); // 100 + 200 + 200 + 100
    }

    function test_assignJobToDVNs() public {
        // 2 must-have dvns, 2 optional dvns
        uint64 confirmations = 10;
        UlnConfig memory config = UlnConfig(
            confirmations,
            2,
            2,
            1,
            _newAddressArray(dvn1, dvn2),
            _newAddressArray(optionalDVN1, optionalDVN2)
        );

        ILayerZeroDVN.AssignJobParam memory param = ILayerZeroDVN.AssignJobParam(
            1,
            bytes("packetHeader"),
            payloadHash,
            confirmations,
            address(this)
        );

        // mock the dvn fees, dvn1's fee is 100, dvn2's fee is 200,
        // optionalDVN1's fee is 300, optionalDVN2's fee is 400
        // only dvn2 and optionalDVN1 have options
        vm.mockCall(dvn1, abi.encodeWithSelector(ILayerZeroDVN.assignJob.selector), abi.encode(100));
        vm.mockCall(
            dvn2,
            abi.encodeWithSelector(ILayerZeroDVN.assignJob.selector, param, OptionsUtil.addDVNPreCrimeOption("", 1)),
            abi.encode(200)
        );
        vm.mockCall(
            optionalDVN1,
            abi.encodeWithSelector(ILayerZeroDVN.assignJob.selector, param, OptionsUtil.addDVNPreCrimeOption("", 2)),
            abi.encode(300)
        );
        vm.mockCall(optionalDVN2, abi.encodeWithSelector(ILayerZeroDVN.assignJob.selector), abi.encode(400));

        bytes memory options = "";
        options = options.addDVNPreCrimeOption(1); // dvn2
        options = options.addDVNPreCrimeOption(2); // optionalDVN1
        (uint256 totalFee, uint256[] memory dvnFees) = _assignJobs(fees, config, param, options);
        assertEq(totalFee, 1000); // 100 + 200 + 300 + 400
        assertEq(dvnFees[0], 100);
        assertEq(dvnFees[1], 200);
        assertEq(dvnFees[2], 300);
        assertEq(dvnFees[3], 400);
        assertEq(fees[dvn1], 100);
        assertEq(fees[dvn2], 200);
        assertEq(fees[optionalDVN1], 300);
        assertEq(fees[optionalDVN2], 400);
    }

    function _newAddressArray(address _addr1, address _addr2) internal pure returns (address[] memory) {
        address[] memory addrs = new address[](2);
        addrs[0] = _addr1;
        addrs[1] = _addr2;
        return addrs;
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/TreasuryFeeHandler.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";

import { TreasuryFeeHandler } from "../contracts/uln/uln301/TreasuryFeeHandler.sol";

import { TokenMock } from "./mocks/TokenMock.sol";

contract TreasuryFeeHandlerTest is Test {
    address internal endpoint = address(0x1234);
    address internal msglib = address(0x5678);
    address internal sender = address(0x9abc);
    address internal treasury = address(0xdef0);
    TokenMock internal lzToken;
    TreasuryFeeHandler internal handler;

    function setUp() public {
        handler = new TreasuryFeeHandler(endpoint);
        lzToken = new TokenMock();
    }

    function test_payFee() public {
        lzToken.transfer(sender, 100);
        vm.prank(sender);
        lzToken.approve(address(handler), 100);

        vm.startPrank(msglib);

        // if the msglib is set by the sender but not sending payload, revert
        vm.mockCall(
            endpoint,
            abi.encodeWithSelector(ILayerZeroEndpoint.getSendLibraryAddress.selector),
            abi.encode(msglib)
        );
        vm.mockCall(endpoint, abi.encodeWithSelector(ILayerZeroEndpoint.isSendingPayload.selector), abi.encode(false));
        vm.expectRevert(TreasuryFeeHandler.LZ_TreasuryFeeHandler_OnlyOnSending.selector);
        handler.payFee(address(lzToken), sender, 100, 100, treasury);

        // when both conditions are met, but required amount is more than supplied, revert
        vm.mockCall(endpoint, abi.encodeWithSelector(ILayerZeroEndpoint.isSendingPayload.selector), abi.encode(true));
        vm.expectRevert(
            abi.encodeWithSelector(TreasuryFeeHandler.LZ_TreasuryFeeHandler_InvalidAmount.selector, 100, 99)
        );
        handler.payFee(address(lzToken), sender, 100, 99, treasury);

        // when both conditions are met, and required amount is less than supplied, transfer
        handler.payFee(address(lzToken), sender, 100, 100, treasury);
        assertEq(lzToken.balanceOf(treasury), 100);
        assertEq(lzToken.balanceOf(sender), 0);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/UlnBase.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { UlnBase, UlnConfig, SetDefaultUlnConfigParam } from "../contracts/uln/UlnBase.sol";
import { Constant } from "./util/Constant.sol";

contract UlnBaseTest is Test, UlnBase {
    address private constant DEFAULT_CONFIG = address(0x0);

    function test_setInvalidDefaultUlnConfig() public {
        vm.startPrank(owner());
        SetDefaultUlnConfigParam[] memory params = new SetDefaultUlnConfigParam[](1);

        // nil dvns count
        params[0] = SetDefaultUlnConfigParam(
            1,
            UlnConfig(1, Constant.NIL_DVN_COUNT, 0, 0, new address[](Constant.NIL_DVN_COUNT), new address[](0))
        );
        vm.expectRevert(LZ_ULN_InvalidRequiredDVNCount.selector);
        this.setDefaultUlnConfigs(params);

        // nil optional dvns count
        params[0] = SetDefaultUlnConfigParam(
            1,
            UlnConfig(1, 0, Constant.NIL_DVN_COUNT, 1, new address[](0), new address[](Constant.NIL_DVN_COUNT))
        );
        vm.expectRevert(LZ_ULN_InvalidOptionalDVNCount.selector);
        this.setDefaultUlnConfigs(params);

        // nil confirmations
        params[0] = SetDefaultUlnConfigParam(
            1,
            UlnConfig(Constant.NIL_CONFIRMATIONS, 1, 0, 0, new address[](1), new address[](0))
        );
        vm.expectRevert(LZ_ULN_InvalidConfirmations.selector);
        this.setDefaultUlnConfigs(params);

        // no dvn
        params[0] = SetDefaultUlnConfigParam(1, UlnConfig(1, 0, 0, 0, new address[](0), new address[](0)));
        vm.expectRevert(LZ_ULN_AtLeastOneDVN.selector);
        this.setDefaultUlnConfigs(params);
    }

    function test_setDefaultUlnConfig() public {
        vm.startPrank(owner());
        UlnConfig memory param = _newUlnConfig(10, 1, address(0x11), 1, address(0x22));
        SetDefaultUlnConfigParam[] memory params = new SetDefaultUlnConfigParam[](1);
        params[0] = SetDefaultUlnConfigParam(1, param);
        this.setDefaultUlnConfigs(params);

        // check default config
        UlnConfig memory defaultConfig = ulnConfigs[DEFAULT_CONFIG][1];
        assertEq(defaultConfig.confirmations, 10);
        assertEq(defaultConfig.requiredDVNCount, 1);
        assertEq(defaultConfig.optionalDVNCount, 1);
        assertEq(defaultConfig.optionalDVNThreshold, 1);
        assertEq(defaultConfig.requiredDVNs[0], address(0x11));
        assertEq(defaultConfig.optionalDVNs[0], address(0x22));
    }

    function test_setInvalidUlnConfig() public {
        // dvns.length > 0 but count == default(0)
        UlnConfig memory param = UlnConfig(1, 0, 0, 0, new address[](1), new address[](0));
        vm.expectRevert(LZ_ULN_InvalidRequiredDVNCount.selector);
        _setUlnConfig(1, address(2), param);

        // count != dvns.length
        param = UlnConfig(1, 1, 0, 0, new address[](2), new address[](0));
        vm.expectRevert(LZ_ULN_InvalidRequiredDVNCount.selector);
        _setUlnConfig(1, address(2), param);

        // dvns.length > MAX(127)
        param = UlnConfig(1, 128, 0, 0, new address[](128), new address[](0));
        vm.expectRevert(LZ_ULN_InvalidRequiredDVNCount.selector);
        _setUlnConfig(1, address(2), param);

        // duplicated dvns
        param = UlnConfig(1, 2, 0, 0, new address[](2), new address[](0));
        vm.expectRevert(LZ_ULN_Unsorted.selector);
        _setUlnConfig(1, address(2), param);

        // optionalDVNs.length > 0 but count == default(0)
        param = UlnConfig(1, 0, 0, 0, new address[](0), new address[](1));
        vm.expectRevert(LZ_ULN_InvalidOptionalDVNCount.selector);
        _setUlnConfig(1, address(2), param);

        // optionalDVNs.length > MAX(127)
        param = UlnConfig(1, 0, 128, 1, new address[](0), new address[](128));
        vm.expectRevert(LZ_ULN_InvalidOptionalDVNCount.selector);
        _setUlnConfig(1, address(2), param);

        // optionalDVNs.length < threshold
        param = UlnConfig(1, 0, 1, 2, new address[](0), new address[](1));
        vm.expectRevert(LZ_ULN_InvalidOptionalDVNThreshold.selector);
        _setUlnConfig(1, address(2), param);

        // optionalDVNs.length > 0 but threshold is 0
        param = UlnConfig(1, 0, 1, 0, new address[](0), new address[](1));
        vm.expectRevert(LZ_ULN_AtLeastOneDVN.selector);
        _setUlnConfig(1, address(2), param);
    }

    function test_setUlnConfig() public {
        UlnConfig memory param = _newUlnConfig(10, 1, address(0x11), 1, address(0x22));
        _setUlnConfig(1, address(2), param);

        // check custom config
        UlnConfig memory customConfig = ulnConfigs[address(2)][1];
        assertEq(customConfig.confirmations, 10);
        assertEq(customConfig.requiredDVNCount, 1);
        assertEq(customConfig.optionalDVNCount, 1);
        assertEq(customConfig.optionalDVNThreshold, 1);
        assertEq(customConfig.requiredDVNs[0], address(0x11));
        assertEq(customConfig.optionalDVNs[0], address(0x22));
    }

    function test_getUlnConfig() public {
        // no available dvn
        vm.expectRevert(LZ_ULN_AtLeastOneDVN.selector);
        getUlnConfig(address(1), 1);

        // set default config
        ulnConfigs[DEFAULT_CONFIG][1] = _newUlnConfig(10, 1, address(0x11), 1, address(0x22));

        // use default uln config
        UlnConfig memory config = getUlnConfig(address(1), 1);
        assertEq(config.confirmations, 10);
        assertEq(config.requiredDVNCount, 1);
        assertEq(config.optionalDVNCount, 1);
        assertEq(config.optionalDVNThreshold, 1);
        assertEq(config.requiredDVNs[0], address(0x11));
        assertEq(config.optionalDVNs[0], address(0x22));

        // set custom confirmations
        ulnConfigs[address(1)][1].confirmations = 2;
        config = getUlnConfig(address(1), 1);
        assertEq(config.confirmations, 2);

        // set custom confirmations to nil
        ulnConfigs[address(1)][1].confirmations = Constant.NIL_CONFIRMATIONS;
        config = getUlnConfig(address(1), 1);
        assertEq(config.confirmations, 0);

        // set custom required dvns
        ulnConfigs[address(1)][1].requiredDVNCount = 1;
        ulnConfigs[address(1)][1].requiredDVNs[0] = address(0x33);
        config = getUlnConfig(address(1), 1);
        assertEq(config.requiredDVNCount, 1);
        assertEq(config.requiredDVNs[0], address(0x33));

        // set custom dvns to nil
        ulnConfigs[address(1)][1].requiredDVNCount = Constant.NIL_DVN_COUNT;
        config = getUlnConfig(address(1), 1);
        assertEq(config.requiredDVNCount, 0);
        assertEq(config.requiredDVNs.length, 0);

        // set custom optional dvns
        ulnConfigs[address(1)][1].optionalDVNCount = 1;
        ulnConfigs[address(1)][1].optionalDVNs[0] = address(0x44);
        config = getUlnConfig(address(1), 1);
        assertEq(config.optionalDVNCount, 1);
        assertEq(config.optionalDVNs[0], address(0x44));

        // set custom optional dvns to nil
        ulnConfigs[address(1)][1].optionalDVNCount = Constant.NIL_DVN_COUNT;
        config = getUlnConfig(address(1), 1);
        assertEq(config.optionalDVNCount, 0);
        assertEq(config.optionalDVNs.length, 0);
        assertEq(config.optionalDVNThreshold, 0);
    }

    function _newSingletonAddressArray(address _addr) internal pure returns (address[] memory) {
        address[] memory addrs = new address[](1);
        addrs[0] = _addr;
        return addrs;
    }

    function _newUlnConfig(
        uint64 _confirmations,
        uint8 _requiredCount,
        address _dvn,
        uint8 _optionalCount,
        address _optionalDVN
    ) internal pure returns (UlnConfig memory) {
        address[] memory dvns = _dvn == address(0) ? new address[](0) : _newSingletonAddressArray(_dvn);
        address[] memory optionalDVNs = _optionalDVN == address(0)
            ? new address[](0)
            : _newSingletonAddressArray(_optionalDVN);
        uint8 optionalDVNThreshold = _optionalDVN == address(0) ? 0 : 1;
        return UlnConfig(_confirmations, _requiredCount, _optionalCount, optionalDVNThreshold, dvns, optionalDVNs);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/UlnOptions.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { AddressCast } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol";

import { UlnOptions as UlnOptionsImpl } from "../contracts/uln/libs/UlnOptions.sol";

import { OptionsUtil } from "./util/OptionsUtil.sol";

library UlnOptions {
    function decode(
        bytes calldata _options
    ) external pure returns (bytes memory executorOptions, bytes memory dvnOptions) {
        return UlnOptionsImpl.decode(_options);
    }
}

contract UlnOptionsTest is Test {
    using OptionsUtil for bytes;
    using BytesLib for bytes;

    function test_decode_type1() public {
        uint128 executeGas = 20000;
        bytes memory legacyOptions = OptionsUtil.encodeLegacyOptionsType1(executeGas);
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(legacyOptions);

        bytes memory t3Options = "";
        t3Options = t3Options.addExecutorLzReceiveOption(executeGas, 0);
        assertEq(executorOptions, t3Options);
        assertEq(dvnOptions, "");
    }

    function test_decode_type2() public {
        uint128 executeGas = 20000;
        uint128 amount = 10000;
        address receiver = address(0x1234);
        bytes memory legacyOptions = OptionsUtil.encodeLegacyOptionsType2(
            executeGas,
            amount,
            abi.encodePacked(receiver)
        );
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(legacyOptions);

        bytes memory t3Options = "";
        t3Options = t3Options.addExecutorLzReceiveOption(executeGas, 0).addExecutorNativeDropOption(
            amount,
            AddressCast.toBytes32(receiver)
        );
        assertEq(executorOptions, t3Options);
        assertEq(dvnOptions, "");
    }

    function test_decode_type3_executor_with_1_option() public {
        uint128 executeGas = 20000;
        bytes memory t3Options = OptionsUtil.newOptions().addExecutorLzReceiveOption(executeGas, 0);
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(t3Options);

        assertEq(executorOptions, OptionsUtil.trimType(t3Options));
        assertEq(dvnOptions, "");
    }

    function test_decode_type3_executor_with_n_option() public {
        uint128 executeGas = 20000;
        uint128 amount = 10000;
        address receiver = address(0x1234);
        bytes memory t3Options = OptionsUtil
            .newOptions()
            .addExecutorLzReceiveOption(executeGas, 0)
            .addExecutorNativeDropOption(amount, AddressCast.toBytes32(receiver));
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(t3Options);

        assertEq(executorOptions, OptionsUtil.trimType(t3Options));
        assertEq(dvnOptions, "");
    }

    function test_decode_type3_dvn_with_1_option() public {
        bytes memory t3Options = OptionsUtil.newOptions().addDVNPreCrimeOption(1);
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(t3Options);

        assertEq(executorOptions, "");
        assertEq(dvnOptions, OptionsUtil.trimType(t3Options));
    }

    function test_decode_type3_dvn_with_n_option() public {
        bytes memory t3Options = OptionsUtil
            .newOptions()
            .addDVNPreCrimeOption(1)
            .addDVNPreCrimeOption(2)
            .addDVNPreCrimeOption(3)
            .addDVNPreCrimeOption(4);
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(t3Options);

        assertEq(executorOptions, "");
        assertEq(dvnOptions, OptionsUtil.trimType(t3Options));
    }

    function test_decode_type3_dvn_with_n_option_and_executor_with_n_option() public {
        uint128 executeGas = 20000;
        uint128 amount = 10000;
        address receiver = address(0x1234);
        bytes memory t3Options = OptionsUtil
            .newOptions()
            .addDVNPreCrimeOption(1)
            .addExecutorLzReceiveOption(executeGas, 0)
            .addDVNPreCrimeOption(2)
            .addExecutorNativeDropOption(amount, AddressCast.toBytes32(receiver))
            .addDVNPreCrimeOption(3)
            .addDVNPreCrimeOption(4);
        (bytes memory executorOptions, bytes memory dvnOptions) = UlnOptions.decode(t3Options);

        bytes memory t3ExecutorOptions = "";
        t3ExecutorOptions = t3ExecutorOptions.addExecutorLzReceiveOption(executeGas, 0).addExecutorNativeDropOption(
            amount,
            AddressCast.toBytes32(receiver)
        );
        bytes memory t3DVNOptions = "";
        t3DVNOptions = t3DVNOptions
            .addDVNPreCrimeOption(1)
            .addDVNPreCrimeOption(2)
            .addDVNPreCrimeOption(3)
            .addDVNPreCrimeOption(4);

        assertEq(executorOptions, t3ExecutorOptions);
        assertEq(dvnOptions, t3DVNOptions);
    }

    function test_decode_type3_options_invalid_size() public {
        // case 1: add one more byte to make it invalid
        bytes memory t3Options = OptionsUtil.newOptions().addExecutorLzReceiveOption(20000, 0);
        t3Options = t3Options.concat(hex"aa");

        vm.expectRevert();
        UlnOptions.decode(t3Options);

        // case 2: remove the last byte to make it invalid
        t3Options = OptionsUtil.newOptions().addExecutorLzReceiveOption(20000, 0);
        t3Options = t3Options.slice(0, t3Options.length - 1);

        vm.expectRevert();
        UlnOptions.decode(t3Options);
    }

    function test_decode_type3_options_invalid_worker_id() public {
        uint8 workerId = 0;
        uint8 optionType = 1;
        bytes memory t3Options = OptionsUtil.newOptions().addOption(workerId, optionType, bytes("abcd"));

        vm.expectRevert(abi.encodeWithSelector(UlnOptionsImpl.LZ_ULN_InvalidWorkerId.selector, 0));
        UlnOptions.decode(t3Options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/Worker.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { ISendLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";

import { Worker } from "../contracts/Worker.sol";
import { TokenMock } from "./mocks/TokenMock.sol";

contract WorkerTest is Worker, Test {
    address internal ROLE_ADMIN = address(0x1);
    address internal ADMIN = address(0x2);

    constructor() Worker(new address[](0), address(0), 0, ROLE_ADMIN, new address[](0)) {
        _grantRole(ADMIN_ROLE, ADMIN);
    }

    function test_hasAcl() public {
        address alice = address(0xabc);
        address bob = address(0xdef);

        // both allowlist and denylist are empty, so everyone is allowed
        assertEq(hasAcl(alice), true);
        assertEq(hasAcl(bob), true);

        // add alice to denylist, so she is not allowed, but bob is still allowed
        _grantRole(DENYLIST, alice);
        assertEq(hasAcl(alice), false);
        assertEq(hasAcl(bob), true);

        // add alice to allowlist, but she is still not allowed because she is in the denylist
        // for bob, he is not allowed because he is not in the allowlist
        _grantRole(ALLOWLIST, alice);
        assertEq(hasAcl(alice), false);
        assertEq(hasAcl(bob), false);

        // add bob to allowlist, so he is allowed
        _grantRole(ALLOWLIST, bob);
        assertEq(hasAcl(bob), true);

        // remove alice from denylist, so she is allowed
        _revokeRole(DENYLIST, alice);
        assertEq(hasAcl(alice), true);

        // remove alice and bob from allowlist, so both allowlist and denylist are empty again
        _revokeRole(ALLOWLIST, alice);
        _revokeRole(ALLOWLIST, bob);
        assertEq(hasAcl(alice), true);
        assertEq(hasAcl(bob), true);
    }

    function test_setPaused() public {
        // only role admin can set paused
        vm.expectRevert();
        this.setPaused(true);

        vm.startPrank(ROLE_ADMIN);
        this.setPaused(true);
        assertEq(paused(), true);
        this.setPaused(false);
        assertEq(paused(), false);
    }

    function test_setPriceFeed() public {
        // only admin can set price feed
        vm.expectRevert();
        this.setPriceFeed(address(1234));

        vm.startPrank(ADMIN);
        vm.expectEmit(true, false, false, true);
        emit SetPriceFeed(address(1234));
        this.setPriceFeed(address(1234));
        assertEq(priceFeed, address(1234));
    }

    function test_setWorkerFeeLib() public {
        // only admin can set worker fee lib
        vm.expectRevert();
        this.setWorkerFeeLib(address(1234));

        vm.startPrank(ADMIN);
        vm.expectEmit(true, false, false, true);
        emit SetWorkerLib(address(1234));
        this.setWorkerFeeLib(address(1234));
        assertEq(workerFeeLib, address(1234));
    }

    function test_setDefaultMultiplierBps() public {
        // only admin can set default multiplier bps
        vm.expectRevert();
        this.setDefaultMultiplierBps(10);

        vm.startPrank(ADMIN);
        vm.expectEmit(true, false, false, true);
        emit SetDefaultMultiplierBps(10);
        this.setDefaultMultiplierBps(10);
        assertEq(defaultMultiplierBps, 10);
    }

    function test_withdrawFee() public {
        address lib = address(0x1234);
        address to = address(0x5678);
        vm.mockCall(lib, abi.encodeWithSelector(ISendLib.withdrawFee.selector), "");

        // only admin can withdraw fee
        vm.expectRevert();
        this.withdrawFee(lib, to, 10);

        // lib must have the message lib role
        vm.startPrank(ADMIN);
        vm.expectRevert(Worker_OnlyMessageLib.selector);
        this.withdrawFee(lib, to, 10);

        // grant lib the message lib role
        _grantRole(MESSAGE_LIB_ROLE, lib);
        vm.expectEmit(true, false, false, true);
        emit Withdraw(lib, to, 10);
        this.withdrawFee(lib, to, 10);
    }

    function test_withdrawToken() public {
        address alice = address(0xabc);
        TokenMock token = new TokenMock();

        // only admin can withdraw token
        vm.expectRevert();
        this.withdrawToken(address(token), alice, 10);

        vm.startPrank(ADMIN);
        // withdraw token
        this.withdrawToken(address(token), alice, 10);
        assertEq(token.balanceOf(address(alice)), 10);

        // withdraw native
        this.withdrawToken(address(0x0), alice, 10);
        assertEq(address(alice).balance, 10);
    }

    function test_grantAndRevokeRole() public {
        address alice = address(0xabc);
        address bob = address(0xdef);

        // grant ALLOWLIST role to alice, allowlistSize should be 1
        _grantRole(ALLOWLIST, alice);
        assertEq(allowlistSize, 1);

        // grant ALLOWLIST role to bob, allowlistSize should be 2
        _grantRole(ALLOWLIST, bob);
        assertEq(allowlistSize, 2);

        // grant ALLOWLIST role to alice again, allowlistSize should still be 2
        _grantRole(ALLOWLIST, alice);
        assertEq(allowlistSize, 2);

        // grant DENYLIST role to alice, allowlistSize should still be 2
        _grantRole(DENYLIST, alice);
        assertEq(allowlistSize, 2);

        // revoke ALLOWLIST role from alice, allowlistSize should be 1
        _revokeRole(ALLOWLIST, alice);
        assertEq(allowlistSize, 1);

        // revoke ALLOWLIST role from bob, allowlistSize should be 0
        _revokeRole(ALLOWLIST, bob);
        assertEq(allowlistSize, 0);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/mocks/EndpointV1.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.17;

import "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroReceiver.sol";
import "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";
import "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

contract EndpointV1 is Ownable, ILayerZeroEndpoint {
    uint16 public immutable chainId;

    // installed libraries and reserved versions
    uint16 public constant BLOCK_VERSION = 65535;
    uint16 public constant DEFAULT_VERSION = 0;
    uint16 public latestVersion;
    mapping(uint16 => ILayerZeroMessagingLibrary) public libraryLookup; // version -> ILayerZeroEndpointLibrary

    // default send/receive libraries
    uint16 public defaultSendVersion;
    uint16 public defaultReceiveVersion;
    ILayerZeroMessagingLibrary public defaultSendLibrary;
    address public defaultReceiveLibraryAddress;

    struct LibraryConfig {
        uint16 sendVersion;
        uint16 receiveVersion;
        address receiveLibraryAddress;
        ILayerZeroMessagingLibrary sendLibrary;
    }

    struct StoredPayload {
        uint64 payloadLength;
        address dstAddress;
        bytes32 payloadHash;
    }

    // user app config = [uaAddress]
    mapping(address => LibraryConfig) public uaConfigLookup;
    // inboundNonce = [srcChainId][srcAddress].
    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;
    // outboundNonce = [dstChainId][srcAddress].
    mapping(uint16 => mapping(address => uint64)) public outboundNonce;
    // storedPayload = [srcChainId][srcAddress]
    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;

    // library versioning events
    event NewLibraryVersionAdded(uint16 version);
    event DefaultSendVersionSet(uint16 version);
    event DefaultReceiveVersionSet(uint16 version);
    event UaSendVersionSet(address ua, uint16 version);
    event UaReceiveVersionSet(address ua, uint16 version);
    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);
    // payload events
    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);
    event PayloadStored(
        uint16 srcChainId,
        bytes srcAddress,
        address dstAddress,
        uint64 nonce,
        bytes payload,
        bytes reason
    );

    constructor(uint16 _chainId) {
        chainId = _chainId;
    }

    //---------------------------------------------------------------------------
    // send and receive nonreentrant lock
    uint8 internal constant _NOT_ENTERED = 1;
    uint8 internal constant _ENTERED = 2;
    uint8 internal _send_entered_state = 1;
    uint8 internal _receive_entered_state = 1;

    modifier sendNonReentrant() {
        require(_send_entered_state == _NOT_ENTERED, "LayerZero: no send reentrancy");
        _send_entered_state = _ENTERED;
        _;
        _send_entered_state = _NOT_ENTERED;
    }
    modifier receiveNonReentrant() {
        require(_receive_entered_state == _NOT_ENTERED, "LayerZero: no receive reentrancy");
        _receive_entered_state = _ENTERED;
        _;
        _receive_entered_state = _NOT_ENTERED;
    }

    // BLOCK_VERSION is also a valid version
    modifier validVersion(uint16 _version) {
        require(_version <= latestVersion || _version == BLOCK_VERSION, "LayerZero: invalid messaging library version");
        _;
    }

    //---------------------------------------------------------------------------
    // User Application Calls - Endpoint Interface

    function send(
        uint16 _dstChainId,
        bytes calldata _destination,
        bytes calldata _payload,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes calldata _adapterParams
    ) external payable override sendNonReentrant {
        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];
        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];
        _getSendLibrary(uaConfig).send{ value: msg.value }(
            msg.sender,
            nonce,
            _dstChainId,
            _destination,
            _payload,
            _refundAddress,
            _zroPaymentAddress,
            _adapterParams
        );
    }

    //---------------------------------------------------------------------------
    // authenticated Library (msg.sender) Calls to pass through Endpoint to UA (dstAddress)
    function receivePayload(
        uint16 _srcChainId,
        bytes calldata _srcAddress,
        address _dstAddress,
        uint64 _nonce,
        uint _gasLimit,
        bytes calldata _payload
    ) external override receiveNonReentrant {
        // assert and increment the nonce. no message shuffling
        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], "LayerZero: wrong nonce");

        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];

        // authentication to prevent cross-version message validation
        // protects against a malicious library from passing arbitrary data
        if (uaConfig.receiveVersion == DEFAULT_VERSION) {
            require(defaultReceiveLibraryAddress == msg.sender, "LayerZero: invalid default library");
        } else {
            require(uaConfig.receiveLibraryAddress == msg.sender, "LayerZero: invalid library");
        }

        // block if any message blocking
        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];
        require(sp.payloadHash == bytes32(0), "LayerZero: in message blocking");

        try ILayerZeroReceiver(_dstAddress).lzReceive{ gas: _gasLimit }(_srcChainId, _srcAddress, _nonce, _payload) {
            // success, do nothing, end of the message delivery
        } catch (bytes memory reason) {
            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode
            storedPayload[_srcChainId][_srcAddress] = StoredPayload(
                uint64(_payload.length),
                _dstAddress,
                keccak256(_payload)
            );
            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);
        }
    }

    function retryPayload(
        uint16 _srcChainId,
        bytes calldata _srcAddress,
        bytes calldata _payload
    ) external override receiveNonReentrant {
        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];
        require(sp.payloadHash != bytes32(0), "LayerZero: no stored payload");
        require(
            _payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,
            "LayerZero: invalid payload"
        );

        address dstAddress = sp.dstAddress;
        // empty the storedPayload
        sp.payloadLength = 0;
        sp.dstAddress = address(0);
        sp.payloadHash = bytes32(0);

        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];

        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);
        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);
    }

    //---------------------------------------------------------------------------
    // Owner Calls, only new library version upgrade (3 steps)

    // note libraryLookup[0] = 0x0, no library implementation
    // LIBRARY UPGRADE step 1: set _newLayerZeroLibraryAddress be the new version
    function newVersion(address _newLayerZeroLibraryAddress) external onlyOwner {
        require(_newLayerZeroLibraryAddress != address(0x0), "LayerZero: new version cannot be zero address");
        require(latestVersion < 65535, "LayerZero: can not add new messaging library");
        latestVersion++;
        libraryLookup[latestVersion] = ILayerZeroMessagingLibrary(_newLayerZeroLibraryAddress);
        emit NewLibraryVersionAdded(latestVersion);
    }

    // LIBRARY UPGRADE step 2: stop sending messages from the old version
    function setDefaultSendVersion(
        uint16 _newDefaultSendVersion
    ) external onlyOwner validVersion(_newDefaultSendVersion) {
        require(_newDefaultSendVersion != DEFAULT_VERSION, "LayerZero: default send version must > 0");
        defaultSendVersion = _newDefaultSendVersion;
        defaultSendLibrary = libraryLookup[defaultSendVersion];
        emit DefaultSendVersionSet(_newDefaultSendVersion);
    }

    // LIBRARY UPGRADE step 3: stop receiving messages from the old version
    function setDefaultReceiveVersion(
        uint16 _newDefaultReceiveVersion
    ) external onlyOwner validVersion(_newDefaultReceiveVersion) {
        require(_newDefaultReceiveVersion != DEFAULT_VERSION, "LayerZero: default receive version must > 0");
        defaultReceiveVersion = _newDefaultReceiveVersion;
        defaultReceiveLibraryAddress = address(libraryLookup[defaultReceiveVersion]);
        emit DefaultReceiveVersionSet(_newDefaultReceiveVersion);
    }

    //---------------------------------------------------------------------------
    // User Application Calls - UA set/get Interface

    function setConfig(
        uint16 _version,
        uint16 _chainId,
        uint _configType,
        bytes calldata _config
    ) external override validVersion(_version) {
        if (_version == DEFAULT_VERSION) {
            require(
                defaultSendVersion == defaultReceiveVersion,
                "LayerZero: can not set Config during DEFAULT migration"
            );
            _version = defaultSendVersion;
        }
        require(_version != BLOCK_VERSION, "LayerZero: can not set config for BLOCK_VERSION");
        libraryLookup[_version].setConfig(_chainId, msg.sender, _configType, _config);
    }

    // Migration step 1: set the send version
    // Define what library the UA points too
    function setSendVersion(uint16 _newVersion) external override validVersion(_newVersion) {
        // write into config
        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];
        uaConfig.sendVersion = _newVersion;
        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0
        uaConfig.sendLibrary = libraryLookup[_newVersion];
        emit UaSendVersionSet(msg.sender, _newVersion);
    }

    // Migration step 2: set the receive version
    // after all messages sent from the old version are received
    // the UA can now safely switch to the new receive version
    // it is the UA's responsibility make sure all messages from the old version are processed
    function setReceiveVersion(uint16 _newVersion) external override validVersion(_newVersion) {
        // write into config
        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];
        uaConfig.receiveVersion = _newVersion;
        // the libraryLookup[BLOCK_VERSION || DEFAULT_VERSION] = 0x0
        uaConfig.receiveLibraryAddress = address(libraryLookup[_newVersion]);
        emit UaReceiveVersionSet(msg.sender, _newVersion);
    }

    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {
        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];
        // revert if no messages are cached. safeguard malicious UA behaviour
        require(sp.payloadHash != bytes32(0), "LayerZero: no stored payload");
        require(sp.dstAddress == msg.sender, "LayerZero: invalid caller");

        // empty the storedPayload
        sp.payloadLength = 0;
        sp.dstAddress = address(0);
        sp.payloadHash = bytes32(0);

        // emit the event with the new nonce
        emit UaForceResumeReceive(_srcChainId, _srcAddress);
    }

    //---------------------------------------------------------------------------
    // view helper function

    function estimateFees(
        uint16 _dstChainId,
        address _userApplication,
        bytes calldata _payload,
        bool _payInZRO,
        bytes calldata _adapterParams
    ) external view override returns (uint nativeFee, uint zroFee) {
        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];
        ILayerZeroMessagingLibrary lib = uaConfig.sendVersion == DEFAULT_VERSION
            ? defaultSendLibrary
            : uaConfig.sendLibrary;
        return lib.estimateFees(_dstChainId, _userApplication, _payload, _payInZRO, _adapterParams);
    }

    function _getSendLibrary(LibraryConfig storage uaConfig) internal view returns (ILayerZeroMessagingLibrary) {
        if (uaConfig.sendVersion == DEFAULT_VERSION) {
            // check if the in send-blocking upgrade
            require(defaultSendVersion != BLOCK_VERSION, "LayerZero: default in BLOCK_VERSION");
            return defaultSendLibrary;
        } else {
            // check if the in send-blocking upgrade
            require(uaConfig.sendVersion != BLOCK_VERSION, "LayerZero: in BLOCK_VERSION");
            return uaConfig.sendLibrary;
        }
    }

    function getSendLibraryAddress(
        address _userApplication
    ) external view override returns (address sendLibraryAddress) {
        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];
        uint16 sendVersion = uaConfig.sendVersion;
        require(sendVersion != BLOCK_VERSION, "LayerZero: send version is BLOCK_VERSION");
        if (sendVersion == DEFAULT_VERSION) {
            require(defaultSendVersion != BLOCK_VERSION, "LayerZero: send version (default) is BLOCK_VERSION");
            sendLibraryAddress = address(defaultSendLibrary);
        } else {
            sendLibraryAddress = address(uaConfig.sendLibrary);
        }
    }

    function getReceiveLibraryAddress(
        address _userApplication
    ) external view override returns (address receiveLibraryAddress) {
        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];
        uint16 receiveVersion = uaConfig.receiveVersion;
        require(receiveVersion != BLOCK_VERSION, "LayerZero: receive version is BLOCK_VERSION");
        if (receiveVersion == DEFAULT_VERSION) {
            require(defaultReceiveVersion != BLOCK_VERSION, "LayerZero: receive version (default) is BLOCK_VERSION");
            receiveLibraryAddress = defaultReceiveLibraryAddress;
        } else {
            receiveLibraryAddress = uaConfig.receiveLibraryAddress;
        }
    }

    function isSendingPayload() external view override returns (bool) {
        return _send_entered_state == _ENTERED;
    }

    function isReceivingPayload() external view override returns (bool) {
        return _receive_entered_state == _ENTERED;
    }

    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (uint64) {
        return inboundNonce[_srcChainId][_srcAddress];
    }

    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view override returns (uint64) {
        return outboundNonce[_dstChainId][_srcAddress];
    }

    function getChainId() external view override returns (uint16) {
        return chainId;
    }

    function getSendVersion(address _userApplication) external view override returns (uint16) {
        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];
        return uaConfig.sendVersion == DEFAULT_VERSION ? defaultSendVersion : uaConfig.sendVersion;
    }

    function getReceiveVersion(address _userApplication) external view override returns (uint16) {
        LibraryConfig storage uaConfig = uaConfigLookup[_userApplication];
        return uaConfig.receiveVersion == DEFAULT_VERSION ? defaultReceiveVersion : uaConfig.receiveVersion;
    }

    function getConfig(
        uint16 _version,
        uint16 _chainId,
        address _userApplication,
        uint _configType
    ) external view override validVersion(_version) returns (bytes memory) {
        if (_version == DEFAULT_VERSION) {
            require(defaultSendVersion == defaultReceiveVersion, "LayerZero: no DEFAULT config while migration");
            _version = defaultSendVersion;
        }
        require(_version != BLOCK_VERSION, "LayerZero: can not get config for BLOCK_VERSION");
        return libraryLookup[_version].getConfig(_chainId, _userApplication, _configType);
    }

    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {
        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];
        return sp.payloadHash != bytes32(0);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/mocks/PriceFeedMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ILayerZeroPriceFeed } from "../../contracts/interfaces/ILayerZeroPriceFeed.sol";

contract PriceFeedMock is ILayerZeroPriceFeed {
    uint128 PRICE_RATIO_DENOMINATOR = 1e10;
    uint128 public nativeTokenPriceUSD;
    uint128 tokensPriceRatio;
    uint256 gasFee;

    function setup(uint256 _fee, uint128 _priceRatio, uint128 _nativeTokenPriceUSD) external {
        gasFee = _fee;
        tokensPriceRatio = _priceRatio;
        nativeTokenPriceUSD = _nativeTokenPriceUSD;
    }

    function getFee(uint32, uint256, uint256) public pure returns (uint256) {
        return 0;
    }

    function getPrice(uint32) external view override returns (Price memory price) {
        price = Price(tokensPriceRatio, 0, 0);
    }

    function getPriceRatioDenominator() external view override returns (uint128) {
        return PRICE_RATIO_DENOMINATOR;
    }

    function estimateFeeByEid(
        uint32,
        uint256,
        uint256
    )
        external
        view
        override
        returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD)
    {
        return (gasFee, tokensPriceRatio, PRICE_RATIO_DENOMINATOR, nativeTokenPriceUSD);
    }

    function estimateFeeOnSend(
        uint32,
        uint256,
        uint256
    )
        external
        payable
        override
        returns (uint256 fee, uint128 priceRatio, uint128 priceRatioDenominator, uint128 nativePriceUSD)
    {
        return (gasFee, tokensPriceRatio, PRICE_RATIO_DENOMINATOR, nativeTokenPriceUSD);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/mocks/ReceiveLibMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.20;

import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";
import { IMessageLib, MessageLibType } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol";
import { IReceiveUlnE2 } from "../../contracts/uln/interfaces/IReceiveUlnE2.sol";
import { Verification } from "../../contracts/uln/ReceiveUlnBase.sol";

contract ReceiveLibMock is IReceiveUlnE2, IMessageLib {
    error NotImplemented();

    mapping(bytes32 headerHash => mapping(bytes32 payloadHash => mapping(address dvn => Verification)))
        public hashLookup;

    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {
        hashLookup[keccak256(_packetHeader)][_payloadHash][msg.sender] = Verification(true, _confirmations);
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (3, 0, 2);
    }

    function commitVerification(bytes calldata, bytes32) external pure {
        revert NotImplemented();
    }

    function setConfig(address, SetConfigParam[] calldata) external pure {
        revert NotImplemented();
    }

    function getConfig(uint32, address, uint32) external pure returns (bytes memory) {
        revert NotImplemented();
    }

    function isSupportedEid(uint32) external pure returns (bool) {
        revert NotImplemented();
    }

    function messageLibType() external pure returns (MessageLibType) {
        revert NotImplemented();
    }

    function supportsInterface(bytes4) external pure returns (bool) {
        revert NotImplemented();
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/mocks/SendLibMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.20;

import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";
import { MessagingFee } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { MessageLibType } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol";
import { ISendLib, Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { Transfer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Transfer.sol";

contract SendLibMock is ISendLib {
    mapping(address worker => uint256) public fees;

    error InvalidAmount(uint256 requested, uint256 available);
    error NotImplemented();

    receive() external payable {}

    function setFee(address _worker) external payable {
        fees[_worker] = msg.value;
    }

    function _debitFee(uint256 _amount) internal {
        uint256 fee = fees[msg.sender];
        if (_amount > fee) revert InvalidAmount(_amount, fee);
        unchecked {
            fees[msg.sender] = fee - _amount;
        }
    }

    function withdrawFee(address _to, uint256 _amount) external {
        _debitFee(_amount);
        address nativeToken = address(0);
        Transfer.nativeOrToken(nativeToken, _to, _amount);
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (3, 0, 2);
    }

    function send(Packet calldata, bytes calldata, bool) external pure returns (MessagingFee memory, bytes memory) {
        revert NotImplemented();
    }

    function quote(Packet calldata, bytes calldata, bool) external pure returns (MessagingFee memory) {
        revert NotImplemented();
    }

    function setTreasury(address) external pure {
        revert NotImplemented();
    }

    function withdrawLzTokenFee(address, address, uint256) external pure {
        revert NotImplemented();
    }

    function setConfig(address, SetConfigParam[] calldata) external pure {
        revert NotImplemented();
    }

    function getConfig(uint32, address, uint32) external pure returns (bytes memory) {
        revert NotImplemented();
    }

    function isSupportedEid(uint32) external pure returns (bool) {
        revert NotImplemented();
    }

    function messageLibType() external pure returns (MessageLibType) {
        revert NotImplemented();
    }

    function supportsInterface(bytes4) external pure returns (bool) {
        revert NotImplemented();
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/mocks/TokenMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TokenMock is ERC20 {
    constructor() ERC20("Token", "TKN") {
        _mint(msg.sender, 1000000000 * 10 ** 18);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/util/Constant.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

library Constant {
    // uln301 lib version
    uint16 internal constant MSG_VERSION = 1;

    uint16 internal constant EID_ETHEREUM = 101;
    uint16 internal constant EID_BSC = 102;

    uint256 internal constant TREASURY_GAS_CAP = 100000;
    uint256 internal constant TREASURY_GAS_FOR_FEE_CAP = 100000;

    uint32 internal constant CONFIG_TYPE_EXECUTOR = 1;
    uint32 internal constant CONFIG_TYPE_ULN = 2;
    uint32 internal constant CONFIG_TYPE_UNKNOWN = 11111;

    uint8 internal constant NIL_DVN_COUNT = type(uint8).max;
    uint64 internal constant NIL_CONFIRMATIONS = type(uint64).max;
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/util/OptionsUtil.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";

import { ExecutorOptions } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol";

import { DVNOptions } from "../../contracts/uln/libs/DVNOptions.sol";

library OptionsUtil {
    using SafeCast for uint256;
    using BytesLib for bytes;

    uint16 internal constant TYPE_1 = 1; // legacy options type 1
    uint16 internal constant TYPE_2 = 2; // legacy options type 2
    uint16 internal constant TYPE_3 = 3;

    function newOptions() internal pure returns (bytes memory) {
        return abi.encodePacked(TYPE_3);
    }

    function addExecutorLzReceiveOption(
        bytes memory _options,
        uint128 _gas,
        uint128 _value
    ) internal pure returns (bytes memory) {
        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);
    }

    function addExecutorNativeDropOption(
        bytes memory _options,
        uint128 _amount,
        bytes32 _receiver
    ) internal pure returns (bytes memory) {
        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);
    }

    function addExecutorLzComposeOption(
        bytes memory _options,
        uint128 _gas,
        uint128 _value
    ) internal pure returns (bytes memory) {
        bytes memory option = ExecutorOptions.encodeLzComposeOption(0, _gas, _value);
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);
    }

    function addExecutorOrderedExecutionOption(bytes memory _options) internal pure returns (bytes memory) {
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(""));
    }

    function addDVNPreCrimeOption(bytes memory _options, uint8 _dvnIdx) internal pure returns (bytes memory) {
        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(""));
    }

    function addExecutorOption(
        bytes memory _options,
        uint8 _optionType,
        bytes memory _option
    ) internal pure returns (bytes memory) {
        return
            abi.encodePacked(
                _options,
                ExecutorOptions.WORKER_ID,
                _option.length.toUint16() + 1, // +1 for optionType
                _optionType,
                _option
            );
    }

    function addDVNOption(
        bytes memory _options,
        uint8 _dvnIdx,
        uint8 _optionType,
        bytes memory _option
    ) internal pure returns (bytes memory) {
        return
            abi.encodePacked(
                _options,
                DVNOptions.WORKER_ID,
                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx
                _dvnIdx,
                _optionType,
                _option
            );
    }

    function addOption(
        bytes memory _options,
        uint8 _workerId,
        uint8 _optionType,
        bytes memory _option
    ) internal pure returns (bytes memory) {
        return
            abi.encodePacked(
                _options,
                _workerId,
                _option.length.toUint16() + 1, // +1 for optionType
                _optionType,
                _option
            );
    }

    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {
        return abi.encodePacked(TYPE_1, _executionGas);
    }

    function encodeLegacyOptionsType2(
        uint256 _executionGas,
        uint256 _amount,
        bytes memory _receiver // use bytes instead of bytes32 in legacy type 2
    ) internal pure returns (bytes memory) {
        return abi.encodePacked(TYPE_2, _executionGas, _amount, _receiver);
    }

    function trimType(bytes memory _options) internal pure returns (bytes memory) {
        return _options.slice(2, _options.length - 2);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/util/Packet.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";

library PacketUtil {
    function newPacket(
        uint64 _nonce,
        uint32 _srcEid,
        address _sender,
        uint32 _dstEid,
        address _receiver,
        bytes memory _message
    ) internal pure returns (Packet memory) {
        bytes32 guid = keccak256(
            abi.encodePacked(
                _nonce,
                _srcEid,
                bytes32(uint256(uint160(_sender))),
                uint32(_dstEid),
                bytes32(uint256(uint160(_receiver)))
            )
        );
        return Packet(_nonce, _srcEid, _sender, _dstEid, bytes32(uint256(uint160(_receiver))), guid, _message);
    }
}


================================================================================
File: packages/layerzero-v2/evm/messagelib/test/util/Setup.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { EndpointV2 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol";
import { EndpointV1 } from "../mocks/EndpointV1.sol";

import { NonceContractMock as NonceContract } from "../../contracts/uln/uln301/mocks/NonceContractMock.sol";
import { IDVN } from "../../contracts/uln/interfaces/IDVN.sol";
import { DVN } from "../../contracts/uln/dvn/DVN.sol";
import { DVNFeeLib } from "../../contracts/uln/dvn/DVNFeeLib.sol";
import { Executor } from "../../contracts/Executor.sol";
import { ExecutorFeeLib } from "../../contracts/ExecutorFeeLib.sol";
import { IExecutor } from "../../contracts/interfaces/IExecutor.sol";
import { PriceFeed } from "../../contracts/PriceFeed.sol";
import { Treasury } from "../../contracts/Treasury.sol";
import { TreasuryFeeHandler } from "../../contracts/uln/uln301/TreasuryFeeHandler.sol";
import { ExecutorConfig, SetDefaultExecutorConfigParam } from "../../contracts/SendLibBase.sol";
import { UlnConfig, SetDefaultUlnConfigParam } from "../../contracts/uln/UlnBase.sol";
import { SetDefaultExecutorParam } from "../../contracts/uln/uln301/ReceiveLibBaseE1.sol";
import { SendUln301 } from "../../contracts/uln/uln301/SendUln301.sol";
import { ReceiveUln301 } from "../../contracts/uln/uln301/ReceiveUln301.sol";
import { SendUln302 } from "../../contracts/uln/uln302/SendUln302.sol";
import { ReceiveUln302 } from "../../contracts/uln/uln302/ReceiveUln302.sol";

import { TokenMock } from "../mocks/TokenMock.sol";
import { Constant } from "./Constant.sol";
import { OptionsUtil } from "./OptionsUtil.sol";

library Setup {
    using OptionsUtil for bytes;

    struct FixtureV1 {
        uint16 eid;
        EndpointV1 endpointV1;
        SendUln301 sendUln301;
        ReceiveUln301 receiveUln301;
        Executor executor;
        DVN dvn;
        PriceFeed priceFeed;
        Treasury treasury;
        TreasuryFeeHandler treasuryFeeHandler;
        TokenMock lzToken;
    }

    struct FixtureV2 {
        uint32 eid;
        EndpointV2 endpointV2;
        SendUln302 sendUln302;
        ReceiveUln302 receiveUln302;
        Executor executor;
        DVN dvn;
        PriceFeed priceFeed;
        Treasury treasury;
        TokenMock lzToken;
    }

    function loadFixtureV1(uint16 eid) internal returns (FixtureV1 memory f) {
        f.eid = eid;
        // deploy endpointV1, sendUln301
        (f.endpointV1, f.sendUln301, f.receiveUln301, f.treasuryFeeHandler) = deployEndpointV1(
            eid,
            Constant.TREASURY_GAS_CAP,
            Constant.TREASURY_GAS_FOR_FEE_CAP
        );
        // deploy priceFee
        f.priceFeed = deployPriceFeed();
        // deploy dvn
        f.dvn = deployDVN(
            eid,
            address(f.sendUln301),
            address(f.receiveUln301),
            address(0),
            address(0),
            address(f.priceFeed)
        );
        // deploy executor
        f.executor = deployExecutor(
            address(0),
            address(f.sendUln301),
            address(f.receiveUln301),
            address(0),
            address(f.priceFeed)
        );
        // deploy treasury
        f.treasury = deployTreasury();
        // deploy LZ token
        f.lzToken = deployTokenMock();

        f.sendUln301.setTreasury(address(f.treasury));
        f.sendUln301.setLzToken(address(f.lzToken));

        f.endpointV1.newVersion(address(f.sendUln301));
        f.endpointV1.newVersion(address(f.receiveUln301));
        f.endpointV1.setDefaultSendVersion(1);
        f.endpointV1.setDefaultReceiveVersion(2);
    }

    function loadFixtureV2(uint32 eid) internal returns (FixtureV2 memory f) {
        f.eid = eid;
        // deploy endpointV2, sendUln302
        (f.endpointV2, f.sendUln302, f.receiveUln302) = deployEndpointV2(
            eid,
            Constant.TREASURY_GAS_CAP,
            Constant.TREASURY_GAS_FOR_FEE_CAP
        );
        // deploy priceFee
        f.priceFeed = deployPriceFeed();
        // deploy dvn
        f.dvn = deployDVN(
            eid,
            address(0),
            address(0),
            address(f.sendUln302),
            address(f.receiveUln302),
            address(f.priceFeed)
        );
        // deploy executor
        f.executor = deployExecutor(
            address(f.endpointV2),
            address(0),
            address(0),
            address(f.sendUln302),
            address(f.priceFeed)
        );
        // deploy treasury
        f.treasury = deployTreasury();
        // deploy LZ token
        f.lzToken = deployTokenMock();

        f.sendUln302.setTreasury(address(f.treasury));

        f.endpointV2.registerLibrary(address(f.sendUln302));
        f.endpointV2.setLzToken(address(f.lzToken));
        f.endpointV2.registerLibrary(address(f.receiveUln302));
    }

    function wireFixtureV1WithRemote(FixtureV1 memory f1, uint32 remoteEid) internal {
        address[] memory dvns = new address[](1);
        dvns[0] = address(f1.dvn);
        UlnConfig memory ulnConfig = UlnConfig(1, uint8(dvns.length), 0, 0, dvns, new address[](0));
        SetDefaultUlnConfigParam[] memory ulnConfigParams = new SetDefaultUlnConfigParam[](1);
        ulnConfigParams[0] = SetDefaultUlnConfigParam(remoteEid, ulnConfig);

        // set send uln config
        {
            f1.sendUln301.setDefaultUlnConfigs(ulnConfigParams);
            f1.sendUln301.setAddressSize(uint16(remoteEid), 20);

            SetDefaultExecutorConfigParam[] memory executorConfigParams = new SetDefaultExecutorConfigParam[](1);
            executorConfigParams[0] = SetDefaultExecutorConfigParam(
                remoteEid,
                ExecutorConfig(1000, address(f1.executor))
            );
            f1.sendUln301.setDefaultExecutorConfigs(executorConfigParams);
        }

        {
            // set receive uln config
            f1.receiveUln301.setDefaultUlnConfigs(ulnConfigParams);
            f1.receiveUln301.setAddressSize(uint16(remoteEid), 20);

            SetDefaultExecutorParam[] memory executorParams = new SetDefaultExecutorParam[](1);
            executorParams[0] = SetDefaultExecutorParam(remoteEid, address(f1.executor));
            f1.receiveUln301.setDefaultExecutors(executorParams);
        }

        IExecutor.DstConfigParam[] memory dstConfigParams = new IExecutor.DstConfigParam[](1);
        dstConfigParams[0] = IExecutor.DstConfigParam({
            dstEid: remoteEid,
            lzReceiveBaseGas: 5000,
            lzComposeBaseGas: 0,
            multiplierBps: 10000,
            floorMarginUSD: 1e10,
            nativeCap: 1 gwei
        });
        f1.executor.setDstConfig(dstConfigParams);
    }

    function wireFixtureV2WithRemote(FixtureV2 memory f2, uint32 remoteEid) internal {
        IExecutor.DstConfigParam[] memory dstConfigParams = new IExecutor.DstConfigParam[](1);
        dstConfigParams[0] = IExecutor.DstConfigParam({
            dstEid: remoteEid,
            lzReceiveBaseGas: 5000,
            lzComposeBaseGas: 0,
            multiplierBps: 10000,
            floorMarginUSD: 1e10,
            nativeCap: 1 gwei
        });
        f2.executor.setDstConfig(dstConfigParams);

        address[] memory dvns = new address[](1);
        dvns[0] = address(f2.dvn);
        UlnConfig memory ulnConfig = UlnConfig(1, uint8(dvns.length), 0, 0, dvns, new address[](0));
        SetDefaultUlnConfigParam[] memory ulnConfigParams = new SetDefaultUlnConfigParam[](1);
        ulnConfigParams[0] = SetDefaultUlnConfigParam(remoteEid, ulnConfig);

        // set send uln config
        SetDefaultExecutorConfigParam[] memory executorConfigParams = new SetDefaultExecutorConfigParam[](1);
        executorConfigParams[0] = SetDefaultExecutorConfigParam(remoteEid, ExecutorConfig(1000, address(f2.executor)));
        f2.sendUln302.setDefaultExecutorConfigs(executorConfigParams);
        f2.sendUln302.setDefaultUlnConfigs(ulnConfigParams);

        // set receive uln config
        f2.receiveUln302.setDefaultUlnConfigs(ulnConfigParams);

        f2.endpointV2.setDefaultSendLibrary(remoteEid, address(f2.sendUln302));
        f2.endpointV2.setDefaultReceiveLibrary(remoteEid, address(f2.receiveUln302), 0);
    }

    function deployEndpointV1(
        uint16 eid,
        uint256 treasuryGasCap,
        uint256 treasuryGasForFeeCap
    ) internal returns (EndpointV1, SendUln301, ReceiveUln301, TreasuryFeeHandler) {
        EndpointV1 endpointV1 = new EndpointV1(eid);
        TreasuryFeeHandler feeHandler = new TreasuryFeeHandler(address(endpointV1));
        SendUln301 sendUln301 = new SendUln301(
            address(endpointV1),
            treasuryGasCap,
            treasuryGasForFeeCap,
            address(new NonceContract(address(endpointV1))),
            eid,
            address(feeHandler)
        );
        ReceiveUln301 receiveUln301 = new ReceiveUln301(address(endpointV1), eid);

        return (endpointV1, sendUln301, receiveUln301, feeHandler);
    }

    function deployEndpointV2(
        uint32 eid,
        uint256 treasuryGasCap,
        uint256 treasuryGasForFeeCap
    ) internal returns (EndpointV2, SendUln302, ReceiveUln302) {
        // deploy endpointV2, sendUln302
        EndpointV2 endpointV2 = new EndpointV2(eid, address(this));
        SendUln302 sendUln302 = new SendUln302(address(endpointV2), treasuryGasCap, treasuryGasForFeeCap);
        ReceiveUln302 receiveUln302 = new ReceiveUln302(address(endpointV2));
        return (endpointV2, sendUln302, receiveUln302);
    }

    function deployPriceFeed() internal returns (PriceFeed) {
        PriceFeed priceFeed = new PriceFeed();
        priceFeed.initialize(address(this));
        return priceFeed;
    }

    function deployDVN(
        uint32 eid,
        address sendUln301,
        address receiveUln301,
        address sendUln302,
        address receiveUln302,
        address priceFeed
    ) internal returns (DVN) {
        address[] memory libs = new address[](4);
        libs[0] = sendUln301;
        libs[1] = receiveUln301;
        libs[2] = sendUln302;
        libs[3] = receiveUln302;
        address[] memory signers = new address[](1);
        signers[0] = address(this);
        address[] memory admins = new address[](1);
        admins[0] = address(this);
        DVN dvn = new DVN(eid, libs, priceFeed, signers, 1, admins);

        IDVN.DstConfigParam[] memory dstConfigParams = new IDVN.DstConfigParam[](1);
        dstConfigParams[0] = IDVN.DstConfigParam({ dstEid: eid, gas: 5000, multiplierBps: 0, floorMarginUSD: 0 });
        dvn.setDstConfig(dstConfigParams);
        DVNFeeLib dvnFeeLib = new DVNFeeLib(1e18);
        dvn.setWorkerFeeLib(address(dvnFeeLib));

        return dvn;
    }

    function deployExecutor(
        address endpointV2,
        address sendUln301,
        address receiveUln301,
        address sendUln302,
        address priceFeed
    ) internal returns (Executor) {
        Executor executor = new Executor();
        ExecutorFeeLib executorFeeLib = new ExecutorFeeLib(1e18);
        {
            address[] memory admins = new address[](1);
            admins[0] = address(this);
            address[] memory libs = new address[](3);
            libs[0] = sendUln301;
            libs[1] = receiveUln301;
            libs[2] = sendUln302;
            executor.initialize(endpointV2, receiveUln301, libs, priceFeed, address(this), admins);
            executor.setWorkerFeeLib(address(executorFeeLib));
        }
        return executor;
    }

    function deployTreasury() internal returns (Treasury) {
        Treasury treasury = new Treasury();
        return treasury;
    }

    function deployTokenMock() internal returns (TokenMock) {
        TokenMock lzToken = new TokenMock();
        return lzToken;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/OApp.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers
// solhint-disable-next-line no-unused-import
import { OAppSender, MessagingFee, MessagingReceipt } from "./OAppSender.sol";
// @dev Import the 'Origin' so it's exposed to OApp implementers
// solhint-disable-next-line no-unused-import
import { OAppReceiver, Origin } from "./OAppReceiver.sol";
import { OAppCore } from "./OAppCore.sol";

/**
 * @title OApp
 * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.
 */
abstract contract OApp is OAppSender, OAppReceiver {
    /**
     * @dev Constructor to initialize the OApp with the provided endpoint and owner.
     * @param _endpoint The address of the LOCAL LayerZero endpoint.
     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.
     */
    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}

    /**
     * @notice Retrieves the OApp version information.
     * @return senderVersion The version of the OAppSender.sol implementation.
     * @return receiverVersion The version of the OAppReceiver.sol implementation.
     */
    function oAppVersion()
        public
        pure
        virtual
        override(OAppSender, OAppReceiver)
        returns (uint64 senderVersion, uint64 receiverVersion)
    {
        return (SENDER_VERSION, RECEIVER_VERSION);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/OAppCore.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { IOAppCore, ILayerZeroEndpointV2 } from "./interfaces/IOAppCore.sol";

/**
 * @title OAppCore
 * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.
 */
abstract contract OAppCore is IOAppCore, Ownable {
    // The LayerZero endpoint associated with the given OApp
    ILayerZeroEndpointV2 public immutable endpoint;

    // Mapping to store peers associated with corresponding endpoints
    mapping(uint32 eid => bytes32 peer) public peers;

    /**
     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.
     * @param _endpoint The address of the LOCAL Layer Zero endpoint.
     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.
     *
     * @dev The delegate typically should be set as the owner of the contract.
     */
    constructor(address _endpoint, address _delegate) {
        endpoint = ILayerZeroEndpointV2(_endpoint);

        if (_delegate == address(0)) revert InvalidDelegate();
        endpoint.setDelegate(_delegate);
    }

    /**
     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.
     * @param _eid The endpoint ID.
     * @param _peer The address of the peer to be associated with the corresponding endpoint.
     *
     * @dev Only the owner/admin of the OApp can call this function.
     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.
     * @dev Set this to bytes32(0) to remove the peer address.
     * @dev Peer is a bytes32 to accommodate non-evm chains.
     */
    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {
        peers[_eid] = _peer;
        emit PeerSet(_eid, _peer);
    }

    /**
     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.
     * ie. the peer is set to bytes32(0).
     * @param _eid The endpoint ID.
     * @return peer The address of the peer associated with the specified endpoint.
     */
    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {
        bytes32 peer = peers[_eid];
        if (peer == bytes32(0)) revert NoPeer(_eid);
        return peer;
    }

    /**
     * @notice Sets the delegate address for the OApp.
     * @param _delegate The address of the delegate to be set.
     *
     * @dev Only the owner/admin of the OApp can call this function.
     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.
     */
    function setDelegate(address _delegate) public onlyOwner {
        endpoint.setDelegate(_delegate);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/OAppReceiver.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { IOAppReceiver, Origin } from "./interfaces/IOAppReceiver.sol";
import { OAppCore } from "./OAppCore.sol";

/**
 * @title OAppReceiver
 * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.
 */
abstract contract OAppReceiver is IOAppReceiver, OAppCore {
    // Custom error message for when the caller is not the registered endpoint/
    error OnlyEndpoint(address addr);

    // @dev The version of the OAppReceiver implementation.
    // @dev Version is bumped when changes are made to this contract.
    uint64 internal constant RECEIVER_VERSION = 1;

    /**
     * @notice Retrieves the OApp version information.
     * @return senderVersion The version of the OAppSender.sol contract.
     * @return receiverVersion The version of the OAppReceiver.sol contract.
     *
     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.
     * ie. this is a RECEIVE only OApp.
     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.
     */
    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {
        return (0, RECEIVER_VERSION);
    }

    /**
     * @notice Retrieves the address responsible for 'sending' composeMsg's to the Endpoint.
     * @return sender The address responsible for 'sending' composeMsg's to the Endpoint.
     *
     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.
     * @dev The default sender IS the OApp implementer.
     */
    function composeMsgSender() public view virtual returns (address sender) {
        return address(this);
    }

    /**
     * @notice Checks if the path initialization is allowed based on the provided origin.
     * @param origin The origin information containing the source endpoint and sender address.
     * @return Whether the path has been initialized.
     *
     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.
     * @dev This defaults to assuming if a peer has been set, its initialized.
     * Can be overridden by the OApp if there is other logic to determine this.
     */
    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {
        return peers[origin.srcEid] == origin.sender;
    }

    /**
     * @notice Retrieves the next nonce for a given source endpoint and sender address.
     * @dev _srcEid The source endpoint ID.
     * @dev _sender The sender address.
     * @return nonce The next nonce.
     *
     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.
     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.
     * @dev This is also enforced by the OApp.
     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.
     */
    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {
        return 0;
    }

    /**
     * @dev Entry point for receiving messages or packets from the endpoint.
     * @param _origin The origin information containing the source endpoint and sender address.
     *  - srcEid: The source chain endpoint ID.
     *  - sender: The sender address on the src chain.
     *  - nonce: The nonce of the message.
     * @param _guid The unique identifier for the received LayerZero message.
     * @param _message The payload of the received message.
     * @param _executor The address of the executor for the received message.
     * @param _extraData Additional arbitrary data provided by the corresponding executor.
     *
     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.
     */
    function lzReceive(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) public payable virtual {
        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.
        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);

        // Ensure that the sender matches the expected peer for the source endpoint.
        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);

        // Call the internal OApp implementation of lzReceive.
        _lzReceive(_origin, _guid, _message, _executor, _extraData);
    }

    /**
     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.
     */
    function _lzReceive(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) internal virtual;
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/OAppSender.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { SafeERC20, IERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { MessagingParams, MessagingFee, MessagingReceipt } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { OAppCore } from "./OAppCore.sol";

/**
 * @title OAppSender
 * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.
 */
abstract contract OAppSender is OAppCore {
    using SafeERC20 for IERC20;

    // Custom error messages
    error NotEnoughNative(uint256 msgValue);
    error LzTokenUnavailable();

    // @dev The version of the OAppSender implementation.
    // @dev Version is bumped when changes are made to this contract.
    uint64 internal constant SENDER_VERSION = 1;

    /**
     * @notice Retrieves the OApp version information.
     * @return senderVersion The version of the OAppSender.sol contract.
     * @return receiverVersion The version of the OAppReceiver.sol contract.
     *
     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.
     * ie. this is a SEND only OApp.
     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions
     */
    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {
        return (SENDER_VERSION, 0);
    }

    /**
     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.
     * @param _dstEid The destination endpoint ID.
     * @param _message The message payload.
     * @param _options Additional options for the message.
     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.
     * @return fee The calculated MessagingFee for the message.
     *      - nativeFee: The native fee for the message.
     *      - lzTokenFee: The LZ token fee for the message.
     */
    function _quote(
        uint32 _dstEid,
        bytes memory _message,
        bytes memory _options,
        bool _payInLzToken
    ) internal view virtual returns (MessagingFee memory fee) {
        return
            endpoint.quote(
                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),
                address(this)
            );
    }

    /**
     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.
     * @param _dstEid The destination endpoint ID.
     * @param _message The message payload.
     * @param _options Additional options for the message.
     * @param _fee The calculated LayerZero fee for the message.
     *      - nativeFee: The native fee.
     *      - lzTokenFee: The lzToken fee.
     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.
     * @return receipt The receipt for the sent message.
     *      - guid: The unique identifier for the sent message.
     *      - nonce: The nonce of the sent message.
     *      - fee: The LayerZero fee incurred for the message.
     */
    function _lzSend(
        uint32 _dstEid,
        bytes memory _message,
        bytes memory _options,
        MessagingFee memory _fee,
        address _refundAddress
    ) internal virtual returns (MessagingReceipt memory receipt) {
        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.
        uint256 messageValue = _payNative(_fee.nativeFee);
        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);

        return
            // solhint-disable-next-line check-send-result
            endpoint.send{ value: messageValue }(
                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),
                _refundAddress
            );
    }

    /**
     * @dev Internal function to pay the native fee associated with the message.
     * @param _nativeFee The native fee to be paid.
     * @return nativeFee The amount of native currency paid.
     *
     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,
     * this will need to be overridden because msg.value would contain multiple lzFees.
     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.
     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.
     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.
     */
    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {
        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);
        return _nativeFee;
    }

    /**
     * @dev Internal function to pay the LZ token fee associated with the message.
     * @param _lzTokenFee The LZ token fee to be paid.
     *
     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.
     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().
     */
    function _payLzToken(uint256 _lzTokenFee) internal virtual {
        // @dev Cannot cache the token because it is not immutable in the endpoint.
        address lzToken = endpoint.lzToken();
        if (lzToken == address(0)) revert LzTokenUnavailable();

        // Pay LZ token fee by sending tokens to the endpoint.
        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/examples/OmniCounter.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { ILayerZeroEndpointV2, MessagingFee, MessagingReceipt, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { ILayerZeroComposer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol";

import { OApp } from "../OApp.sol";
import { OptionsBuilder } from "../libs/OptionsBuilder.sol";
import { OAppPreCrimeSimulator } from "../../precrime/OAppPreCrimeSimulator.sol";

library MsgCodec {
    uint8 internal constant VANILLA_TYPE = 1;
    uint8 internal constant COMPOSED_TYPE = 2;
    uint8 internal constant ABA_TYPE = 3;
    uint8 internal constant COMPOSED_ABA_TYPE = 4;

    uint8 internal constant MSG_TYPE_OFFSET = 0;
    uint8 internal constant SRC_EID_OFFSET = 1;
    uint8 internal constant VALUE_OFFSET = 5;

    function encode(uint8 _type, uint32 _srcEid) internal pure returns (bytes memory) {
        return abi.encodePacked(_type, _srcEid);
    }

    function encode(uint8 _type, uint32 _srcEid, uint256 _value) internal pure returns (bytes memory) {
        return abi.encodePacked(_type, _srcEid, _value);
    }

    function msgType(bytes calldata _message) internal pure returns (uint8) {
        return uint8(bytes1(_message[MSG_TYPE_OFFSET:SRC_EID_OFFSET]));
    }

    function srcEid(bytes calldata _message) internal pure returns (uint32) {
        return uint32(bytes4(_message[SRC_EID_OFFSET:VALUE_OFFSET]));
    }

    function value(bytes calldata _message) internal pure returns (uint256) {
        return uint256(bytes32(_message[VALUE_OFFSET:]));
    }
}

contract OmniCounter is ILayerZeroComposer, OApp, OAppPreCrimeSimulator {
    using MsgCodec for bytes;
    using OptionsBuilder for bytes;

    uint256 public count;
    uint256 public composedCount;

    address public admin;
    uint32 public eid;

    mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)) private maxReceivedNonce;
    bool private orderedNonce;

    // for global assertions
    mapping(uint32 srcEid => uint256 count) public inboundCount;
    mapping(uint32 dstEid => uint256 count) public outboundCount;

    constructor(address _endpoint, address _delegate) OApp(_endpoint, _delegate) {
        admin = msg.sender;
        eid = ILayerZeroEndpointV2(_endpoint).eid();
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "only admin");
        _;
    }

    // -------------------------------
    // Only Admin
    function setAdmin(address _admin) external onlyAdmin {
        admin = _admin;
    }

    function withdraw(address payable _to, uint256 _amount) external onlyAdmin {
        (bool success, ) = _to.call{ value: _amount }("");
        require(success, "OmniCounter: withdraw failed");
    }

    // -------------------------------
    // Send
    function increment(uint32 _eid, uint8 _type, bytes calldata _options) external payable {
        //        bytes memory options = combineOptions(_eid, _type, _options);
        _lzSend(_eid, MsgCodec.encode(_type, eid), _options, MessagingFee(msg.value, 0), payable(msg.sender));
        _incrementOutbound(_eid);
    }

    // this is a broken function to skip incrementing outbound count
    // so that preCrime will fail
    function brokenIncrement(uint32 _eid, uint8 _type, bytes calldata _options) external payable onlyAdmin {
        //        bytes memory options = combineOptions(_eid, _type, _options);
        _lzSend(_eid, MsgCodec.encode(_type, eid), _options, MessagingFee(msg.value, 0), payable(msg.sender));
    }

    function batchIncrement(
        uint32[] calldata _eids,
        uint8[] calldata _types,
        bytes[] calldata _options
    ) external payable {
        require(_eids.length == _options.length && _eids.length == _types.length, "OmniCounter: length mismatch");

        MessagingReceipt memory receipt;
        uint256 providedFee = msg.value;
        for (uint256 i = 0; i < _eids.length; i++) {
            address refundAddress = i == _eids.length - 1 ? msg.sender : address(this);
            uint32 dstEid = _eids[i];
            uint8 msgType = _types[i];
            //            bytes memory options = combineOptions(dstEid, msgType, _options[i]);
            receipt = _lzSend(
                dstEid,
                MsgCodec.encode(msgType, eid),
                _options[i],
                MessagingFee(providedFee, 0),
                payable(refundAddress)
            );
            _incrementOutbound(dstEid);
            providedFee -= receipt.fee.nativeFee;
        }
    }

    // -------------------------------
    // View
    function quote(
        uint32 _eid,
        uint8 _type,
        bytes calldata _options
    ) public view returns (uint256 nativeFee, uint256 lzTokenFee) {
        //        bytes memory options = combineOptions(_eid, _type, _options);
        MessagingFee memory fee = _quote(_eid, MsgCodec.encode(_type, eid), _options, false);
        return (fee.nativeFee, fee.lzTokenFee);
    }

    // @dev enables preCrime simulator
    // @dev routes the call down from the OAppPreCrimeSimulator, and up to the OApp
    function _lzReceiveSimulate(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) internal virtual override {
        _lzReceive(_origin, _guid, _message, _executor, _extraData);
    }

    // -------------------------------
    function _lzReceive(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address /*_executor*/,
        bytes calldata /*_extraData*/
    ) internal override {
        _acceptNonce(_origin.srcEid, _origin.sender, _origin.nonce);
        uint8 messageType = _message.msgType();

        if (messageType == MsgCodec.VANILLA_TYPE) {
            count++;

            //////////////////////////////// IMPORTANT //////////////////////////////////
            /// if you request for msg.value in the options, you should also encode it
            /// into your message and check the value received at destination (example below).
            /// if not, the executor could potentially provide less msg.value than you requested
            /// leading to unintended behavior. Another option is to assert the executor to be
            /// one that you trust.
            /////////////////////////////////////////////////////////////////////////////
            require(msg.value >= _message.value(), "OmniCounter: insufficient value");

            _incrementInbound(_origin.srcEid);
        } else if (messageType == MsgCodec.COMPOSED_TYPE || messageType == MsgCodec.COMPOSED_ABA_TYPE) {
            count++;
            _incrementInbound(_origin.srcEid);
            endpoint.sendCompose(address(this), _guid, 0, _message);
        } else if (messageType == MsgCodec.ABA_TYPE) {
            count++;
            _incrementInbound(_origin.srcEid);

            // send back to the sender
            _incrementOutbound(_origin.srcEid);
            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 10);
            _lzSend(
                _origin.srcEid,
                MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid, 10),
                options,
                MessagingFee(msg.value, 0),
                payable(address(this))
            );
        } else {
            revert("invalid message type");
        }
    }

    function _incrementInbound(uint32 _srcEid) internal {
        inboundCount[_srcEid]++;
    }

    function _incrementOutbound(uint32 _dstEid) internal {
        outboundCount[_dstEid]++;
    }

    function lzCompose(
        address _oApp,
        bytes32 /*_guid*/,
        bytes calldata _message,
        address,
        bytes calldata
    ) external payable override {
        require(_oApp == address(this), "!oApp");
        require(msg.sender == address(endpoint), "!endpoint");

        uint8 msgType = _message.msgType();
        if (msgType == MsgCodec.COMPOSED_TYPE) {
            composedCount += 1;
        } else if (msgType == MsgCodec.COMPOSED_ABA_TYPE) {
            composedCount += 1;

            uint32 srcEid = _message.srcEid();
            _incrementOutbound(srcEid);
            bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
            _lzSend(
                srcEid,
                MsgCodec.encode(MsgCodec.VANILLA_TYPE, eid),
                options,
                MessagingFee(msg.value, 0),
                payable(address(this))
            );
        } else {
            revert("invalid message type");
        }
    }

    // -------------------------------
    // Ordered OApp
    // this demonstrates how to build an app that requires execution nonce ordering
    // normally an app should decide ordered or not on contract construction
    // this is just a demo
    function setOrderedNonce(bool _orderedNonce) external onlyOwner {
        orderedNonce = _orderedNonce;
    }

    function _acceptNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) internal virtual {
        uint64 currentNonce = maxReceivedNonce[_srcEid][_sender];
        if (orderedNonce) {
            require(_nonce == currentNonce + 1, "OApp: invalid nonce");
        }
        // update the max nonce anyway. once the ordered mode is turned on, missing early nonces will be rejected
        if (_nonce > currentNonce) {
            maxReceivedNonce[_srcEid][_sender] = _nonce;
        }
    }

    function nextNonce(uint32 _srcEid, bytes32 _sender) public view virtual override returns (uint64) {
        if (orderedNonce) {
            return maxReceivedNonce[_srcEid][_sender] + 1;
        } else {
            return 0; // path nonce starts from 1. if 0 it means that there is no specific nonce enforcement
        }
    }

    // TODO should override oApp version with added ordered nonce increment
    // a governance function to skip nonce
    function skipInboundNonce(uint32 _srcEid, bytes32 _sender, uint64 _nonce) public virtual onlyOwner {
        endpoint.skip(address(this), _srcEid, _sender, _nonce);
        if (orderedNonce) {
            maxReceivedNonce[_srcEid][_sender]++;
        }
    }

    function isPeer(uint32 _eid, bytes32 _peer) public view override returns (bool) {
        return peers[_eid] == _peer;
    }

    // @dev Batch send requires overriding this function from OAppSender because the msg.value contains multiple fees
    function _payNative(uint256 _nativeFee) internal virtual override returns (uint256 nativeFee) {
        if (msg.value < _nativeFee) revert NotEnoughNative(msg.value);
        return _nativeFee;
    }

    // be able to receive ether
    receive() external payable virtual {}

    fallback() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/examples/OmniCounterPreCrime.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { PreCrime, PreCrimePeer } from "../../precrime/PreCrime.sol";
import { InboundPacket } from "../../precrime/libs/Packet.sol";
import { OmniCounter } from "./OmniCounter.sol";

contract OmniCounterPreCrime is PreCrime {
    struct ChainCount {
        uint32 remoteEid;
        uint256 inboundCount;
        uint256 outboundCount;
    }

    constructor(address _endpoint, address _counter) PreCrime(_endpoint, _counter) {}

    function buildSimulationResult() external view override returns (bytes memory) {
        address payable payableSimulator = payable(simulator);
        OmniCounter counter = OmniCounter(payableSimulator);
        ChainCount[] memory chainCounts = new ChainCount[](preCrimePeers.length);
        for (uint256 i = 0; i < preCrimePeers.length; i++) {
            uint32 remoteEid = preCrimePeers[i].eid;
            chainCounts[i] = ChainCount(remoteEid, counter.inboundCount(remoteEid), counter.outboundCount(remoteEid));
        }
        return abi.encode(chainCounts);
    }

    function _preCrime(
        InboundPacket[] memory /** _packets */,
        uint32[] memory _eids,
        bytes[] memory _simulations
    ) internal view override {
        uint32 localEid = _getLocalEid();
        ChainCount[] memory localChainCounts;

        // find local chain counts
        for (uint256 i = 0; i < _eids.length; i++) {
            if (_eids[i] == localEid) {
                localChainCounts = abi.decode(_simulations[i], (ChainCount[]));
                break;
            }
        }

        // local against remote
        for (uint256 i = 0; i < _eids.length; i++) {
            uint32 remoteEid = _eids[i];
            ChainCount[] memory remoteChainCounts = abi.decode(_simulations[i], (ChainCount[]));
            (uint256 _inboundCount, ) = _findChainCounts(localChainCounts, remoteEid);
            (, uint256 _outboundCount) = _findChainCounts(remoteChainCounts, localEid);
            if (_inboundCount > _outboundCount) {
                revert CrimeFound("inboundCount > outboundCount");
            }
        }
    }

    function _findChainCounts(
        ChainCount[] memory _chainCounts,
        uint32 _remoteEid
    ) internal pure returns (uint256, uint256) {
        for (uint256 i = 0; i < _chainCounts.length; i++) {
            if (_chainCounts[i].remoteEid == _remoteEid) {
                return (_chainCounts[i].inboundCount, _chainCounts[i].outboundCount);
            }
        }
        return (0, 0);
    }

    function _getPreCrimePeers(
        InboundPacket[] memory _packets
    ) internal view override returns (PreCrimePeer[] memory peers) {
        PreCrimePeer[] memory allPeers = preCrimePeers;
        PreCrimePeer[] memory peersTmp = new PreCrimePeer[](_packets.length);

        int256 cursor = -1;
        for (uint256 i = 0; i < _packets.length; i++) {
            uint32 srcEid = _packets[i].origin.srcEid;

            // push src eid & peer
            int256 index = _indexOf(allPeers, srcEid);
            if (index >= 0 && _indexOf(peersTmp, srcEid) < 0) {
                cursor++;
                peersTmp[uint256(cursor)] = allPeers[uint256(index)];
            }
        }
        // copy to return
        if (cursor >= 0) {
            uint256 len = uint256(cursor) + 1;
            peers = new PreCrimePeer[](len);
            for (uint256 i = 0; i < len; i++) {
                peers[i] = peersTmp[i];
            }
        }
    }

    function _indexOf(PreCrimePeer[] memory _peers, uint32 _eid) internal pure returns (int256) {
        for (uint256 i = 0; i < _peers.length; i++) {
            if (_peers[i].eid == _eid) return int256(i);
        }
        return -1;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/interfaces/IOAppComposer.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { ILayerZeroComposer } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroComposer.sol";

/**
 * @title IOAppComposer
 * @dev This interface defines the OApp Composer, allowing developers to inherit only the OApp package without the protocol.
 */
// solhint-disable-next-line no-empty-blocks
interface IOAppComposer is ILayerZeroComposer {}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/interfaces/IOAppCore.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { ILayerZeroEndpointV2 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";

/**
 * @title IOAppCore
 */
interface IOAppCore {
    // Custom error messages
    error OnlyPeer(uint32 eid, bytes32 sender);
    error NoPeer(uint32 eid);
    error InvalidEndpointCall();
    error InvalidDelegate();

    // Event emitted when a peer (OApp) is set for a corresponding endpoint
    event PeerSet(uint32 eid, bytes32 peer);

    /**
     * @notice Retrieves the OApp version information.
     * @return senderVersion The version of the OAppSender.sol contract.
     * @return receiverVersion The version of the OAppReceiver.sol contract.
     */
    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);

    /**
     * @notice Retrieves the LayerZero endpoint associated with the OApp.
     * @return iEndpoint The LayerZero endpoint as an interface.
     */
    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);

    /**
     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.
     * @param _eid The endpoint ID.
     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.
     */
    function peers(uint32 _eid) external view returns (bytes32 peer);

    /**
     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.
     * @param _eid The endpoint ID.
     * @param _peer The address of the peer to be associated with the corresponding endpoint.
     */
    function setPeer(uint32 _eid, bytes32 _peer) external;

    /**
     * @notice Sets the delegate address for the OApp Core.
     * @param _delegate The address of the delegate to be set.
     */
    function setDelegate(address _delegate) external;
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/interfaces/IOAppMsgInspector.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

/**
 * @title IOAppMsgInspector
 * @dev Interface for the OApp Message Inspector, allowing examination of message and options contents.
 */
interface IOAppMsgInspector {
    // Custom error message for inspection failure
    error InspectionFailed(bytes message, bytes options);

    /**
     * @notice Allows the inspector to examine LayerZero message contents and optionally throw a revert if invalid.
     * @param _message The message payload to be inspected.
     * @param _options Additional options or parameters for inspection.
     * @return valid A boolean indicating whether the inspection passed (true) or failed (false).
     *
     * @dev Optionally done as a revert, OR use the boolean provided to handle the failure.
     */
    function inspect(bytes calldata _message, bytes calldata _options) external view returns (bool valid);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/interfaces/IOAppOptionsType3.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

/**
 * @dev Struct representing enforced option parameters.
 */
struct EnforcedOptionParam {
    uint32 eid; // Endpoint ID
    uint16 msgType; // Message Type
    bytes options; // Additional options
}

/**
 * @title IOAppOptionsType3
 * @dev Interface for the OApp with Type 3 Options, allowing the setting and combining of enforced options.
 */
interface IOAppOptionsType3 {
    // Custom error message for invalid options
    error InvalidOptions(bytes options);

    // Event emitted when enforced options are set
    event EnforcedOptionSet(EnforcedOptionParam[] _enforcedOptions);

    /**
     * @notice Sets enforced options for specific endpoint and message type combinations.
     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.
     */
    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) external;

    /**
     * @notice Combines options for a given endpoint and message type.
     * @param _eid The endpoint ID.
     * @param _msgType The OApp message type.
     * @param _extraOptions Additional options passed by the caller.
     * @return options The combination of caller specified options AND enforced options.
     */
    function combineOptions(
        uint32 _eid,
        uint16 _msgType,
        bytes calldata _extraOptions
    ) external view returns (bytes memory options);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/interfaces/IOAppReceiver.sol
================================================================================

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import { ILayerZeroReceiver, Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol";

interface IOAppReceiver is ILayerZeroReceiver {
    /**
     * @notice Retrieves the address responsible for 'sending' composeMsg's to the Endpoint.
     * @return sender The address responsible for 'sending' composeMsg's to the Endpoint.
     *
     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.
     * @dev The default sender IS the OApp implementer.
     */
    function composeMsgSender() external view returns (address sender);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/libs/OAppOptionsType3.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { IOAppOptionsType3, EnforcedOptionParam } from "../interfaces/IOAppOptionsType3.sol";

/**
 * @title OAppOptionsType3
 * @dev Abstract contract implementing the IOAppOptionsType3 interface with type 3 options.
 */
abstract contract OAppOptionsType3 is IOAppOptionsType3, Ownable {
    uint16 internal constant OPTION_TYPE_3 = 3;

    // @dev The "msgType" should be defined in the child contract.
    mapping(uint32 eid => mapping(uint16 msgType => bytes enforcedOption)) public enforcedOptions;

    /**
     * @dev Sets the enforced options for specific endpoint and message type combinations.
     * @param _enforcedOptions An array of EnforcedOptionParam structures specifying enforced options.
     *
     * @dev Only the owner/admin of the OApp can call this function.
     * @dev Provides a way for the OApp to enforce things like paying for PreCrime, AND/OR minimum dst lzReceive gas amounts etc.
     * @dev These enforced options can vary as the potential options/execution on the remote may differ as per the msgType.
     * eg. Amount of lzReceive() gas necessary to deliver a lzCompose() message adds overhead you dont want to pay
     * if you are only making a standard LayerZero message ie. lzReceive() WITHOUT sendCompose().
     */
    function setEnforcedOptions(EnforcedOptionParam[] calldata _enforcedOptions) public virtual onlyOwner {
        for (uint256 i = 0; i < _enforcedOptions.length; i++) {
            // @dev Enforced options are only available for optionType 3, as type 1 and 2 dont support combining.
            _assertOptionsType3(_enforcedOptions[i].options);
            enforcedOptions[_enforcedOptions[i].eid][_enforcedOptions[i].msgType] = _enforcedOptions[i].options;
        }

        emit EnforcedOptionSet(_enforcedOptions);
    }

    /**
     * @notice Combines options for a given endpoint and message type.
     * @param _eid The endpoint ID.
     * @param _msgType The OAPP message type.
     * @param _extraOptions Additional options passed by the caller.
     * @return options The combination of caller specified options AND enforced options.
     *
     * @dev If there is an enforced lzReceive option:
     * - {gasLimit: 200k, msg.value: 1 ether} AND a caller supplies a lzReceive option: {gasLimit: 100k, msg.value: 0.5 ether}
     * - The resulting options will be {gasLimit: 300k, msg.value: 1.5 ether} when the message is executed on the remote lzReceive() function.
     * @dev This presence of duplicated options is handled off-chain in the verifier/executor.
     */
    function combineOptions(
        uint32 _eid,
        uint16 _msgType,
        bytes calldata _extraOptions
    ) public view virtual returns (bytes memory) {
        bytes memory enforced = enforcedOptions[_eid][_msgType];

        // No enforced options, pass whatever the caller supplied, even if it's empty or legacy type 1/2 options.
        if (enforced.length == 0) return _extraOptions;

        // No caller options, return enforced
        if (_extraOptions.length == 0) return enforced;

        // @dev If caller provided _extraOptions, must be type 3 as its the ONLY type that can be combined.
        if (_extraOptions.length >= 2) {
            _assertOptionsType3(_extraOptions);
            // @dev Remove the first 2 bytes containing the type from the _extraOptions and combine with enforced.
            return bytes.concat(enforced, _extraOptions[2:]);
        }

        // No valid set of options was found.
        revert InvalidOptions(_extraOptions);
    }

    /**
     * @dev Internal function to assert that options are of type 3.
     * @param _options The options to be checked.
     */
    function _assertOptionsType3(bytes calldata _options) internal pure virtual {
        uint16 optionsType = uint16(bytes2(_options[0:2]));
        if (optionsType != OPTION_TYPE_3) revert InvalidOptions(_options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oapp/libs/OptionsBuilder.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";

import { ExecutorOptions } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol";
import { DVNOptions } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/DVNOptions.sol";

/**
 * @title OptionsBuilder
 * @dev Library for building and encoding various message options.
 */
library OptionsBuilder {
    using SafeCast for uint256;
    using BytesLib for bytes;

    // Constants for options types
    uint16 internal constant TYPE_1 = 1; // legacy options type 1
    uint16 internal constant TYPE_2 = 2; // legacy options type 2
    uint16 internal constant TYPE_3 = 3;

    // Custom error message
    error InvalidSize(uint256 max, uint256 actual);
    error InvalidOptionType(uint16 optionType);

    // Modifier to ensure only options of type 3 are used
    modifier onlyType3(bytes memory _options) {
        if (_options.toUint16(0) != TYPE_3) revert InvalidOptionType(_options.toUint16(0));
        _;
    }

    /**
     * @dev Creates a new options container with type 3.
     * @return options The newly created options container.
     */
    function newOptions() internal pure returns (bytes memory) {
        return abi.encodePacked(TYPE_3);
    }

    /**
     * @dev Adds an executor LZ receive option to the existing options.
     * @param _options The existing options container.
     * @param _gas The gasLimit used on the lzReceive() function in the OApp.
     * @param _value The msg.value passed to the lzReceive() function in the OApp.
     * @return options The updated options container.
     *
     * @dev When multiples of this option are added, they are summed by the executor
     * eg. if (_gas: 200k, and _value: 1 ether) AND (_gas: 100k, _value: 0.5 ether) are sent in an option to the LayerZeroEndpoint,
     * that becomes (300k, 1.5 ether) when the message is executed on the remote lzReceive() function.
     */
    function addExecutorLzReceiveOption(
        bytes memory _options,
        uint128 _gas,
        uint128 _value
    ) internal pure onlyType3(_options) returns (bytes memory) {
        bytes memory option = ExecutorOptions.encodeLzReceiveOption(_gas, _value);
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZRECEIVE, option);
    }

    /**
     * @dev Adds an executor native drop option to the existing options.
     * @param _options The existing options container.
     * @param _amount The amount for the native value that is airdropped to the 'receiver'.
     * @param _receiver The receiver address for the native drop option.
     * @return options The updated options container.
     *
     * @dev When multiples of this option are added, they are summed by the executor on the remote chain.
     */
    function addExecutorNativeDropOption(
        bytes memory _options,
        uint128 _amount,
        bytes32 _receiver
    ) internal pure onlyType3(_options) returns (bytes memory) {
        bytes memory option = ExecutorOptions.encodeNativeDropOption(_amount, _receiver);
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP, option);
    }

    /**
     * @dev Adds an executor LZ compose option to the existing options.
     * @param _options The existing options container.
     * @param _index The index for the lzCompose() function call.
     * @param _gas The gasLimit for the lzCompose() function call.
     * @param _value The msg.value for the lzCompose() function call.
     * @return options The updated options container.
     *
     * @dev When multiples of this option are added, they are summed PER index by the executor on the remote chain.
     * @dev If the OApp sends N lzCompose calls on the remote, you must provide N incremented indexes starting with 0.
     * ie. When your remote OApp composes (N = 3) messages, you must set this option for index 0,1,2
     */
    function addExecutorLzComposeOption(
        bytes memory _options,
        uint16 _index,
        uint128 _gas,
        uint128 _value
    ) internal pure onlyType3(_options) returns (bytes memory) {
        bytes memory option = ExecutorOptions.encodeLzComposeOption(_index, _gas, _value);
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE, option);
    }

    /**
     * @dev Adds an executor ordered execution option to the existing options.
     * @param _options The existing options container.
     * @return options The updated options container.
     */
    function addExecutorOrderedExecutionOption(
        bytes memory _options
    ) internal pure onlyType3(_options) returns (bytes memory) {
        return addExecutorOption(_options, ExecutorOptions.OPTION_TYPE_ORDERED_EXECUTION, bytes(""));
    }

    /**
     * @dev Adds a DVN pre-crime option to the existing options.
     * @param _options The existing options container.
     * @param _dvnIdx The DVN index for the pre-crime option.
     * @return options The updated options container.
     */
    function addDVNPreCrimeOption(
        bytes memory _options,
        uint8 _dvnIdx
    ) internal pure onlyType3(_options) returns (bytes memory) {
        return addDVNOption(_options, _dvnIdx, DVNOptions.OPTION_TYPE_PRECRIME, bytes(""));
    }

    /**
     * @dev Adds an executor option to the existing options.
     * @param _options The existing options container.
     * @param _optionType The type of the executor option.
     * @param _option The encoded data for the executor option.
     * @return options The updated options container.
     */
    function addExecutorOption(
        bytes memory _options,
        uint8 _optionType,
        bytes memory _option
    ) internal pure onlyType3(_options) returns (bytes memory) {
        return
            abi.encodePacked(
                _options,
                ExecutorOptions.WORKER_ID,
                _option.length.toUint16() + 1, // +1 for optionType
                _optionType,
                _option
            );
    }

    /**
     * @dev Adds a DVN option to the existing options.
     * @param _options The existing options container.
     * @param _dvnIdx The DVN index for the DVN option.
     * @param _optionType The type of the DVN option.
     * @param _option The encoded data for the DVN option.
     * @return options The updated options container.
     */
    function addDVNOption(
        bytes memory _options,
        uint8 _dvnIdx,
        uint8 _optionType,
        bytes memory _option
    ) internal pure onlyType3(_options) returns (bytes memory) {
        return
            abi.encodePacked(
                _options,
                DVNOptions.WORKER_ID,
                _option.length.toUint16() + 2, // +2 for optionType and dvnIdx
                _dvnIdx,
                _optionType,
                _option
            );
    }

    /**
     * @dev Encodes legacy options of type 1.
     * @param _executionGas The gasLimit value passed to lzReceive().
     * @return legacyOptions The encoded legacy options.
     */
    function encodeLegacyOptionsType1(uint256 _executionGas) internal pure returns (bytes memory) {
        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);
        return abi.encodePacked(TYPE_1, _executionGas);
    }

    /**
     * @dev Encodes legacy options of type 2.
     * @param _executionGas The gasLimit value passed to lzReceive().
     * @param _nativeForDst The amount of native air dropped to the receiver.
     * @param _receiver The _nativeForDst receiver address.
     * @return legacyOptions The encoded legacy options of type 2.
     */
    function encodeLegacyOptionsType2(
        uint256 _executionGas,
        uint256 _nativeForDst,
        bytes memory _receiver // @dev Use bytes instead of bytes32 in legacy type 2 for _receiver.
    ) internal pure returns (bytes memory) {
        if (_executionGas > type(uint128).max) revert InvalidSize(type(uint128).max, _executionGas);
        if (_nativeForDst > type(uint128).max) revert InvalidSize(type(uint128).max, _nativeForDst);
        if (_receiver.length > 32) revert InvalidSize(32, _receiver.length);
        return abi.encodePacked(TYPE_2, _executionGas, _nativeForDst, _receiver);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oft/OFT.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { IOFT, OFTCore } from "./OFTCore.sol";

/**
 * @title OFT Contract
 * @dev OFT is an ERC-20 token that extends the functionality of the OFTCore contract.
 */
abstract contract OFT is OFTCore, ERC20 {
    /**
     * @dev Constructor for the OFT contract.
     * @param _name The name of the OFT.
     * @param _symbol The symbol of the OFT.
     * @param _lzEndpoint The LayerZero endpoint address.
     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.
     */
    constructor(
        string memory _name,
        string memory _symbol,
        address _lzEndpoint,
        address _delegate
    ) ERC20(_name, _symbol) OFTCore(decimals(), _lzEndpoint, _delegate) {}

    /**
     * @notice Retrieves interfaceID and the version of the OFT.
     * @return interfaceId The interface ID.
     * @return version The version.
     *
     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.
     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.
     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.
     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)
     */
    function oftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {
        return (type(IOFT).interfaceId, 1);
    }

    /**
     * @dev Retrieves the address of the underlying ERC20 implementation.
     * @return The address of the OFT token.
     *
     * @dev In the case of OFT, address(this) and erc20 are the same contract.
     */
    function token() external view returns (address) {
        return address(this);
    }

    /**
     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.
     * @return requiresApproval Needs approval of the underlying token implementation.
     *
     * @dev In the case of OFT where the contract IS the token, approval is NOT required.
     */
    function approvalRequired() external pure virtual returns (bool) {
        return false;
    }

    /**
     * @dev Burns tokens from the sender's specified balance.
     * @param _amountLD The amount of tokens to send in local decimals.
     * @param _minAmountLD The minimum amount to send in local decimals.
     * @param _dstEid The destination chain ID.
     * @return amountSentLD The amount sent in local decimals.
     * @return amountReceivedLD The amount received in local decimals on the remote.
     */
    function _debit(
        uint256 _amountLD,
        uint256 _minAmountLD,
        uint32 _dstEid
    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {
        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);

        // @dev In NON-default OFT, amountSentLD could be 100, with a 10% fee, the amountReceivedLD amount is 90,
        // therefore amountSentLD CAN differ from amountReceivedLD.

        // @dev Default OFT burns on src.
        _burn(msg.sender, amountSentLD);
    }

    /**
     * @dev Credits tokens to the specified address.
     * @param _to The address to credit the tokens to.
     * @param _amountLD The amount of tokens to credit in local decimals.
     * @dev _srcEid The source chain ID.
     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.
     */
    function _credit(
        address _to,
        uint256 _amountLD,
        uint32 /*_srcEid*/
    ) internal virtual override returns (uint256 amountReceivedLD) {
        // @dev Default OFT mints on dst.
        _mint(_to, _amountLD);
        // @dev In the case of NON-default OFT, the _amountLD MIGHT not be == amountReceivedLD.
        return _amountLD;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oft/OFTAdapter.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { IERC20Metadata, IERC20 } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IOFT, OFTCore } from "./OFTCore.sol";

/**
 * @title OFTAdapter Contract
 * @dev OFTAdapter is a contract that adapts an ERC-20 token to the OFT functionality.
 *
 * @dev For existing ERC20 tokens, this can be used to convert the token to crosschain compatibility.
 * @dev WARNING: ONLY 1 of these should exist for a given global mesh,
 * unless you make a NON-default implementation of OFT and needs to be done very carefully.
 * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.
 * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...
 * a pre/post balance check will need to be done to calculate the amountSentLD/amountReceivedLD.
 */
abstract contract OFTAdapter is OFTCore {
    using SafeERC20 for IERC20;

    IERC20 internal immutable innerToken;

    /**
     * @dev Constructor for the OFTAdapter contract.
     * @param _token The address of the ERC-20 token to be adapted.
     * @param _lzEndpoint The LayerZero endpoint address.
     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.
     */
    constructor(
        address _token,
        address _lzEndpoint,
        address _delegate
    ) OFTCore(IERC20Metadata(_token).decimals(), _lzEndpoint, _delegate) {
        innerToken = IERC20(_token);
    }

    /**
     * @notice Retrieves interfaceID and the version of the OFT.
     * @return interfaceId The interface ID.
     * @return version The version.
     *
     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.
     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.
     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.
     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)
     */
    function oftVersion() external pure virtual returns (bytes4 interfaceId, uint64 version) {
        return (type(IOFT).interfaceId, 1);
    }

    /**
     * @dev Retrieves the address of the underlying ERC20 implementation.
     * @return The address of the adapted ERC-20 token.
     *
     * @dev In the case of OFTAdapter, address(this) and erc20 are NOT the same contract.
     */
    function token() external view returns (address) {
        return address(innerToken);
    }

    /**
     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.
     * @return requiresApproval Needs approval of the underlying token implementation.
     *
     * @dev In the case of default OFTAdapter, approval is required.
     * @dev In non-default OFTAdapter contracts with something like mint and burn privileges, it would NOT need approval.
     */
    function approvalRequired() external pure virtual returns (bool) {
        return true;
    }

    /**
     * @dev Burns tokens from the sender's specified balance, ie. pull method.
     * @param _amountLD The amount of tokens to send in local decimals.
     * @param _minAmountLD The minimum amount to send in local decimals.
     * @param _dstEid The destination chain ID.
     * @return amountSentLD The amount sent in local decimals.
     * @return amountReceivedLD The amount received in local decimals on the remote.
     *
     * @dev msg.sender will need to approve this _amountLD of tokens to be locked inside of the contract.
     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.
     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...
     * a pre/post balance check will need to be done to calculate the amountReceivedLD.
     */
    function _debit(
        uint256 _amountLD,
        uint256 _minAmountLD,
        uint32 _dstEid
    ) internal virtual override returns (uint256 amountSentLD, uint256 amountReceivedLD) {
        (amountSentLD, amountReceivedLD) = _debitView(_amountLD, _minAmountLD, _dstEid);
        // @dev Lock tokens by moving them into this contract from the caller.
        innerToken.safeTransferFrom(msg.sender, address(this), amountSentLD);
    }

    /**
     * @dev Credits tokens to the specified address.
     * @param _to The address to credit the tokens to.
     * @param _amountLD The amount of tokens to credit in local decimals.
     * @dev _srcEid The source chain ID.
     * @return amountReceivedLD The amount of tokens ACTUALLY received in local decimals.
     *
     * @dev WARNING: The default OFTAdapter implementation assumes LOSSLESS transfers, ie. 1 token in, 1 token out.
     * IF the 'innerToken' applies something like a transfer fee, the default will NOT work...
     * a pre/post balance check will need to be done to calculate the amountReceivedLD.
     */
    function _credit(
        address _to,
        uint256 _amountLD,
        uint32 /*_srcEid*/
    ) internal virtual override returns (uint256 amountReceivedLD) {
        // @dev Unlock the tokens and transfer to the recipient.
        innerToken.safeTransfer(_to, _amountLD);
        // @dev In the case of NON-default OFTAdapter, the amountLD MIGHT not be == amountReceivedLD.
        return _amountLD;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oft/OFTCore.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { OApp, Origin } from "../oapp/OApp.sol";
import { OAppOptionsType3 } from "../oapp/libs/OAppOptionsType3.sol";
import { IOAppMsgInspector } from "../oapp/interfaces/IOAppMsgInspector.sol";

import { OAppPreCrimeSimulator } from "../precrime/OAppPreCrimeSimulator.sol";

import { IOFT, SendParam, OFTLimit, OFTReceipt, OFTFeeDetail, MessagingReceipt, MessagingFee } from "./interfaces/IOFT.sol";
import { OFTMsgCodec } from "./libs/OFTMsgCodec.sol";
import { OFTComposeMsgCodec } from "./libs/OFTComposeMsgCodec.sol";

/**
 * @title OFTCore
 * @dev Abstract contract for the OftChain (OFT) token.
 */
abstract contract OFTCore is IOFT, OApp, OAppPreCrimeSimulator, OAppOptionsType3 {
    using OFTMsgCodec for bytes;
    using OFTMsgCodec for bytes32;

    // @notice Provides a conversion rate when swapping between denominations of SD and LD
    //      - shareDecimals == SD == shared Decimals
    //      - localDecimals == LD == local decimals
    // @dev Considers that tokens have different decimal amounts on various chains.
    // @dev eg.
    //  For a token
    //      - locally with 4 decimals --> 1.2345 => uint(12345)
    //      - remotely with 2 decimals --> 1.23 => uint(123)
    //      - The conversion rate would be 10 ** (4 - 2) = 100
    //  @dev If you want to send 1.2345 -> (uint 12345), you CANNOT represent that value on the remote,
    //  you can only display 1.23 -> uint(123).
    //  @dev To preserve the dust that would otherwise be lost on that conversion,
    //  we need to unify a denomination that can be represented on ALL chains inside of the OFT mesh
    uint256 public immutable decimalConversionRate;

    // @notice Msg types that are used to identify the various OFT operations.
    // @dev This can be extended in child contracts for non-default oft operations
    // @dev These values are used in things like combineOptions() in OAppOptionsType3.sol.
    uint16 public constant SEND = 1;
    uint16 public constant SEND_AND_CALL = 2;

    // Address of an optional contract to inspect both 'message' and 'options'
    address public msgInspector;
    event MsgInspectorSet(address inspector);

    /**
     * @dev Constructor.
     * @param _localDecimals The decimals of the token on the local chain (this chain).
     * @param _endpoint The address of the LayerZero endpoint.
     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.
     */
    constructor(uint8 _localDecimals, address _endpoint, address _delegate) OApp(_endpoint, _delegate) {
        if (_localDecimals < sharedDecimals()) revert InvalidLocalDecimals();
        decimalConversionRate = 10 ** (_localDecimals - sharedDecimals());
    }

    /**
     * @dev Retrieves the shared decimals of the OFT.
     * @return The shared decimals of the OFT.
     *
     * @dev Sets an implicit cap on the amount of tokens, over uint64.max() will need some sort of outbound cap / totalSupply cap
     * Lowest common decimal denominator between chains.
     * Defaults to 6 decimal places to provide up to 18,446,744,073,709.551615 units (max uint64).
     * For tokens exceeding this totalSupply(), they will need to override the sharedDecimals function with something smaller.
     * ie. 4 sharedDecimals would be 1,844,674,407,370,955.1615
     */
    function sharedDecimals() public pure virtual returns (uint8) {
        return 6;
    }

    /**
     * @dev Sets the message inspector address for the OFT.
     * @param _msgInspector The address of the message inspector.
     *
     * @dev This is an optional contract that can be used to inspect both 'message' and 'options'.
     * @dev Set it to address(0) to disable it, or set it to a contract address to enable it.
     */
    function setMsgInspector(address _msgInspector) public virtual onlyOwner {
        msgInspector = _msgInspector;
        emit MsgInspectorSet(_msgInspector);
    }

    /**
     * @notice Provides a quote for OFT-related operations.
     * @param _sendParam The parameters for the send operation.
     * @return oftLimit The OFT limit information.
     * @return oftFeeDetails The details of OFT fees.
     * @return oftReceipt The OFT receipt information.
     */
    function quoteOFT(
        SendParam calldata _sendParam
    )
        external
        view
        virtual
        returns (OFTLimit memory oftLimit, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory oftReceipt)
    {
        uint256 minAmountLD = 0; // Unused in the default implementation.
        uint256 maxAmountLD = type(uint64).max; // Unused in the default implementation.
        oftLimit = OFTLimit(minAmountLD, maxAmountLD);

        // Unused in the default implementation; reserved for future complex fee details.
        oftFeeDetails = new OFTFeeDetail[](0);

        // @dev This is the same as the send() operation, but without the actual send.
        // - amountSentLD is the amount in local decimals that would be sent from the sender.
        // - amountReceivedLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.
        // @dev The amountSentLD MIGHT not equal the amount the user actually receives. HOWEVER, the default does.
        (uint256 amountSentLD, uint256 amountReceivedLD) = _debitView(
            _sendParam.amountLD,
            _sendParam.minAmountLD,
            _sendParam.dstEid
        );
        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);
    }

    /**
     * @notice Provides a quote for the send() operation.
     * @param _sendParam The parameters for the send() operation.
     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.
     * @return msgFee The calculated LayerZero messaging fee from the send() operation.
     *
     * @dev MessagingFee: LayerZero msg fee
     *  - nativeFee: The native fee.
     *  - lzTokenFee: The lzToken fee.
     */
    function quoteSend(
        SendParam calldata _sendParam,
        bool _payInLzToken
    ) external view virtual returns (MessagingFee memory msgFee) {
        // @dev mock the amount to receive, this is the same operation used in the send().
        // The quote is as similar as possible to the actual send() operation.
        (, uint256 amountReceivedLD) = _debitView(_sendParam.amountLD, _sendParam.minAmountLD, _sendParam.dstEid);

        // @dev Builds the options and OFT message to quote in the endpoint.
        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);

        // @dev Calculates the LayerZero fee for the send() operation.
        return _quote(_sendParam.dstEid, message, options, _payInLzToken);
    }

    /**
     * @dev Executes the send operation.
     * @param _sendParam The parameters for the send operation.
     * @param _fee The calculated fee for the send() operation.
     *      - nativeFee: The native fee.
     *      - lzTokenFee: The lzToken fee.
     * @param _refundAddress The address to receive any excess funds.
     * @return msgReceipt The receipt for the send operation.
     * @return oftReceipt The OFT receipt information.
     *
     * @dev MessagingReceipt: LayerZero msg receipt
     *  - guid: The unique identifier for the sent message.
     *  - nonce: The nonce of the sent message.
     *  - fee: The LayerZero fee incurred for the message.
     */
    function send(
        SendParam calldata _sendParam,
        MessagingFee calldata _fee,
        address _refundAddress
    ) external payable virtual returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) {
        // @dev Applies the token transfers regarding this send() operation.
        // - amountSentLD is the amount in local decimals that was ACTUALLY sent/debited from the sender.
        // - amountReceivedLD is the amount in local decimals that will be received/credited to the recipient on the remote OFT instance.
        (uint256 amountSentLD, uint256 amountReceivedLD) = _debit(
            _sendParam.amountLD,
            _sendParam.minAmountLD,
            _sendParam.dstEid
        );

        // @dev Builds the options and OFT message to quote in the endpoint.
        (bytes memory message, bytes memory options) = _buildMsgAndOptions(_sendParam, amountReceivedLD);

        // @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.
        msgReceipt = _lzSend(_sendParam.dstEid, message, options, _fee, _refundAddress);
        // @dev Formulate the OFT receipt.
        oftReceipt = OFTReceipt(amountSentLD, amountReceivedLD);

        emit OFTSent(msgReceipt.guid, _sendParam.dstEid, msg.sender, amountSentLD, amountReceivedLD);
    }

    /**
     * @dev Internal function to build the message and options.
     * @param _sendParam The parameters for the send() operation.
     * @param _amountLD The amount in local decimals.
     * @return message The encoded message.
     * @return options The encoded options.
     */
    function _buildMsgAndOptions(
        SendParam calldata _sendParam,
        uint256 _amountLD
    ) internal view virtual returns (bytes memory message, bytes memory options) {
        bool hasCompose;
        // @dev This generated message has the msg.sender encoded into the payload so the remote knows who the caller is.
        (message, hasCompose) = OFTMsgCodec.encode(
            _sendParam.to,
            _toSD(_amountLD),
            // @dev Must be include a non empty bytes if you want to compose, EVEN if you dont need it on the remote.
            // EVEN if you dont require an arbitrary payload to be sent... eg. '0x01'
            _sendParam.composeMsg
        );
        // @dev Change the msg type depending if its composed or not.
        uint16 msgType = hasCompose ? SEND_AND_CALL : SEND;
        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.
        options = combineOptions(_sendParam.dstEid, msgType, _sendParam.extraOptions);

        // @dev Optionally inspect the message and options depending if the OApp owner has set a msg inspector.
        // @dev If it fails inspection, needs to revert in the implementation. ie. does not rely on return boolean
        if (msgInspector != address(0)) IOAppMsgInspector(msgInspector).inspect(message, options);
    }

    /**
     * @dev Internal function to handle the receive on the LayerZero endpoint.
     * @param _origin The origin information.
     *  - srcEid: The source chain endpoint ID.
     *  - sender: The sender address from the src chain.
     *  - nonce: The nonce of the LayerZero message.
     * @param _guid The unique identifier for the received LayerZero message.
     * @param _message The encoded message.
     * @dev _executor The address of the executor.
     * @dev _extraData Additional data.
     */
    function _lzReceive(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address /*_executor*/, // @dev unused in the default implementation.
        bytes calldata /*_extraData*/ // @dev unused in the default implementation.
    ) internal virtual override {
        // @dev The src sending chain doesnt know the address length on this chain (potentially non-evm)
        // Thus everything is bytes32() encoded in flight.
        address toAddress = _message.sendTo().bytes32ToAddress();
        // @dev Credit the amountLD to the recipient and return the ACTUAL amount the recipient received in local decimals
        uint256 amountReceivedLD = _credit(toAddress, _toLD(_message.amountSD()), _origin.srcEid);

        if (_message.isComposed()) {
            // @dev Proprietary composeMsg format for the OFT.
            bytes memory composeMsg = OFTComposeMsgCodec.encode(
                _origin.nonce,
                _origin.srcEid,
                amountReceivedLD,
                _message.composeMsg()
            );

            // @dev Stores the lzCompose payload that will be executed in a separate tx.
            // Standardizes functionality for executing arbitrary contract invocation on some non-evm chains.
            // @dev The off-chain executor will listen and process the msg based on the src-chain-callers compose options passed.
            // @dev The index is used when a OApp needs to compose multiple msgs on lzReceive.
            // For default OFT implementation there is only 1 compose msg per lzReceive, thus its always 0.
            endpoint.sendCompose(toAddress, _guid, 0 /* the index of the composed message*/, composeMsg);
        }

        emit OFTReceived(_guid, _origin.srcEid, toAddress, amountReceivedLD);
    }

    /**
     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.
     * @param _origin The origin information.
     *  - srcEid: The source chain endpoint ID.
     *  - sender: The sender address from the src chain.
     *  - nonce: The nonce of the LayerZero message.
     * @param _guid The unique identifier for the received LayerZero message.
     * @param _message The LayerZero message.
     * @param _executor The address of the off-chain executor.
     * @param _extraData Arbitrary data passed by the msg executor.
     *
     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,
     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.
     */
    function _lzReceiveSimulate(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) internal virtual override {
        _lzReceive(_origin, _guid, _message, _executor, _extraData);
    }

    /**
     * @dev Check if the peer is considered 'trusted' by the OApp.
     * @param _eid The endpoint ID to check.
     * @param _peer The peer to check.
     * @return Whether the peer passed is considered 'trusted' by the OApp.
     *
     * @dev Enables OAppPreCrimeSimulator to check whether a potential Inbound Packet is from a trusted source.
     */
    function isPeer(uint32 _eid, bytes32 _peer) public view virtual override returns (bool) {
        return peers[_eid] == _peer;
    }

    /**
     * @dev Internal function to remove dust from the given local decimal amount.
     * @param _amountLD The amount in local decimals.
     * @return amountLD The amount after removing dust.
     *
     * @dev Prevents the loss of dust when moving amounts between chains with different decimals.
     * @dev eg. uint(123) with a conversion rate of 100 becomes uint(100).
     */
    function _removeDust(uint256 _amountLD) internal view virtual returns (uint256 amountLD) {
        return (_amountLD / decimalConversionRate) * decimalConversionRate;
    }

    /**
     * @dev Internal function to convert an amount from shared decimals into local decimals.
     * @param _amountSD The amount in shared decimals.
     * @return amountLD The amount in local decimals.
     */
    function _toLD(uint64 _amountSD) internal view virtual returns (uint256 amountLD) {
        return _amountSD * decimalConversionRate;
    }

    /**
     * @dev Internal function to convert an amount from local decimals into shared decimals.
     * @param _amountLD The amount in local decimals.
     * @return amountSD The amount in shared decimals.
     */
    function _toSD(uint256 _amountLD) internal view virtual returns (uint64 amountSD) {
        return uint64(_amountLD / decimalConversionRate);
    }

    /**
     * @dev Internal function to mock the amount mutation from a OFT debit() operation.
     * @param _amountLD The amount to send in local decimals.
     * @param _minAmountLD The minimum amount to send in local decimals.
     * @dev _dstEid The destination endpoint ID.
     * @return amountSentLD The amount sent, in local decimals.
     * @return amountReceivedLD The amount to be received on the remote chain, in local decimals.
     *
     * @dev This is where things like fees would be calculated and deducted from the amount to be received on the remote.
     */
    function _debitView(
        uint256 _amountLD,
        uint256 _minAmountLD,
        uint32 /*_dstEid*/
    ) internal view virtual returns (uint256 amountSentLD, uint256 amountReceivedLD) {
        // @dev Remove the dust so nothing is lost on the conversion between chains with different decimals for the token.
        amountSentLD = _removeDust(_amountLD);
        // @dev The amount to send is the same as amount received in the default implementation.
        amountReceivedLD = amountSentLD;

        // @dev Check for slippage.
        if (amountReceivedLD < _minAmountLD) {
            revert SlippageExceeded(amountReceivedLD, _minAmountLD);
        }
    }

    /**
     * @dev Internal function to perform a debit operation.
     * @param _amountLD The amount to send in local decimals.
     * @param _minAmountLD The minimum amount to send in local decimals.
     * @param _dstEid The destination endpoint ID.
     * @return amountSentLD The amount sent in local decimals.
     * @return amountReceivedLD The amount received in local decimals on the remote.
     *
     * @dev Defined here but are intended to be overriden depending on the OFT implementation.
     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.
     */
    function _debit(
        uint256 _amountLD,
        uint256 _minAmountLD,
        uint32 _dstEid
    ) internal virtual returns (uint256 amountSentLD, uint256 amountReceivedLD);

    /**
     * @dev Internal function to perform a credit operation.
     * @param _to The address to credit.
     * @param _amountLD The amount to credit in local decimals.
     * @param _srcEid The source endpoint ID.
     * @return amountReceivedLD The amount ACTUALLY received in local decimals.
     *
     * @dev Defined here but are intended to be overriden depending on the OFT implementation.
     * @dev Depending on OFT implementation the _amountLD could differ from the amountReceivedLD.
     */
    function _credit(
        address _to,
        uint256 _amountLD,
        uint32 _srcEid
    ) internal virtual returns (uint256 amountReceivedLD);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oft/interfaces/IOFT.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { MessagingReceipt, MessagingFee } from "../../oapp/OAppSender.sol";

/**
 * @dev Struct representing token parameters for the OFT send() operation.
 */
struct SendParam {
    uint32 dstEid; // Destination endpoint ID.
    bytes32 to; // Recipient address.
    uint256 amountLD; // Amount to send in local decimals.
    uint256 minAmountLD; // Minimum amount to send in local decimals.
    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.
    bytes composeMsg; // The composed message for the send() operation.
    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.
}

/**
 * @dev Struct representing OFT limit information.
 * @dev These amounts can change dynamically and are up the the specific oft implementation.
 */
struct OFTLimit {
    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.
    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.
}

/**
 * @dev Struct representing OFT receipt information.
 */
struct OFTReceipt {
    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.
    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.
    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.
}

/**
 * @dev Struct representing OFT fee details.
 * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.
 */
struct OFTFeeDetail {
    int256 feeAmountLD; // Amount of the fee in local decimals.
    string description; // Description of the fee.
}

/**
 * @title IOFT
 * @dev Interface for the OftChain (OFT) token.
 * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.
 * @dev This specific interface ID is '0x02e49c2c'.
 */
interface IOFT {
    // Custom error messages
    error InvalidLocalDecimals();
    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);

    // Events
    event OFTSent(
        bytes32 indexed guid, // GUID of the OFT message.
        uint32 dstEid, // Destination Endpoint ID.
        address indexed fromAddress, // Address of the sender on the src chain.
        uint256 amountSentLD, // Amount of tokens sent in local decimals.
        uint256 amountReceivedLD // Amount of tokens received in local decimals.
    );
    event OFTReceived(
        bytes32 indexed guid, // GUID of the OFT message.
        uint32 srcEid, // Source Endpoint ID.
        address indexed toAddress, // Address of the recipient on the dst chain.
        uint256 amountReceivedLD // Amount of tokens received in local decimals.
    );

    /**
     * @notice Retrieves interfaceID and the version of the OFT.
     * @return interfaceId The interface ID.
     * @return version The version.
     *
     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.
     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.
     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.
     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)
     */
    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);

    /**
     * @notice Retrieves the address of the token associated with the OFT.
     * @return token The address of the ERC20 token implementation.
     */
    function token() external view returns (address);

    /**
     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.
     * @return requiresApproval Needs approval of the underlying token implementation.
     *
     * @dev Allows things like wallet implementers to determine integration requirements,
     * without understanding the underlying token implementation.
     */
    function approvalRequired() external view returns (bool);

    /**
     * @notice Retrieves the shared decimals of the OFT.
     * @return sharedDecimals The shared decimals of the OFT.
     */
    function sharedDecimals() external view returns (uint8);

    /**
     * @notice Provides a quote for OFT-related operations.
     * @param _sendParam The parameters for the send operation.
     * @return limit The OFT limit information.
     * @return oftFeeDetails The details of OFT fees.
     * @return receipt The OFT receipt information.
     */
    function quoteOFT(
        SendParam calldata _sendParam
    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);

    /**
     * @notice Provides a quote for the send() operation.
     * @param _sendParam The parameters for the send() operation.
     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.
     * @return fee The calculated LayerZero messaging fee from the send() operation.
     *
     * @dev MessagingFee: LayerZero msg fee
     *  - nativeFee: The native fee.
     *  - lzTokenFee: The lzToken fee.
     */
    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);

    /**
     * @notice Executes the send() operation.
     * @param _sendParam The parameters for the send operation.
     * @param _fee The fee information supplied by the caller.
     *      - nativeFee: The native fee.
     *      - lzTokenFee: The lzToken fee.
     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.
     * @return receipt The LayerZero messaging receipt from the send() operation.
     * @return oftReceipt The OFT receipt information.
     *
     * @dev MessagingReceipt: LayerZero msg receipt
     *  - guid: The unique identifier for the sent message.
     *  - nonce: The nonce of the sent message.
     *  - fee: The LayerZero fee incurred for the message.
     */
    function send(
        SendParam calldata _sendParam,
        MessagingFee calldata _fee,
        address _refundAddress
    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oft/libs/OFTComposeMsgCodec.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

library OFTComposeMsgCodec {
    // Offset constants for decoding composed messages
    uint8 private constant NONCE_OFFSET = 8;
    uint8 private constant SRC_EID_OFFSET = 12;
    uint8 private constant AMOUNT_LD_OFFSET = 44;
    uint8 private constant COMPOSE_FROM_OFFSET = 76;

    /**
     * @dev Encodes a OFT composed message.
     * @param _nonce The nonce value.
     * @param _srcEid The source endpoint ID.
     * @param _amountLD The amount in local decimals.
     * @param _composeMsg The composed message.
     * @return _msg The encoded Composed message.
     */
    function encode(
        uint64 _nonce,
        uint32 _srcEid,
        uint256 _amountLD,
        bytes memory _composeMsg // 0x[composeFrom][composeMsg]
    ) internal pure returns (bytes memory _msg) {
        _msg = abi.encodePacked(_nonce, _srcEid, _amountLD, _composeMsg);
    }

    /**
     * @dev Retrieves the nonce from the composed message.
     * @param _msg The message.
     * @return The nonce value.
     */
    function nonce(bytes calldata _msg) internal pure returns (uint64) {
        return uint64(bytes8(_msg[:NONCE_OFFSET]));
    }

    /**
     * @dev Retrieves the source endpoint ID from the composed message.
     * @param _msg The message.
     * @return The source endpoint ID.
     */
    function srcEid(bytes calldata _msg) internal pure returns (uint32) {
        return uint32(bytes4(_msg[NONCE_OFFSET:SRC_EID_OFFSET]));
    }

    /**
     * @dev Retrieves the amount in local decimals from the composed message.
     * @param _msg The message.
     * @return The amount in local decimals.
     */
    function amountLD(bytes calldata _msg) internal pure returns (uint256) {
        return uint256(bytes32(_msg[SRC_EID_OFFSET:AMOUNT_LD_OFFSET]));
    }

    /**
     * @dev Retrieves the composeFrom value from the composed message.
     * @param _msg The message.
     * @return The composeFrom value.
     */
    function composeFrom(bytes calldata _msg) internal pure returns (bytes32) {
        return bytes32(_msg[AMOUNT_LD_OFFSET:COMPOSE_FROM_OFFSET]);
    }

    /**
     * @dev Retrieves the composed message.
     * @param _msg The message.
     * @return The composed message.
     */
    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {
        return _msg[COMPOSE_FROM_OFFSET:];
    }

    /**
     * @dev Converts an address to bytes32.
     * @param _addr The address to convert.
     * @return The bytes32 representation of the address.
     */
    function addressToBytes32(address _addr) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(_addr)));
    }

    /**
     * @dev Converts bytes32 to an address.
     * @param _b The bytes32 value to convert.
     * @return The address representation of bytes32.
     */
    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {
        return address(uint160(uint256(_b)));
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/oft/libs/OFTMsgCodec.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

library OFTMsgCodec {
    // Offset constants for encoding and decoding OFT messages
    uint8 private constant SEND_TO_OFFSET = 32;
    uint8 private constant SEND_AMOUNT_SD_OFFSET = 40;

    /**
     * @dev Encodes an OFT LayerZero message.
     * @param _sendTo The recipient address.
     * @param _amountShared The amount in shared decimals.
     * @param _composeMsg The composed message.
     * @return _msg The encoded message.
     * @return hasCompose A boolean indicating whether the message has a composed payload.
     */
    function encode(
        bytes32 _sendTo,
        uint64 _amountShared,
        bytes memory _composeMsg
    ) internal view returns (bytes memory _msg, bool hasCompose) {
        hasCompose = _composeMsg.length > 0;
        // @dev Remote chains will want to know the composed function caller ie. msg.sender on the src.
        _msg = hasCompose
            ? abi.encodePacked(_sendTo, _amountShared, addressToBytes32(msg.sender), _composeMsg)
            : abi.encodePacked(_sendTo, _amountShared);
    }

    /**
     * @dev Checks if the OFT message is composed.
     * @param _msg The OFT message.
     * @return A boolean indicating whether the message is composed.
     */
    function isComposed(bytes calldata _msg) internal pure returns (bool) {
        return _msg.length > SEND_AMOUNT_SD_OFFSET;
    }

    /**
     * @dev Retrieves the recipient address from the OFT message.
     * @param _msg The OFT message.
     * @return The recipient address.
     */
    function sendTo(bytes calldata _msg) internal pure returns (bytes32) {
        return bytes32(_msg[:SEND_TO_OFFSET]);
    }

    /**
     * @dev Retrieves the amount in shared decimals from the OFT message.
     * @param _msg The OFT message.
     * @return The amount in shared decimals.
     */
    function amountSD(bytes calldata _msg) internal pure returns (uint64) {
        return uint64(bytes8(_msg[SEND_TO_OFFSET:SEND_AMOUNT_SD_OFFSET]));
    }

    /**
     * @dev Retrieves the composed message from the OFT message.
     * @param _msg The OFT message.
     * @return The composed message.
     */
    function composeMsg(bytes calldata _msg) internal pure returns (bytes memory) {
        return _msg[SEND_AMOUNT_SD_OFFSET:];
    }

    /**
     * @dev Converts an address to bytes32.
     * @param _addr The address to convert.
     * @return The bytes32 representation of the address.
     */
    function addressToBytes32(address _addr) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(_addr)));
    }

    /**
     * @dev Converts bytes32 to an address.
     * @param _b The bytes32 value to convert.
     * @return The address representation of bytes32.
     */
    function bytes32ToAddress(bytes32 _b) internal pure returns (address) {
        return address(uint160(uint256(_b)));
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/precrime/OAppPreCrimeSimulator.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { IPreCrime } from "./interfaces/IPreCrime.sol";
import { IOAppPreCrimeSimulator, InboundPacket, Origin } from "./interfaces/IOAppPreCrimeSimulator.sol";

/**
 * @title OAppPreCrimeSimulator
 * @dev Abstract contract serving as the base for preCrime simulation functionality in an OApp.
 */
abstract contract OAppPreCrimeSimulator is IOAppPreCrimeSimulator, Ownable {
    // The address of the preCrime implementation.
    address public preCrime;

    /**
     * @dev Retrieves the address of the OApp contract.
     * @return The address of the OApp contract.
     *
     * @dev The simulator contract is the base contract for the OApp by default.
     * @dev If the simulator is a separate contract, override this function.
     */
    function oApp() external view virtual returns (address) {
        return address(this);
    }

    /**
     * @dev Sets the preCrime contract address.
     * @param _preCrime The address of the preCrime contract.
     */
    function setPreCrime(address _preCrime) public virtual onlyOwner {
        preCrime = _preCrime;
        emit PreCrimeSet(_preCrime);
    }

    /**
     * @dev Interface for pre-crime simulations. Always reverts at the end with the simulation results.
     * @param _packets An array of InboundPacket objects representing received packets to be delivered.
     *
     * @dev WARNING: MUST revert at the end with the simulation results.
     * @dev Gives the preCrime implementation the ability to mock sending packets to the lzReceive function,
     * WITHOUT actually executing them.
     */
    function lzReceiveAndRevert(InboundPacket[] calldata _packets) public payable virtual {
        for (uint256 i = 0; i < _packets.length; i++) {
            InboundPacket calldata packet = _packets[i];

            // Ignore packets that are not from trusted peers.
            if (!isPeer(packet.origin.srcEid, packet.origin.sender)) continue;

            // @dev Because a verifier is calling this function, it doesnt have access to executor params:
            //  - address _executor
            //  - bytes calldata _extraData
            // preCrime will NOT work for OApps that rely on these two parameters inside of their _lzReceive().
            // They are instead stubbed to default values, address(0) and bytes("")
            // @dev Calling this.lzReceiveSimulate removes ability for assembly return 0 callstack exit,
            // which would cause the revert to be ignored.
            this.lzReceiveSimulate{ value: packet.value }(
                packet.origin,
                packet.guid,
                packet.message,
                packet.executor,
                packet.extraData
            );
        }

        // @dev Revert with the simulation results. msg.sender must implement IPreCrime.buildSimulationResult().
        revert SimulationResult(IPreCrime(msg.sender).buildSimulationResult());
    }

    /**
     * @dev Is effectively an internal function because msg.sender must be address(this).
     * Allows resetting the call stack for 'internal' calls.
     * @param _origin The origin information containing the source endpoint and sender address.
     *  - srcEid: The source chain endpoint ID.
     *  - sender: The sender address on the src chain.
     *  - nonce: The nonce of the message.
     * @param _guid The unique identifier of the packet.
     * @param _message The message payload of the packet.
     * @param _executor The executor address for the packet.
     * @param _extraData Additional data for the packet.
     */
    function lzReceiveSimulate(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) external payable virtual {
        // @dev Ensure ONLY can be called 'internally'.
        if (msg.sender != address(this)) revert OnlySelf();
        _lzReceiveSimulate(_origin, _guid, _message, _executor, _extraData);
    }

    /**
     * @dev Internal function to handle the OAppPreCrimeSimulator simulated receive.
     * @param _origin The origin information.
     *  - srcEid: The source chain endpoint ID.
     *  - sender: The sender address from the src chain.
     *  - nonce: The nonce of the LayerZero message.
     * @param _guid The GUID of the LayerZero message.
     * @param _message The LayerZero message.
     * @param _executor The address of the off-chain executor.
     * @param _extraData Arbitrary data passed by the msg executor.
     *
     * @dev Enables the preCrime simulator to mock sending lzReceive() messages,
     * routes the msg down from the OAppPreCrimeSimulator, and back up to the OAppReceiver.
     */
    function _lzReceiveSimulate(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) internal virtual;

    /**
     * @dev checks if the specified peer is considered 'trusted' by the OApp.
     * @param _eid The endpoint Id to check.
     * @param _peer The peer to check.
     * @return Whether the peer passed is considered 'trusted' by the OApp.
     */
    function isPeer(uint32 _eid, bytes32 _peer) public view virtual returns (bool);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/precrime/PreCrime.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";
import { ILayerZeroEndpointV2 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";

import { IPreCrime, PreCrimePeer } from "./interfaces/IPreCrime.sol";
import { IOAppPreCrimeSimulator } from "./interfaces/IOAppPreCrimeSimulator.sol";
import { InboundPacket, PacketDecoder } from "./libs/Packet.sol";

abstract contract PreCrime is Ownable, IPreCrime {
    using BytesLib for bytes;

    uint16 internal constant CONFIG_VERSION = 2;
    address internal constant OFF_CHAIN_CALLER = address(0xDEAD);

    address internal immutable lzEndpoint;
    address public immutable simulator;
    address public immutable oApp;

    // preCrime config
    uint64 public maxBatchSize;
    PreCrimePeer[] internal preCrimePeers;

    /// @dev getConfig(), simulate() and preCrime() are not view functions because it is more flexible to be able to
    ///      update state for some complex logic. So onlyOffChain() modifier is to make sure they are only called
    ///      by the off-chain.
    modifier onlyOffChain() {
        if (msg.sender != OFF_CHAIN_CALLER) revert OnlyOffChain();
        _;
    }

    constructor(address _endpoint, address _simulator) {
        lzEndpoint = _endpoint;
        simulator = _simulator;
        oApp = IOAppPreCrimeSimulator(_simulator).oApp();
    }

    function setMaxBatchSize(uint64 _maxBatchSize) external onlyOwner {
        maxBatchSize = _maxBatchSize;
    }

    function setPreCrimePeers(PreCrimePeer[] calldata _preCrimePeers) external onlyOwner {
        delete preCrimePeers;
        for (uint256 i = 0; i < _preCrimePeers.length; ++i) {
            preCrimePeers.push(_preCrimePeers[i]);
        }
    }

    function getPreCrimePeers() external view returns (PreCrimePeer[] memory) {
        return preCrimePeers;
    }

    function getConfig(
        bytes[] calldata _packets,
        uint256[] calldata _packetMsgValues
    ) external onlyOffChain returns (bytes memory) {
        bytes memory config = abi.encodePacked(CONFIG_VERSION, maxBatchSize);

        // if no packets, return config with all peers
        PreCrimePeer[] memory peers = _packets.length == 0
            ? preCrimePeers
            : _getPreCrimePeers(PacketDecoder.decode(_packets, _packetMsgValues));

        if (peers.length > 0) {
            uint16 size = uint16(peers.length);
            config = abi.encodePacked(config, size);

            for (uint256 i = 0; i < size; ++i) {
                config = abi.encodePacked(config, peers[i].eid, peers[i].preCrime, peers[i].oApp);
            }
        }

        return config;
    }

    // @dev _packetMsgValues refers to the 'lzReceive' option passed per packet
    function simulate(
        bytes[] calldata _packets,
        uint256[] calldata _packetMsgValues
    ) external payable override onlyOffChain returns (bytes memory) {
        InboundPacket[] memory packets = PacketDecoder.decode(_packets, _packetMsgValues);
        _checkPacketSizeAndOrder(packets);
        return _simulate(packets);
    }

    function preCrime(
        bytes[] calldata _packets,
        uint256[] calldata _packetMsgValues,
        bytes[] calldata _simulations
    ) external onlyOffChain {
        InboundPacket[] memory packets = PacketDecoder.decode(_packets, _packetMsgValues);
        uint32[] memory eids = new uint32[](_simulations.length);
        bytes[] memory simulations = new bytes[](_simulations.length);

        for (uint256 i = 0; i < _simulations.length; ++i) {
            bytes calldata simulation = _simulations[i];
            eids[i] = uint32(bytes4(simulation[0:4]));
            simulations[i] = simulation[4:];
        }
        _checkResultsCompleteness(packets, eids);

        _preCrime(packets, eids, simulations);
    }

    function version() external pure returns (uint64 major, uint8 minor) {
        return (2, 0);
    }

    function _checkResultsCompleteness(InboundPacket[] memory _packets, uint32[] memory _eids) internal {
        // check if all peers result included
        if (_packets.length > 0) {
            PreCrimePeer[] memory peers = _getPreCrimePeers(_packets);
            for (uint256 i = 0; i < peers.length; i++) {
                uint32 expectedEid = peers[i].eid;
                if (!_isContain(_eids, expectedEid)) revert SimulationResultNotFound(expectedEid);
            }
        }

        // check if local result included
        uint32 localEid = _getLocalEid();
        if (!_isContain(_eids, localEid)) revert SimulationResultNotFound(localEid);
    }

    function _isContain(uint32[] memory _array, uint32 _item) internal pure returns (bool) {
        for (uint256 i = 0; i < _array.length; i++) {
            if (_array[i] == _item) return true;
        }
        return false;
    }

    function _checkPacketSizeAndOrder(InboundPacket[] memory _packets) internal view {
        if (_packets.length > maxBatchSize) revert PacketOversize(maxBatchSize, _packets.length);

        // check packets nonce, sequence order
        // packets should group by srcEid and sender, then sort by nonce ascending
        if (_packets.length > 0) {
            uint32 srcEid;
            bytes32 sender;
            uint64 nonce;
            for (uint256 i = 0; i < _packets.length; i++) {
                InboundPacket memory packet = _packets[i];

                // skip if not from trusted peer
                if (!IOAppPreCrimeSimulator(simulator).isPeer(packet.origin.srcEid, packet.origin.sender)) continue;

                // start from a new chain or a new source oApp
                if (packet.origin.srcEid != srcEid || packet.origin.sender != sender) {
                    srcEid = packet.origin.srcEid;
                    sender = packet.origin.sender;
                    nonce = _getInboundNonce(srcEid, sender);
                }
                // TODO ??
                // Wont the nonce order not matter and enforced at the OApp level? the simulation will revert?

                // the following packet's nonce add 1 in order
                if (packet.origin.nonce != ++nonce) revert PacketUnsorted();
            }
        }
    }

    function _simulate(InboundPacket[] memory _packets) internal virtual returns (bytes memory) {
        (bool success, bytes memory returnData) = simulator.call{ value: msg.value }(
            abi.encodeWithSelector(IOAppPreCrimeSimulator.lzReceiveAndRevert.selector, _packets)
        );

        bytes memory result = _parseRevertResult(success, returnData);
        return abi.encodePacked(_getLocalEid(), result); // add localEid at the first of the result
    }

    function _parseRevertResult(bool _success, bytes memory _returnData) internal pure returns (bytes memory result) {
        // should always revert with LzReceiveRevert
        if (_success) revert SimulationFailed("no revert");

        // if not expected selector, bubble up error
        if (bytes4(_returnData) != IOAppPreCrimeSimulator.SimulationResult.selector) {
            revert SimulationFailed(_returnData);
        }

        // Slice the sighash. Remove the selector which is the first 4 bytes
        result = _returnData.slice(4, _returnData.length - 4);
        result = abi.decode(result, (bytes));
    }

    // to be compatible with EndpointV1
    function _getLocalEid() internal view virtual returns (uint32) {
        return ILayerZeroEndpointV2(lzEndpoint).eid();
    }

    // to be compatible with EndpointV1
    function _getInboundNonce(uint32 _srcEid, bytes32 _sender) internal view virtual returns (uint64) {
        return ILayerZeroEndpointV2(lzEndpoint).inboundNonce(oApp, _srcEid, _sender);
    }

    // ----------------- to be implemented -----------------
    function buildSimulationResult() external view virtual override returns (bytes memory);

    function _getPreCrimePeers(InboundPacket[] memory _packets) internal virtual returns (PreCrimePeer[] memory peers);

    function _preCrime(
        InboundPacket[] memory _packets,
        uint32[] memory _eids,
        bytes[] memory _simulations
    ) internal virtual;
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/precrime/extensions/PreCrimeE1.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";

import { ILayerZeroEndpoint } from "@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol";

import { PreCrime } from "../PreCrime.sol";

abstract contract PreCrimeE1 is PreCrime {
    using SafeCast for uint32;

    uint32 internal immutable localEid;

    constructor(uint32 _localEid, address _endpoint, address _simulator) PreCrime(_endpoint, _simulator) {
        localEid = _localEid;
    }

    function _getLocalEid() internal view override returns (uint32) {
        return localEid;
    }

    function _getInboundNonce(uint32 _srcEid, bytes32 _sender) internal view override returns (uint64) {
        bytes memory path = _getPath(_srcEid, _sender);
        return ILayerZeroEndpoint(lzEndpoint).getInboundNonce(_srcEid.toUint16(), path);
    }

    function _getPath(uint32 _srcEid, bytes32 _sender) internal view virtual returns (bytes memory);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

// @dev Import the Origin so it's exposed to OAppPreCrimeSimulator implementers.
// solhint-disable-next-line no-unused-import
import { InboundPacket, Origin } from "../libs/Packet.sol";

/**
 * @title IOAppPreCrimeSimulator Interface
 * @dev Interface for the preCrime simulation functionality in an OApp.
 */
interface IOAppPreCrimeSimulator {
    // @dev simulation result used in PreCrime implementation
    error SimulationResult(bytes result);
    error OnlySelf();

    /**
     * @dev Emitted when the preCrime contract address is set.
     * @param preCrimeAddress The address of the preCrime contract.
     */
    event PreCrimeSet(address preCrimeAddress);

    /**
     * @dev Retrieves the address of the preCrime contract implementation.
     * @return The address of the preCrime contract.
     */
    function preCrime() external view returns (address);

    /**
     * @dev Retrieves the address of the OApp contract.
     * @return The address of the OApp contract.
     */
    function oApp() external view returns (address);

    /**
     * @dev Sets the preCrime contract address.
     * @param _preCrime The address of the preCrime contract.
     */
    function setPreCrime(address _preCrime) external;

    /**
     * @dev Mocks receiving a packet, then reverts with a series of data to infer the state/result.
     * @param _packets An array of LayerZero InboundPacket objects representing received packets.
     */
    function lzReceiveAndRevert(InboundPacket[] calldata _packets) external payable;

    /**
     * @dev checks if the specified peer is considered 'trusted' by the OApp.
     * @param _eid The endpoint Id to check.
     * @param _peer The peer to check.
     * @return Whether the peer passed is considered 'trusted' by the OApp.
     */
    function isPeer(uint32 _eid, bytes32 _peer) external view returns (bool);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/precrime/interfaces/IPreCrime.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;
struct PreCrimePeer {
    uint32 eid;
    bytes32 preCrime;
    bytes32 oApp;
}

// TODO not done yet
interface IPreCrime {
    error OnlyOffChain();

    // for simulate()
    error PacketOversize(uint256 max, uint256 actual);
    error PacketUnsorted();
    error SimulationFailed(bytes reason);

    // for preCrime()
    error SimulationResultNotFound(uint32 eid);
    error InvalidSimulationResult(uint32 eid, bytes reason);
    error CrimeFound(bytes crime);

    function getConfig(bytes[] calldata _packets, uint256[] calldata _packetMsgValues) external returns (bytes memory);

    function simulate(
        bytes[] calldata _packets,
        uint256[] calldata _packetMsgValues
    ) external payable returns (bytes memory);

    function buildSimulationResult() external view returns (bytes memory);

    function preCrime(
        bytes[] calldata _packets,
        uint256[] calldata _packetMsgValues,
        bytes[] calldata _simulations
    ) external;

    function version() external view returns (uint64 major, uint8 minor);
}


================================================================================
File: packages/layerzero-v2/evm/oapp/contracts/precrime/libs/Packet.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";

/**
 * @title InboundPacket
 * @dev Structure representing an inbound packet received by the contract.
 */
struct InboundPacket {
    Origin origin; // Origin information of the packet.
    uint32 dstEid; // Destination endpointId of the packet.
    address receiver; // Receiver address for the packet.
    bytes32 guid; // Unique identifier of the packet.
    uint256 value; // msg.value of the packet.
    address executor; // Executor address for the packet.
    bytes message; // Message payload of the packet.
    bytes extraData; // Additional arbitrary data for the packet.
}

/**
 * @title PacketDecoder
 * @dev Library for decoding LayerZero packets.
 */
library PacketDecoder {
    using PacketV1Codec for bytes;

    /**
     * @dev Decode an inbound packet from the given packet data.
     * @param _packet The packet data to decode.
     * @return packet An InboundPacket struct representing the decoded packet.
     */
    function decode(bytes calldata _packet) internal pure returns (InboundPacket memory packet) {
        packet.origin = Origin(_packet.srcEid(), _packet.sender(), _packet.nonce());
        packet.dstEid = _packet.dstEid();
        packet.receiver = _packet.receiverB20();
        packet.guid = _packet.guid();
        packet.message = _packet.message();
    }

    /**
     * @dev Decode multiple inbound packets from the given packet data and associated message values.
     * @param _packets An array of packet data to decode.
     * @param _packetMsgValues An array of associated message values for each packet.
     * @return packets An array of InboundPacket structs representing the decoded packets.
     */
    function decode(
        bytes[] calldata _packets,
        uint256[] memory _packetMsgValues
    ) internal pure returns (InboundPacket[] memory packets) {
        packets = new InboundPacket[](_packets.length);
        for (uint256 i = 0; i < _packets.length; i++) {
            bytes calldata packet = _packets[i];
            packets[i] = PacketDecoder.decode(packet);
            // @dev Allows the verifier to specify the msg.value that gets passed in lzReceive.
            packets[i].value = _packetMsgValues[i];
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/OFT.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import { OptionsBuilder } from "../contracts/oapp/libs/OptionsBuilder.sol";

import { OFTMock } from "./mocks/OFTMock.sol";
import { MessagingFee, MessagingReceipt } from "../contracts/oft/OFTCore.sol";
import { OFTAdapterMock } from "./mocks/OFTAdapterMock.sol";
import { ERC20Mock } from "./mocks/ERC20Mock.sol";
import { OFTComposerMock } from "./mocks/OFTComposerMock.sol";
import { OFTInspectorMock, IOAppMsgInspector } from "./mocks/OFTInspectorMock.sol";
import { IOAppOptionsType3, EnforcedOptionParam } from "../contracts/oapp/libs/OAppOptionsType3.sol";

import { OFTMsgCodec } from "../contracts/oft/libs/OFTMsgCodec.sol";
import { OFTComposeMsgCodec } from "../contracts/oft/libs/OFTComposeMsgCodec.sol";

import { IOFT, SendParam, OFTReceipt } from "../contracts/oft/interfaces/IOFT.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

import "forge-std/console.sol";
import { TestHelper } from "./TestHelper.sol";

contract OFTTest is TestHelper {
    using OptionsBuilder for bytes;

    uint32 aEid = 1;
    uint32 bEid = 2;
    uint32 cEid = 3;

    OFTMock aOFT;
    OFTMock bOFT;
    OFTAdapterMock cOFTAdapter;
    ERC20Mock cERC20Mock;

    OFTInspectorMock oAppInspector;

    address public userA = address(0x1);
    address public userB = address(0x2);
    address public userC = address(0x3);
    uint256 public initialBalance = 100 ether;

    function setUp() public virtual override {
        vm.deal(userA, 1000 ether);
        vm.deal(userB, 1000 ether);
        vm.deal(userC, 1000 ether);

        super.setUp();
        setUpEndpoints(3, LibraryType.UltraLightNode);

        aOFT = OFTMock(
            _deployOApp(type(OFTMock).creationCode, abi.encode("aOFT", "aOFT", address(endpoints[aEid]), address(this)))
        );

        bOFT = OFTMock(
            _deployOApp(type(OFTMock).creationCode, abi.encode("bOFT", "bOFT", address(endpoints[bEid]), address(this)))
        );

        cERC20Mock = new ERC20Mock("cToken", "cToken");
        cOFTAdapter = OFTAdapterMock(
            _deployOApp(
                type(OFTAdapterMock).creationCode,
                abi.encode(address(cERC20Mock), address(endpoints[cEid]), address(this))
            )
        );

        // config and wire the ofts
        address[] memory ofts = new address[](3);
        ofts[0] = address(aOFT);
        ofts[1] = address(bOFT);
        ofts[2] = address(cOFTAdapter);
        this.wireOApps(ofts);

        // mint tokens
        aOFT.mint(userA, initialBalance);
        bOFT.mint(userB, initialBalance);
        cERC20Mock.mint(userC, initialBalance);

        // deploy a universal inspector, can be used by each oft
        oAppInspector = new OFTInspectorMock();
    }

    function test_constructor() public {
        assertEq(aOFT.owner(), address(this));
        assertEq(bOFT.owner(), address(this));
        assertEq(cOFTAdapter.owner(), address(this));

        assertEq(aOFT.balanceOf(userA), initialBalance);
        assertEq(bOFT.balanceOf(userB), initialBalance);
        assertEq(IERC20(cOFTAdapter.token()).balanceOf(userC), initialBalance);

        assertEq(aOFT.token(), address(aOFT));
        assertEq(bOFT.token(), address(bOFT));
        assertEq(cOFTAdapter.token(), address(cERC20Mock));
    }

    function test_oftVersion() public {
        (bytes4 interfaceId, ) = aOFT.oftVersion();
        bytes4 expectedId = 0x02e49c2c;
        assertEq(interfaceId, expectedId);
    }

    function test_send_oft() public {
        uint256 tokensToSend = 1 ether;
        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        SendParam memory sendParam = SendParam(
            bEid,
            addressToBytes32(userB),
            tokensToSend,
            tokensToSend,
            options,
            "",
            ""
        );
        MessagingFee memory fee = aOFT.quoteSend(sendParam, false);

        assertEq(aOFT.balanceOf(userA), initialBalance);
        assertEq(bOFT.balanceOf(userB), initialBalance);

        vm.prank(userA);
        aOFT.send{ value: fee.nativeFee }(sendParam, fee, payable(address(this)));
        verifyPackets(bEid, addressToBytes32(address(bOFT)));

        assertEq(aOFT.balanceOf(userA), initialBalance - tokensToSend);
        assertEq(bOFT.balanceOf(userB), initialBalance + tokensToSend);
    }

    function test_send_oft_compose_msg() public {
        uint256 tokensToSend = 1 ether;

        OFTComposerMock composer = new OFTComposerMock();

        bytes memory options = OptionsBuilder
            .newOptions()
            .addExecutorLzReceiveOption(200000, 0)
            .addExecutorLzComposeOption(0, 500000, 0);
        bytes memory composeMsg = hex"1234";
        SendParam memory sendParam = SendParam(
            bEid,
            addressToBytes32(address(composer)),
            tokensToSend,
            tokensToSend,
            options,
            composeMsg,
            ""
        );
        MessagingFee memory fee = aOFT.quoteSend(sendParam, false);

        assertEq(aOFT.balanceOf(userA), initialBalance);
        assertEq(bOFT.balanceOf(address(composer)), 0);

        vm.prank(userA);
        (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt) = aOFT.send{ value: fee.nativeFee }(
            sendParam,
            fee,
            payable(address(this))
        );
        verifyPackets(bEid, addressToBytes32(address(bOFT)));

        // lzCompose params
        uint32 dstEid_ = bEid;
        address from_ = address(bOFT);
        bytes memory options_ = options;
        bytes32 guid_ = msgReceipt.guid;
        address to_ = address(composer);
        bytes memory composerMsg_ = OFTComposeMsgCodec.encode(
            msgReceipt.nonce,
            aEid,
            oftReceipt.amountReceivedLD,
            abi.encodePacked(addressToBytes32(userA), composeMsg)
        );
        this.lzCompose(dstEid_, from_, options_, guid_, to_, composerMsg_);

        assertEq(aOFT.balanceOf(userA), initialBalance - tokensToSend);
        assertEq(bOFT.balanceOf(address(composer)), tokensToSend);

        assertEq(composer.from(), from_);
        assertEq(composer.guid(), guid_);
        assertEq(composer.message(), composerMsg_);
        assertEq(composer.executor(), address(this));
        assertEq(composer.extraData(), composerMsg_); // default to setting the extraData to the message as well to test
    }

    function test_oft_compose_codec() public {
        uint64 nonce = 1;
        uint32 srcEid = 2;
        uint256 amountCreditLD = 3;
        bytes memory composeMsg = hex"1234";

        bytes memory message = OFTComposeMsgCodec.encode(
            nonce,
            srcEid,
            amountCreditLD,
            abi.encodePacked(addressToBytes32(msg.sender), composeMsg)
        );
        (uint64 nonce_, uint32 srcEid_, uint256 amountCreditLD_, bytes32 composeFrom_, bytes memory composeMsg_) = this
            .decodeOFTComposeMsgCodec(message);

        assertEq(nonce_, nonce);
        assertEq(srcEid_, srcEid);
        assertEq(amountCreditLD_, amountCreditLD);
        assertEq(composeFrom_, addressToBytes32(msg.sender));
        assertEq(composeMsg_, composeMsg);
    }

    function decodeOFTComposeMsgCodec(
        bytes calldata message
    )
        public
        pure
        returns (uint64 nonce, uint32 srcEid, uint256 amountCreditLD, bytes32 composeFrom, bytes memory composeMsg)
    {
        nonce = OFTComposeMsgCodec.nonce(message);
        srcEid = OFTComposeMsgCodec.srcEid(message);
        amountCreditLD = OFTComposeMsgCodec.amountLD(message);
        composeFrom = OFTComposeMsgCodec.composeFrom(message);
        composeMsg = OFTComposeMsgCodec.composeMsg(message);
    }

    function test_debit_slippage_removeDust() public {
        uint256 amountToSendLD = 1.23456789 ether;
        uint256 minAmountToCreditLD = 1.23456789 ether;
        uint32 dstEid = aEid;

        // remove the dust form the shared decimal conversion
        assertEq(aOFT.removeDust(amountToSendLD), 1.234567 ether);

        vm.expectRevert(
            abi.encodeWithSelector(IOFT.SlippageExceeded.selector, aOFT.removeDust(amountToSendLD), minAmountToCreditLD)
        );
        aOFT.debit(amountToSendLD, minAmountToCreditLD, dstEid);
    }

    function test_debit_slippage_minAmountToCreditLD() public {
        uint256 amountToSendLD = 1 ether;
        uint256 minAmountToCreditLD = 1.00000001 ether;
        uint32 dstEid = aEid;

        vm.expectRevert(abi.encodeWithSelector(IOFT.SlippageExceeded.selector, amountToSendLD, minAmountToCreditLD));
        aOFT.debit(amountToSendLD, minAmountToCreditLD, dstEid);
    }

    function test_toLD() public {
        uint64 amountSD = 1000;
        assertEq(amountSD * aOFT.decimalConversionRate(), aOFT.toLD(uint64(amountSD)));
    }

    function test_toSD() public {
        uint256 amountLD = 1000000;
        assertEq(amountLD / aOFT.decimalConversionRate(), aOFT.toSD(amountLD));
    }

    function test_oft_debit() public {
        uint256 amountToSendLD = 1 ether;
        uint256 minAmountToCreditLD = 1 ether;
        uint32 dstEid = aEid;

        assertEq(aOFT.balanceOf(userA), initialBalance);
        assertEq(aOFT.balanceOf(address(this)), 0);

        vm.prank(userA);
        (uint256 amountDebitedLD, uint256 amountToCreditLD) = aOFT.debit(amountToSendLD, minAmountToCreditLD, dstEid);

        assertEq(amountDebitedLD, amountToSendLD);
        assertEq(amountToCreditLD, amountToSendLD);

        assertEq(aOFT.balanceOf(userA), initialBalance - amountToSendLD);
        assertEq(aOFT.balanceOf(address(this)), 0);
    }

    function test_oft_credit() public {
        uint256 amountToCreditLD = 1 ether;
        uint32 srcEid = aEid;

        assertEq(aOFT.balanceOf(userA), initialBalance);
        assertEq(aOFT.balanceOf(address(this)), 0);

        vm.prank(userA);
        uint256 amountReceived = aOFT.credit(userA, amountToCreditLD, srcEid);

        assertEq(aOFT.balanceOf(userA), initialBalance + amountReceived);
        assertEq(aOFT.balanceOf(address(this)), 0);
    }

    function test_oft_adapter_debit() public {
        uint256 amountToSendLD = 1 ether;
        uint256 minAmountToCreditLD = 1 ether;
        uint32 dstEid = cEid;

        assertEq(cERC20Mock.balanceOf(userC), initialBalance);
        assertEq(cERC20Mock.balanceOf(address(cOFTAdapter)), 0);

        vm.prank(userC);
        vm.expectRevert(
            abi.encodeWithSelector(IOFT.SlippageExceeded.selector, amountToSendLD, minAmountToCreditLD + 1)
        );
        cOFTAdapter.debitView(amountToSendLD, minAmountToCreditLD + 1, dstEid);

        vm.prank(userC);
        cERC20Mock.approve(address(cOFTAdapter), amountToSendLD);
        vm.prank(userC);
        (uint256 amountDebitedLD, uint256 amountToCreditLD) = cOFTAdapter.debit(
            amountToSendLD,
            minAmountToCreditLD,
            dstEid
        );

        assertEq(amountDebitedLD, amountToSendLD);
        assertEq(amountToCreditLD, amountToSendLD);

        assertEq(cERC20Mock.balanceOf(userC), initialBalance - amountToSendLD);
        assertEq(cERC20Mock.balanceOf(address(cOFTAdapter)), amountToSendLD);
    }

    function test_oft_adapter_credit() public {
        uint256 amountToCreditLD = 1 ether;
        uint32 srcEid = cEid;

        assertEq(cERC20Mock.balanceOf(userC), initialBalance);
        assertEq(cERC20Mock.balanceOf(address(cOFTAdapter)), 0);

        vm.prank(userC);
        cERC20Mock.transfer(address(cOFTAdapter), amountToCreditLD);

        uint256 amountReceived = cOFTAdapter.credit(userB, amountToCreditLD, srcEid);

        assertEq(cERC20Mock.balanceOf(userC), initialBalance - amountToCreditLD);
        assertEq(cERC20Mock.balanceOf(address(userB)), amountReceived);
        assertEq(cERC20Mock.balanceOf(address(cOFTAdapter)), 0);
    }

    function decodeOFTMsgCodec(
        bytes calldata message
    ) public pure returns (bool isComposed, bytes32 sendTo, uint64 amountSD, bytes memory composeMsg) {
        isComposed = OFTMsgCodec.isComposed(message);
        sendTo = OFTMsgCodec.sendTo(message);
        amountSD = OFTMsgCodec.amountSD(message);
        composeMsg = OFTMsgCodec.composeMsg(message);
    }

    function test_oft_build_msg() public {
        uint32 dstEid = bEid;
        bytes32 to = addressToBytes32(userA);
        uint256 amountToSendLD = 1.23456789 ether;
        uint256 minAmountToCreditLD = aOFT.removeDust(amountToSendLD);

        // params for buildMsgAndOptions
        bytes memory extraOptions = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        bytes memory composeMsg = hex"1234";
        SendParam memory sendParam = SendParam(
            dstEid,
            to,
            amountToSendLD,
            minAmountToCreditLD,
            extraOptions,
            composeMsg,
            ""
        );
        uint256 amountToCreditLD = minAmountToCreditLD;

        (bytes memory message, ) = aOFT.buildMsgAndOptions(sendParam, amountToCreditLD);

        (bool isComposed_, bytes32 sendTo_, uint64 amountSD_, bytes memory composeMsg_) = this.decodeOFTMsgCodec(
            message
        );

        assertEq(isComposed_, true);
        assertEq(sendTo_, to);
        assertEq(amountSD_, aOFT.toSD(amountToCreditLD));
        bytes memory expectedComposeMsg = abi.encodePacked(addressToBytes32(address(this)), composeMsg);
        assertEq(composeMsg_, expectedComposeMsg);
    }

    function test_oft_build_msg_no_compose_msg() public {
        uint32 dstEid = bEid;
        bytes32 to = addressToBytes32(userA);
        uint256 amountToSendLD = 1.23456789 ether;
        uint256 minAmountToCreditLD = aOFT.removeDust(amountToSendLD);

        // params for buildMsgAndOptions
        bytes memory extraOptions = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        bytes memory composeMsg = "";
        SendParam memory sendParam = SendParam(
            dstEid,
            to,
            amountToSendLD,
            minAmountToCreditLD,
            extraOptions,
            composeMsg,
            ""
        );
        uint256 amountToCreditLD = minAmountToCreditLD;

        (bytes memory message, ) = aOFT.buildMsgAndOptions(sendParam, amountToCreditLD);

        (bool isComposed_, bytes32 sendTo_, uint64 amountSD_, bytes memory composeMsg_) = this.decodeOFTMsgCodec(
            message
        );

        assertEq(isComposed_, false);
        assertEq(sendTo_, to);
        assertEq(amountSD_, aOFT.toSD(amountToCreditLD));
        assertEq(composeMsg_, "");
    }

    function test_set_enforced_options() public {
        uint32 eid = 1;

        bytes memory optionsTypeOne = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        bytes memory optionsTypeTwo = OptionsBuilder.newOptions().addExecutorLzReceiveOption(250000, 0);

        EnforcedOptionParam[] memory enforcedOptions = new EnforcedOptionParam[](2);
        enforcedOptions[0] = EnforcedOptionParam(eid, 1, optionsTypeOne);
        enforcedOptions[1] = EnforcedOptionParam(eid, 2, optionsTypeTwo);

        aOFT.setEnforcedOptions(enforcedOptions);

        assertEq(aOFT.enforcedOptions(eid, 1), optionsTypeOne);
        assertEq(aOFT.enforcedOptions(eid, 2), optionsTypeTwo);
    }

    function test_assert_options_type3_revert() public {
        uint32 eid = 1;
        EnforcedOptionParam[] memory enforcedOptions = new EnforcedOptionParam[](1);

        enforcedOptions[0] = EnforcedOptionParam(eid, 1, hex"0004"); // not type 3
        vm.expectRevert(abi.encodeWithSelector(IOAppOptionsType3.InvalidOptions.selector, hex"0004"));
        aOFT.setEnforcedOptions(enforcedOptions);

        enforcedOptions[0] = EnforcedOptionParam(eid, 1, hex"0002"); // not type 3
        vm.expectRevert(abi.encodeWithSelector(IOAppOptionsType3.InvalidOptions.selector, hex"0002"));
        aOFT.setEnforcedOptions(enforcedOptions);

        enforcedOptions[0] = EnforcedOptionParam(eid, 1, hex"0001"); // not type 3
        vm.expectRevert(abi.encodeWithSelector(IOAppOptionsType3.InvalidOptions.selector, hex"0001"));
        aOFT.setEnforcedOptions(enforcedOptions);

        enforcedOptions[0] = EnforcedOptionParam(eid, 1, hex"0003"); // IS type 3
        aOFT.setEnforcedOptions(enforcedOptions); // doesnt revert cus option type 3
    }

    function test_combine_options() public {
        uint32 eid = 1;
        uint16 msgType = 1;

        bytes memory enforcedOptions = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        EnforcedOptionParam[] memory enforcedOptionsArray = new EnforcedOptionParam[](1);
        enforcedOptionsArray[0] = EnforcedOptionParam(eid, msgType, enforcedOptions);
        aOFT.setEnforcedOptions(enforcedOptionsArray);

        bytes memory extraOptions = OptionsBuilder.newOptions().addExecutorNativeDropOption(
            1.2345 ether,
            addressToBytes32(userA)
        );

        bytes memory expectedOptions = OptionsBuilder
            .newOptions()
            .addExecutorLzReceiveOption(200000, 0)
            .addExecutorNativeDropOption(1.2345 ether, addressToBytes32(userA));

        bytes memory combinedOptions = aOFT.combineOptions(eid, msgType, extraOptions);
        assertEq(combinedOptions, expectedOptions);
    }

    function test_combine_options_no_extra_options() public {
        uint32 eid = 1;
        uint16 msgType = 1;

        bytes memory enforcedOptions = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        EnforcedOptionParam[] memory enforcedOptionsArray = new EnforcedOptionParam[](1);
        enforcedOptionsArray[0] = EnforcedOptionParam(eid, msgType, enforcedOptions);
        aOFT.setEnforcedOptions(enforcedOptionsArray);

        bytes memory expectedOptions = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);

        bytes memory combinedOptions = aOFT.combineOptions(eid, msgType, "");
        assertEq(combinedOptions, expectedOptions);
    }

    function test_combine_options_no_enforced_options() public {
        uint32 eid = 1;
        uint16 msgType = 1;

        bytes memory extraOptions = OptionsBuilder.newOptions().addExecutorNativeDropOption(
            1.2345 ether,
            addressToBytes32(userA)
        );

        bytes memory expectedOptions = OptionsBuilder.newOptions().addExecutorNativeDropOption(
            1.2345 ether,
            addressToBytes32(userA)
        );

        bytes memory combinedOptions = aOFT.combineOptions(eid, msgType, extraOptions);
        assertEq(combinedOptions, expectedOptions);
    }

    function test_oapp_inspector_inspect() public {
        uint32 dstEid = bEid;
        bytes32 to = addressToBytes32(userA);
        uint256 amountToSendLD = 1.23456789 ether;
        uint256 minAmountToCreditLD = aOFT.removeDust(amountToSendLD);

        // params for buildMsgAndOptions
        bytes memory extraOptions = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        bytes memory composeMsg = "";
        SendParam memory sendParam = SendParam(
            dstEid,
            to,
            amountToSendLD,
            minAmountToCreditLD,
            extraOptions,
            composeMsg,
            ""
        );
        uint256 amountToCreditLD = minAmountToCreditLD;

        // doesnt revert
        (bytes memory message, ) = aOFT.buildMsgAndOptions(sendParam, amountToCreditLD);

        // deploy a universal inspector, it automatically reverts
        oAppInspector = new OFTInspectorMock();
        // set the inspector
        aOFT.setMsgInspector(address(oAppInspector));

        // does revert because inspector is set
        vm.expectRevert(abi.encodeWithSelector(IOAppMsgInspector.InspectionFailed.selector, message, extraOptions));
        (message, ) = aOFT.buildMsgAndOptions(sendParam, amountToCreditLD);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/OmniCounter.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.15;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { Errors } from "@layerzerolabs/lz-evm-protocol-v2/contracts/libs/Errors.sol";

import { OptionsBuilder } from "../contracts/oapp/libs/OptionsBuilder.sol";
import { OmniCounter, MsgCodec } from "../contracts/oapp/examples/OmniCounter.sol";
import { OmniCounterPreCrime } from "../contracts/oapp/examples/OmniCounterPreCrime.sol";
import { PreCrimePeer } from "../contracts/precrime/interfaces/IPreCrime.sol";

import { TestHelper } from "./TestHelper.sol";

import "forge-std/console.sol";

contract OmniCounterTest is TestHelper {
    using OptionsBuilder for bytes;

    uint32 aEid = 1;
    uint32 bEid = 2;

    // omnicounter with precrime
    OmniCounter aCounter;
    OmniCounterPreCrime aPreCrime;
    OmniCounter bCounter;
    OmniCounterPreCrime bPreCrime;

    address offchain = address(0xDEAD);

    error CrimeFound(bytes crime);

    function setUp() public virtual override {
        super.setUp();

        setUpEndpoints(2, LibraryType.UltraLightNode);

        address[] memory uas = setupOApps(type(OmniCounter).creationCode, 1, 2);
        aCounter = OmniCounter(payable(uas[0]));
        bCounter = OmniCounter(payable(uas[1]));

        setUpPreCrime();
    }

    function setUpPreCrime() public {
        // set up precrime for aCounter
        aPreCrime = new OmniCounterPreCrime(address(aCounter.endpoint()), address(aCounter));
        aPreCrime.setMaxBatchSize(10);

        PreCrimePeer[] memory aCounterPreCrimePeers = new PreCrimePeer[](1);
        aCounterPreCrimePeers[0] = PreCrimePeer(
            bEid,
            addressToBytes32(address(bPreCrime)),
            addressToBytes32(address(bCounter))
        );
        aPreCrime.setPreCrimePeers(aCounterPreCrimePeers);

        aCounter.setPreCrime(address(aPreCrime));

        // set up precrime for bCounter
        bPreCrime = new OmniCounterPreCrime(address(bCounter.endpoint()), address(bCounter));
        bPreCrime.setMaxBatchSize(10);

        PreCrimePeer[] memory bCounterPreCrimePeers = new PreCrimePeer[](1);
        bCounterPreCrimePeers[0] = PreCrimePeer(
            aEid,
            addressToBytes32(address(aPreCrime)),
            addressToBytes32(address(aCounter))
        );
        bPreCrime.setPreCrimePeers(bCounterPreCrimePeers);

        bCounter.setPreCrime(address(bPreCrime));
    }

    // classic message passing A -> B
    function test_increment() public {
        uint256 counterBefore = bCounter.count();

        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        (uint256 nativeFee, ) = aCounter.quote(bEid, MsgCodec.VANILLA_TYPE, options);
        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.VANILLA_TYPE, options);

        assertEq(bCounter.count(), counterBefore, "shouldn't be increased until packet is verified");

        // verify packet to bCounter manually
        verifyPackets(bEid, addressToBytes32(address(bCounter)));

        assertEq(bCounter.count(), counterBefore + 1, "increment assertion failure");
    }

    function test_batchIncrement() public {
        uint256 counterBefore = bCounter.count();

        uint256 batchSize = 5;
        uint32[] memory eids = new uint32[](batchSize);
        uint8[] memory types = new uint8[](batchSize);
        bytes[] memory options = new bytes[](batchSize);
        bytes memory option = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        uint256 fee;
        for (uint256 i = 0; i < batchSize; i++) {
            eids[i] = bEid;
            types[i] = MsgCodec.VANILLA_TYPE;
            options[i] = option;
            (uint256 nativeFee, ) = aCounter.quote(eids[i], types[i], options[i]);
            fee += nativeFee;
        }

        vm.expectRevert(); // Errors.InvalidAmount
        aCounter.batchIncrement{ value: fee - 1 }(eids, types, options);

        aCounter.batchIncrement{ value: fee }(eids, types, options);
        verifyPackets(bEid, addressToBytes32(address(bCounter)));

        assertEq(bCounter.count(), counterBefore + batchSize, "batchIncrement assertion failure");
    }

    function test_nativeDrop_increment() public {
        uint256 balanceBefore = address(bCounter).balance;

        bytes memory options = OptionsBuilder
            .newOptions()
            .addExecutorLzReceiveOption(200000, 0)
            .addExecutorNativeDropOption(1 gwei, addressToBytes32(address(bCounter)));
        (uint256 nativeFee, ) = aCounter.quote(bEid, MsgCodec.VANILLA_TYPE, options);
        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.VANILLA_TYPE, options);

        // verify packet to bCounter manually
        verifyPackets(bEid, addressToBytes32(address(bCounter)));

        assertEq(address(bCounter).balance, balanceBefore + 1 gwei, "nativeDrop assertion failure");

        // transfer funds out
        address payable receiver = payable(address(0xABCD));

        // withdraw with non admin
        vm.startPrank(receiver);
        vm.expectRevert();
        bCounter.withdraw(receiver, 1 gwei);
        vm.stopPrank();

        // withdraw with admin
        bCounter.withdraw(receiver, 1 gwei);
        assertEq(address(bCounter).balance, 0, "withdraw assertion failure");
        assertEq(receiver.balance, 1 gwei, "withdraw assertion failure");
    }

    // classic message passing A -> B1 -> B2
    function test_lzCompose_increment() public {
        uint256 countBefore = bCounter.count();
        uint256 composedCountBefore = bCounter.composedCount();

        bytes memory options = OptionsBuilder
            .newOptions()
            .addExecutorLzReceiveOption(200000, 0)
            .addExecutorLzComposeOption(0, 200000, 0);
        (uint256 nativeFee, ) = aCounter.quote(bEid, MsgCodec.COMPOSED_TYPE, options);
        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.COMPOSED_TYPE, options);

        verifyPackets(bEid, addressToBytes32(address(bCounter)), 0, address(bCounter));

        assertEq(bCounter.count(), countBefore + 1, "increment B1 assertion failure");
        assertEq(bCounter.composedCount(), composedCountBefore + 1, "increment B2 assertion failure");
    }

    // A -> B -> A
    function test_ABA_increment() public {
        uint256 countABefore = aCounter.count();
        uint256 countBBefore = bCounter.count();

        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(10000000, 10000000);
        (uint256 nativeFee, ) = aCounter.quote(bEid, MsgCodec.ABA_TYPE, options);
        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.ABA_TYPE, options);

        verifyPackets(bEid, addressToBytes32(address(bCounter)));
        assertEq(aCounter.count(), countABefore, "increment A assertion failure");
        assertEq(bCounter.count(), countBBefore + 1, "increment B assertion failure");

        verifyPackets(aEid, addressToBytes32(address(aCounter)));
        assertEq(aCounter.count(), countABefore + 1, "increment A assertion failure");
    }

    // A -> B1 -> B2 -> A
    function test_lzCompose_ABA_increment() public {
        uint256 countABefore = aCounter.count();
        uint256 countBBefore = bCounter.count();
        uint256 composedCountBBefore = bCounter.composedCount();

        bytes memory options = OptionsBuilder
            .newOptions()
            .addExecutorLzReceiveOption(200000, 0)
            .addExecutorLzComposeOption(0, 10000000, 10000000);
        (uint256 nativeFee, ) = aCounter.quote(bEid, MsgCodec.COMPOSED_ABA_TYPE, options);
        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.COMPOSED_ABA_TYPE, options);

        verifyPackets(bEid, addressToBytes32(address(bCounter)), 0, address(bCounter));
        assertEq(bCounter.count(), countBBefore + 1, "increment B1 assertion failure");
        assertEq(bCounter.composedCount(), composedCountBBefore + 1, "increment B2 assertion failure");

        verifyPackets(aEid, addressToBytes32(address(aCounter)));
        assertEq(aCounter.count(), countABefore + 1, "increment A assertion failure");
    }

    function test_omniCounterPreCrime() public {
        bytes memory options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(200000, 0);
        (uint256 nativeFee, ) = aCounter.quote(bEid, MsgCodec.VANILLA_TYPE, options);

        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.VANILLA_TYPE, options);
        aCounter.increment{ value: nativeFee }(bEid, MsgCodec.VANILLA_TYPE, options);
        assertEq(aCounter.outboundCount(bEid), 2, "outboundCount assertion failure");

        // precrime should pass
        bytes[] memory packets = new bytes[](2);
        uint256[] memory packetMsgValues = new uint256[](2);
        bytes memory message = MsgCodec.encode(MsgCodec.VANILLA_TYPE, aEid);
        packets[0] = PacketV1Codec.encode(
            Packet(1, aEid, address(aCounter), bEid, addressToBytes32(address(bCounter)), bytes32(0), message)
        );
        packets[1] = PacketV1Codec.encode(
            Packet(2, aEid, address(aCounter), bEid, addressToBytes32(address(bCounter)), bytes32(0), message)
        );

        vm.startPrank(offchain);

        bytes[] memory simulations = new bytes[](2);
        simulations[0] = aPreCrime.simulate(new bytes[](0), new uint256[](0));
        simulations[1] = bPreCrime.simulate(packets, packetMsgValues);

        bPreCrime.preCrime(packets, packetMsgValues, simulations);

        verifyPackets(bEid, addressToBytes32(address(bCounter)));
        assertEq(bCounter.inboundCount(aEid), 2, "inboundCount assertion failure");

        vm.startPrank(address(this));

        // precrime a broken increment
        aCounter.brokenIncrement{ value: nativeFee }(bEid, MsgCodec.VANILLA_TYPE, options);
        assertEq(aCounter.outboundCount(bEid), 2, "outboundCount assertion failure"); // broken outbound increment

        packets = new bytes[](1);
        packetMsgValues = new uint256[](1);
        packets[0] = PacketV1Codec.encode(
            Packet(3, aEid, address(aCounter), bEid, addressToBytes32(address(bCounter)), bytes32(0), message)
        );

        vm.startPrank(offchain);

        simulations[0] = aPreCrime.simulate(new bytes[](0), new uint256[](0));
        simulations[1] = bPreCrime.simulate(packets, packetMsgValues);

        bytes memory expectedError = abi.encodeWithSelector(CrimeFound.selector, "inboundCount > outboundCount");
        vm.expectRevert(expectedError);

        bPreCrime.preCrime(packets, packetMsgValues, simulations);

        verifyPackets(bEid, addressToBytes32(address(bCounter)));
        assertEq(bCounter.inboundCount(aEid), 3, "inboundCount assertion failure"); // state broken
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/OptionsHelper.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ExecutorOptions } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol";
import { UlnOptions } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/libs/UlnOptions.sol";

contract UlnOptionsMock {
    using UlnOptions for bytes;

    function decode(
        bytes calldata _options
    ) public pure returns (bytes memory executorOptions, bytes memory dvnOptions) {
        return UlnOptions.decode(_options);
    }
}

contract OptionsHelper {
    UlnOptionsMock ulnOptions = new UlnOptionsMock();

    function _parseExecutorLzReceiveOption(bytes memory _options) internal view returns (uint256 gas, uint256 value) {
        (bool exist, bytes memory option) = _getExecutorOptionByOptionType(
            _options,
            ExecutorOptions.OPTION_TYPE_LZRECEIVE
        );
        require(exist, "OptionsHelper: lzReceive option not found");
        (gas, value) = this.decodeLzReceiveOption(option);
    }

    function _parseExecutorNativeDropOption(
        bytes memory _options
    ) internal view returns (uint256 amount, bytes32 receiver) {
        (bool exist, bytes memory option) = _getExecutorOptionByOptionType(
            _options,
            ExecutorOptions.OPTION_TYPE_NATIVE_DROP
        );
        require(exist, "OptionsHelper: nativeDrop option not found");
        (amount, receiver) = this.decodeNativeDropOption(option);
    }

    function _parseExecutorLzComposeOption(
        bytes memory _options
    ) internal view returns (uint16 index, uint256 gas, uint256 value) {
        (bool exist, bytes memory option) = _getExecutorOptionByOptionType(
            _options,
            ExecutorOptions.OPTION_TYPE_LZCOMPOSE
        );
        require(exist, "OptionsHelper: lzCompose option not found");
        return this.decodeLzComposeOption(option);
    }

    function _executorOptionExists(
        bytes memory _options,
        uint8 _executorOptionType
    ) internal view returns (bool exist) {
        (exist, ) = _getExecutorOptionByOptionType(_options, _executorOptionType);
    }

    function _getExecutorOptionByOptionType(
        bytes memory _options,
        uint8 _executorOptionType
    ) internal view returns (bool exist, bytes memory option) {
        (bytes memory executorOpts, ) = ulnOptions.decode(_options);

        uint256 cursor;
        while (cursor < executorOpts.length) {
            (uint8 optionType, bytes memory op, uint256 nextCursor) = this.nextExecutorOption(executorOpts, cursor);
            if (optionType == _executorOptionType) {
                return (true, op);
            }
            cursor = nextCursor;
        }
    }

    function nextExecutorOption(
        bytes calldata _options,
        uint256 _cursor
    ) external pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {
        return ExecutorOptions.nextExecutorOption(_options, _cursor);
    }

    function decodeLzReceiveOption(bytes calldata _option) external pure returns (uint128 gas, uint128 value) {
        return ExecutorOptions.decodeLzReceiveOption(_option);
    }

    function decodeNativeDropOption(bytes calldata _option) external pure returns (uint128 amount, bytes32 receiver) {
        return ExecutorOptions.decodeNativeDropOption(_option);
    }

    function decodeLzComposeOption(
        bytes calldata _option
    ) external pure returns (uint16 index, uint128 gas, uint128 value) {
        return ExecutorOptions.decodeLzComposeOption(_option);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/PreCrimeV2.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.15;

import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";

import { IPreCrime, PreCrimePeer } from "../contracts/precrime/interfaces/IPreCrime.sol";
import { InboundPacket } from "../contracts/precrime/libs/Packet.sol";

import { TestHelper } from "./TestHelper.sol";
import { PreCrimeV2Mock } from "./mocks/PreCrimeV2Mock.sol";
import { PreCrimeV2SimulatorMock } from "./mocks/PreCrimeV2SimulatorMock.sol";

import "forge-std/console.sol";

contract PreCrimeV2Test is TestHelper {
    uint16 constant CONFIG_VERSION = 2;
    uint64 constant MAX_BATCH_SIZE = 4;
    address constant OFF_CHAIN = address(0xDEAD);

    PreCrimeV2Mock preCrime;
    PreCrimeV2SimulatorMock simulator;

    PreCrimePeer[] preCrimePeers;

    function setUp() public override {
        super.setUp();

        setUpEndpoints(1, LibraryType.SimpleMessageLib);

        simulator = new PreCrimeV2SimulatorMock();
        preCrime = new PreCrimeV2Mock(address(endpoints[1]), address(simulator));

        preCrimePeers.push(PreCrimePeer(2, bytes32(uint256(22)), bytes32(uint256(2))));
        preCrimePeers.push(PreCrimePeer(3, bytes32(uint256(33)), bytes32(uint256(3))));

        preCrime.setPreCrimePeers(preCrimePeers);
        preCrime.setMaxBatchSize(MAX_BATCH_SIZE);
    }

    function test_getConfig() public {
        uint256[] memory packetMsgValues = new uint256[](1);

        // return config with all peers if no packet
        vm.startPrank(OFF_CHAIN);
        bytes memory config = preCrime.getConfig(new bytes[](0), packetMsgValues);
        bytes memory expectedConfig = abi.encodePacked(CONFIG_VERSION, MAX_BATCH_SIZE, _encodePeers(preCrimePeers));
        assertEq(config, expectedConfig);

        // return config without peers if packet from untrusted peer
        bytes[] memory packets = _buildPacket(2, bytes32(0), 1, 1); // untrusted peer
        config = preCrime.getConfig(packets, packetMsgValues);
        expectedConfig = abi.encodePacked(CONFIG_VERSION, MAX_BATCH_SIZE);
        assertEq(config, expectedConfig);

        // return config with peers if packet from trusted peer
        packets = _buildPacket(2, bytes32(uint256(2)), 1, 1); // trusted peer
        config = preCrime.getConfig(packets, packetMsgValues);
        expectedConfig = abi.encodePacked(CONFIG_VERSION, MAX_BATCH_SIZE, _encodePeers(preCrimePeers));
        assertEq(config, expectedConfig);
    }

    function test_simulate_packetOverSize() public {
        uint256[] memory packetMsgValues = new uint256[](5);
        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, 5); // too many packets
        vm.startPrank(OFF_CHAIN);
        bytes memory expectedError = abi.encodeWithSelector(IPreCrime.PacketOversize.selector, 4, 5);
        vm.expectRevert(expectedError);
        preCrime.simulate(packets, packetMsgValues);
    }

    function test_simulate_packetUnsorted() public {
        uint256[] memory packetMsgValues = new uint256[](4);
        bytes[] memory unsortedPackets = new bytes[](4);
        unsortedPackets[0] = _buildPacket(2, bytes32(uint256(2)), 1, 1)[0];
        unsortedPackets[1] = _buildPacket(3, bytes32(uint256(3)), 1, 1)[0]; // unsorted
        unsortedPackets[2] = _buildPacket(2, bytes32(uint256(2)), 2, 1)[0];
        unsortedPackets[3] = _buildPacket(3, bytes32(uint256(4)), 1, 1)[0]; // untrested peer, but skipped

        vm.startPrank(OFF_CHAIN);
        bytes memory expectedError = abi.encodeWithSelector(IPreCrime.PacketUnsorted.selector);
        vm.expectRevert(expectedError);
        preCrime.simulate(unsortedPackets, packetMsgValues);
    }

    function test_simulate_failed() public {
        // empty packetMsgValues to be reused
        uint256[] memory packetMsgValues = new uint256[](1);
        bytes[] memory packets = _buildPacket(0, bytes32(0), 1, 1); // invalid packet and simulation failed
        vm.startPrank(OFF_CHAIN);
        bytes memory expectedError = abi.encodeWithSelector(
            IPreCrime.SimulationFailed.selector,
            abi.encodeWithSelector(PreCrimeV2SimulatorMock.InvalidEid.selector)
        );
        vm.expectRevert(expectedError);
        preCrime.simulate(packets, packetMsgValues);
    }

    function test_simulate() public {
        uint256[] memory packetMsgValues = new uint256[](4);
        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, 2);
        packets = _appendPackets(packets, _buildPacket(3, bytes32(uint256(3)), 1, 2));

        vm.startPrank(OFF_CHAIN);
        bytes memory result = preCrime.simulate(packets, packetMsgValues);
        bytes memory expectedResult = abi.encodePacked(uint32(1), uint256(4)); // receive 4 packets
        assertEq(result, expectedResult);
    }

    function test_preCrime_simulationResultNotFound() public {
        uint256[] memory packetMsgValues = new uint256[](1);
        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, 1);

        // result of eid 3 not found
        bytes[] memory results = new bytes[](2);
        results[0] = abi.encodePacked(uint32(1), uint256(1));
        results[1] = abi.encodePacked(uint32(2), uint256(1));

        vm.startPrank(OFF_CHAIN);
        bytes memory expectedError = abi.encodeWithSelector(IPreCrime.SimulationResultNotFound.selector, 3);
        vm.expectRevert(expectedError);
        preCrime.preCrime(packets, packetMsgValues, results);

        // result of eid 1 (local result) not found
        results[0] = abi.encodePacked(uint32(2), uint256(1));
        results[1] = abi.encodePacked(uint32(3), uint256(1));

        expectedError = abi.encodeWithSelector(IPreCrime.SimulationResultNotFound.selector, 1);
        vm.expectRevert(expectedError);
        preCrime.preCrime(packets, packetMsgValues, results);
    }

    function test_preCrime() public {
        uint256[] memory packetMsgValues = new uint256[](1);
        bytes[] memory packets = _buildPacket(2, bytes32(uint256(2)), 1, 1);

        bytes[] memory results = new bytes[](3);
        results[0] = abi.encodePacked(uint32(1), uint256(1));
        results[1] = abi.encodePacked(uint32(2), uint256(2));
        results[2] = abi.encodePacked(uint32(3), uint256(3));

        vm.startPrank(OFF_CHAIN);
        preCrime.preCrime(packets, packetMsgValues, results);

        // check internal state of preCrime
        assertEq(preCrime.eids(0), 1);
        assertEq(preCrime.eids(1), 2);
        assertEq(preCrime.eids(2), 3);
        assertEq(preCrime.results(0), abi.encode(1));
        assertEq(preCrime.results(1), abi.encode(2));
        assertEq(preCrime.results(2), abi.encode(3));
    }

    function _buildPacket(
        uint32 _srcEid,
        bytes32 _sender,
        uint64 _nonce,
        uint256 _packetNum
    ) internal view returns (bytes[] memory) {
        bytes[] memory packets = new bytes[](_packetNum);
        for (uint256 i = 0; i < _packetNum; ++i) {
            InboundPacket memory packet = InboundPacket(
                Origin(_srcEid, _sender, _nonce + uint64(i)),
                1,
                preCrime.oApp(),
                bytes32(0),
                0,
                address(0),
                "",
                ""
            );
            packets[i] = _encodePacket(packet);
        }
        return packets;
    }

    function _encodePacket(InboundPacket memory _packet) internal pure returns (bytes memory encodedPacket) {
        encodedPacket = abi.encodePacked(
            uint8(1),
            _packet.origin.nonce,
            _packet.origin.srcEid,
            _packet.origin.sender,
            _packet.dstEid,
            bytes32(uint256(uint160(_packet.receiver))),
            _packet.guid,
            _packet.value,
            _packet.message
        );
    }

    function _appendPackets(
        bytes[] memory _packets,
        bytes[] memory _newPackets
    ) internal pure returns (bytes[] memory) {
        bytes[] memory packets = new bytes[](_packets.length + _newPackets.length);
        for (uint256 i = 0; i < _packets.length; ++i) {
            packets[i] = _packets[i];
        }
        for (uint256 i = 0; i < _newPackets.length; ++i) {
            packets[_packets.length + i] = _newPackets[i];
        }
        return packets;
    }

    function _encodePeers(PreCrimePeer[] memory _peers) internal pure returns (bytes memory) {
        bytes memory peers = abi.encodePacked(uint16(_peers.length));
        for (uint256 i = 0; i < _peers.length; ++i) {
            peers = abi.encodePacked(peers, _peers[i].eid, _peers[i].preCrime, _peers[i].oApp);
        }
        return peers;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/TestHelper.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.18;

import { Test } from "forge-std/Test.sol";
import { DoubleEndedQueue } from "@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol";

import { UlnConfig, SetDefaultUlnConfigParam } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/UlnBase.sol";
import { SetDefaultExecutorConfigParam, ExecutorConfig } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/SendLibBase.sol";
import { ReceiveUln302 } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln302/ReceiveUln302.sol";
import { IDVN } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/IDVN.sol";
import { DVN, ExecuteParam } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/DVN.sol";
import { DVNFeeLib } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/dvn/DVNFeeLib.sol";
import { IExecutor } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/IExecutor.sol";
import { Executor } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/Executor.sol";
import { PriceFeed } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/PriceFeed.sol";
import { ILayerZeroPriceFeed } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/interfaces/ILayerZeroPriceFeed.sol";
import { IReceiveUlnE2 } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/interfaces/IReceiveUlnE2.sol";
import { ReceiveUln302 } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln302/ReceiveUln302.sol";
import { IMessageLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol";
import { EndpointV2 } from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol";
import { ExecutorOptions } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/ExecutorOptions.sol";
import { PacketV1Codec } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol";
import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";

import { OApp } from "../contracts/oapp/OApp.sol";
import { OptionsBuilder } from "../contracts/oapp/libs/OptionsBuilder.sol";

import { OptionsHelper } from "./OptionsHelper.sol";
import { SendUln302Mock as SendUln302 } from "./mocks/SendUln302Mock.sol";
import { SimpleMessageLibMock } from "./mocks/SimpleMessageLibMock.sol";
import "./mocks/ExecutorFeeLibMock.sol";

contract TestHelper is Test, OptionsHelper {
    using OptionsBuilder for bytes;

    enum LibraryType {
        UltraLightNode,
        SimpleMessageLib
    }

    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;
    using PacketV1Codec for bytes;

    mapping(uint32 => mapping(bytes32 => DoubleEndedQueue.Bytes32Deque)) packetsQueue; // dstEid => dstUA => guids queue
    mapping(bytes32 => bytes) packets; // guid => packet bytes
    mapping(bytes32 => bytes) optionsLookup; // guid => options

    mapping(uint32 => address) endpoints; // eid => endpoint

    uint256 public constant TREASURY_GAS_CAP = 1000000000000;
    uint256 public constant TREASURY_GAS_FOR_FEE_CAP = 100000;

    uint128 public executorValueCap = 0.1 ether;

    function setUp() public virtual {}

    /**
     * @dev set executorValueCap if more than 0.1 ether is necessary
     * @dev this must be called prior to setUpEndpoints() if the value is to be used
     * @param _valueCap amount executor can pass as msg.value to lzReceive()
     */
    function setExecutorValueCap(uint128 _valueCap) public {
        executorValueCap = _valueCap;
    }

    /**
     * @dev setup the endpoints
     * @param _endpointNum num of endpoints
     */
    function setUpEndpoints(uint8 _endpointNum, LibraryType _libraryType) public {
        EndpointV2[] memory endpointList = new EndpointV2[](_endpointNum);
        uint32[] memory eidList = new uint32[](_endpointNum);

        // deploy _excludedContracts
        for (uint8 i = 0; i < _endpointNum; i++) {
            uint32 eid = i + 1;
            eidList[i] = eid;
            endpointList[i] = new EndpointV2(eid, address(this));
            registerEndpoint(endpointList[i]);
        }

        // deploy
        address[] memory sendLibs = new address[](_endpointNum);
        address[] memory receiveLibs = new address[](_endpointNum);

        address[] memory signers = new address[](1);
        signers[0] = vm.addr(1);

        PriceFeed priceFeed = new PriceFeed();
        priceFeed.initialize(address(this));

        for (uint8 i = 0; i < _endpointNum; i++) {
            if (_libraryType == LibraryType.UltraLightNode) {
                address endpointAddr = address(endpointList[i]);

                SendUln302 sendUln;
                ReceiveUln302 receiveUln;
                {
                    sendUln = new SendUln302(payable(this), endpointAddr, TREASURY_GAS_CAP, TREASURY_GAS_FOR_FEE_CAP);
                    receiveUln = new ReceiveUln302(endpointAddr);
                    endpointList[i].registerLibrary(address(sendUln));
                    endpointList[i].registerLibrary(address(receiveUln));
                    sendLibs[i] = address(sendUln);
                    receiveLibs[i] = address(receiveUln);
                }

                Executor executor = new Executor();
                DVN dvn;
                {
                    address[] memory admins = new address[](1);
                    admins[0] = address(this);

                    address[] memory messageLibs = new address[](2);
                    messageLibs[0] = address(sendUln);
                    messageLibs[1] = address(receiveUln);

                    executor.initialize(
                        endpointAddr,
                        address(0x0),
                        messageLibs,
                        address(priceFeed),
                        address(this),
                        admins
                    );
                    ExecutorFeeLib executorLib = new ExecutorFeeLibMock();
                    executor.setWorkerFeeLib(address(executorLib));

                    dvn = new DVN(i + 1, messageLibs, address(priceFeed), signers, 1, admins);
                    DVNFeeLib dvnLib = new DVNFeeLib(1e18);
                    dvn.setWorkerFeeLib(address(dvnLib));
                }

                uint32 endpointNum = _endpointNum;
                IExecutor.DstConfigParam[] memory dstConfigParams = new IExecutor.DstConfigParam[](endpointNum);
                IDVN.DstConfigParam[] memory dvnConfigParams = new IDVN.DstConfigParam[](endpointNum);
                for (uint8 j = 0; j < endpointNum; j++) {
                    if (i == j) continue;
                    uint32 dstEid = j + 1;

                    address[] memory defaultDVNs = new address[](1);
                    address[] memory optionalDVNs = new address[](0);
                    defaultDVNs[0] = address(dvn);

                    {
                        SetDefaultUlnConfigParam[] memory params = new SetDefaultUlnConfigParam[](1);
                        UlnConfig memory ulnConfig = UlnConfig(
                            100,
                            uint8(defaultDVNs.length),
                            uint8(optionalDVNs.length),
                            0,
                            defaultDVNs,
                            optionalDVNs
                        );
                        params[0] = SetDefaultUlnConfigParam(dstEid, ulnConfig);
                        sendUln.setDefaultUlnConfigs(params);
                    }

                    {
                        SetDefaultExecutorConfigParam[] memory params = new SetDefaultExecutorConfigParam[](1);
                        ExecutorConfig memory executorConfig = ExecutorConfig(10000, address(executor));
                        params[0] = SetDefaultExecutorConfigParam(dstEid, executorConfig);
                        sendUln.setDefaultExecutorConfigs(params);
                    }

                    {
                        SetDefaultUlnConfigParam[] memory params = new SetDefaultUlnConfigParam[](1);
                        UlnConfig memory ulnConfig = UlnConfig(
                            100,
                            uint8(defaultDVNs.length),
                            uint8(optionalDVNs.length),
                            0,
                            defaultDVNs,
                            optionalDVNs
                        );
                        params[0] = SetDefaultUlnConfigParam(dstEid, ulnConfig);
                        receiveUln.setDefaultUlnConfigs(params);
                    }

                    // executor config
                    dstConfigParams[j] = IExecutor.DstConfigParam({
                        dstEid: dstEid,
                        lzReceiveBaseGas: 5000,
                        lzComposeBaseGas: 0,
                        multiplierBps: 10000,
                        floorMarginUSD: 1e10,
                        nativeCap: executorValueCap
                    });

                    // dvn config
                    dvnConfigParams[j] = IDVN.DstConfigParam({
                        dstEid: dstEid,
                        gas: 5000,
                        multiplierBps: 10000,
                        floorMarginUSD: 1e10
                    });

                    uint128 denominator = priceFeed.getPriceRatioDenominator();
                    ILayerZeroPriceFeed.UpdatePrice[] memory prices = new ILayerZeroPriceFeed.UpdatePrice[](1);
                    prices[0] = ILayerZeroPriceFeed.UpdatePrice(
                        dstEid,
                        ILayerZeroPriceFeed.Price(1 * denominator, 1, 1)
                    );
                    priceFeed.setPrice(prices);
                }
                executor.setDstConfig(dstConfigParams);
                dvn.setDstConfig(dvnConfigParams);
            } else if (_libraryType == LibraryType.SimpleMessageLib) {
                SimpleMessageLibMock messageLib = new SimpleMessageLibMock(payable(this), address(endpointList[i]));
                endpointList[i].registerLibrary(address(messageLib));
                sendLibs[i] = address(messageLib);
                receiveLibs[i] = address(messageLib);
            } else {
                revert("invalid library type");
            }
        }

        // config up
        for (uint8 i = 0; i < _endpointNum; i++) {
            EndpointV2 endpoint = endpointList[i];
            for (uint8 j = 0; j < _endpointNum; j++) {
                if (i == j) continue;
                endpoint.setDefaultSendLibrary(j + 1, sendLibs[i]);
                endpoint.setDefaultReceiveLibrary(j + 1, receiveLibs[i], 0);
            }
        }
    }

    /**
     * @dev setup UAs, only if the UA has `endpoint` address as the unique parameter
     */
    function setupOApps(
        bytes memory _oappCreationCode,
        uint8 _startEid,
        uint8 _oappNum
    ) public returns (address[] memory oapps) {
        oapps = new address[](_oappNum);
        for (uint8 eid = _startEid; eid < _startEid + _oappNum; eid++) {
            address oapp = _deployOApp(_oappCreationCode, abi.encode(address(endpoints[eid]), address(this), true));
            oapps[eid - _startEid] = oapp;
        }
        // config
        wireOApps(oapps);
    }

    function wireOApps(address[] memory oapps) public {
        uint256 size = oapps.length;
        for (uint256 i = 0; i < size; i++) {
            OApp localOApp = OApp(payable(oapps[i]));
            for (uint256 j = 0; j < size; j++) {
                if (i == j) continue;
                OApp remoteOApp = OApp(payable(oapps[j]));
                uint32 remoteEid = (remoteOApp.endpoint()).eid();
                localOApp.setPeer(remoteEid, addressToBytes32(address(remoteOApp)));
            }
        }
    }

    function _deployOApp(bytes memory _oappBytecode, bytes memory _constructorArgs) internal returns (address addr) {
        bytes memory bytecode = bytes.concat(abi.encodePacked(_oappBytecode), _constructorArgs);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
    }

    function schedulePacket(bytes calldata _packetBytes, bytes calldata _options) public {
        uint32 dstEid = _packetBytes.dstEid();
        bytes32 dstAddress = _packetBytes.receiver();
        DoubleEndedQueue.Bytes32Deque storage queue = packetsQueue[dstEid][dstAddress];
        // front in, back out
        bytes32 guid = _packetBytes.guid();
        queue.pushFront(guid);
        packets[guid] = _packetBytes;
        optionsLookup[guid] = _options;
    }

    /**
     * @dev verify packets to destination chain's UA address
     * @param _dstEid  destination eid
     * @param _dstAddress  destination address
     */
    function verifyPackets(uint32 _dstEid, bytes32 _dstAddress) public {
        verifyPackets(_dstEid, _dstAddress, 0, address(0x0));
    }

    /**
     * @dev verify packets to destination chain's UA address
     * @param _dstEid  destination eid
     * @param _dstAddress  destination address
     */
    function verifyPackets(uint32 _dstEid, address _dstAddress) public {
        verifyPackets(_dstEid, bytes32(uint256(uint160(_dstAddress))), 0, address(0x0));
    }

    /**
     * @dev dst UA receive/execute packets
     * @dev will NOT work calling this directly with composer IF the composed payload is different from the lzReceive msg payload
     */
    function verifyPackets(uint32 _dstEid, bytes32 _dstAddress, uint256 _packetAmount, address _composer) public {
        require(endpoints[_dstEid] != address(0), "endpoint not yet registered");

        DoubleEndedQueue.Bytes32Deque storage queue = packetsQueue[_dstEid][_dstAddress];
        uint256 pendingPacketsSize = queue.length();
        uint256 numberOfPackets;
        if (_packetAmount == 0) {
            numberOfPackets = queue.length();
        } else {
            numberOfPackets = pendingPacketsSize > _packetAmount ? _packetAmount : pendingPacketsSize;
        }
        while (numberOfPackets > 0) {
            numberOfPackets--;
            // front in, back out
            bytes32 guid = queue.popBack();
            bytes memory packetBytes = packets[guid];
            this.assertGuid(packetBytes, guid);
            this.validatePacket(packetBytes);

            bytes memory options = optionsLookup[guid];
            if (_executorOptionExists(options, ExecutorOptions.OPTION_TYPE_NATIVE_DROP)) {
                (uint256 amount, bytes32 receiver) = _parseExecutorNativeDropOption(options);
                address to = address(uint160(uint256(receiver)));
                (bool sent, ) = to.call{ value: amount }("");
                require(sent, "Failed to send Ether");
            }
            if (_executorOptionExists(options, ExecutorOptions.OPTION_TYPE_LZRECEIVE)) {
                this.lzReceive(packetBytes, options);
            }
            if (_composer != address(0) && _executorOptionExists(options, ExecutorOptions.OPTION_TYPE_LZCOMPOSE)) {
                this.lzCompose(packetBytes, options, guid, _composer);
            }
        }
    }

    function lzReceive(bytes calldata _packetBytes, bytes memory _options) external payable {
        EndpointV2 endpoint = EndpointV2(endpoints[_packetBytes.dstEid()]);
        (uint256 gas, uint256 value) = OptionsHelper._parseExecutorLzReceiveOption(_options);

        Origin memory origin = Origin(_packetBytes.srcEid(), _packetBytes.sender(), _packetBytes.nonce());
        endpoint.lzReceive{ value: value, gas: gas }(
            origin,
            _packetBytes.receiverB20(),
            _packetBytes.guid(),
            _packetBytes.message(),
            bytes("")
        );
    }

    function lzCompose(
        bytes calldata _packetBytes,
        bytes memory _options,
        bytes32 _guid,
        address _composer
    ) external payable {
        this.lzCompose(
            _packetBytes.dstEid(),
            _packetBytes.receiverB20(),
            _options,
            _guid,
            _composer,
            _packetBytes.message()
        );
    }

    // @dev the verifyPackets does not know the composeMsg if it is NOT the same as the original lzReceive payload
    // Can call this directly from your test to lzCompose those types of packets
    function lzCompose(
        uint32 _dstEid,
        address _from,
        bytes memory _options,
        bytes32 _guid,
        address _to,
        bytes calldata _composerMsg
    ) external payable {
        EndpointV2 endpoint = EndpointV2(endpoints[_dstEid]);
        (uint16 index, uint256 gas, uint256 value) = _parseExecutorLzComposeOption(_options);
        endpoint.lzCompose{ value: value, gas: gas }(_from, _to, _guid, index, _composerMsg, bytes(""));
    }

    function validatePacket(bytes calldata _packetBytes) external {
        uint32 dstEid = _packetBytes.dstEid();
        EndpointV2 endpoint = EndpointV2(endpoints[dstEid]);
        (address receiveLib, ) = endpoint.getReceiveLibrary(_packetBytes.receiverB20(), _packetBytes.srcEid());
        ReceiveUln302 dstUln = ReceiveUln302(receiveLib);

        (uint64 major, , ) = IMessageLib(receiveLib).version();
        if (major == 3) {
            // it is ultra light node
            bytes memory config = dstUln.getConfig(_packetBytes.srcEid(), _packetBytes.receiverB20(), 2); // CONFIG_TYPE_ULN
            DVN dvn = DVN(abi.decode(config, (UlnConfig)).requiredDVNs[0]);

            bytes memory packetHeader = _packetBytes.header();
            bytes32 payloadHash = keccak256(_packetBytes.payload());

            // sign
            bytes memory signatures;
            bytes memory verifyCalldata = abi.encodeWithSelector(
                IReceiveUlnE2.verify.selector,
                packetHeader,
                payloadHash,
                100
            );
            {
                bytes32 hash = dvn.hashCallData(dstEid, address(dstUln), verifyCalldata, block.timestamp + 1000);
                bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
                (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // matches dvn signer
                signatures = abi.encodePacked(r, s, v);
            }
            ExecuteParam[] memory params = new ExecuteParam[](1);
            params[0] = ExecuteParam(dstEid, address(dstUln), verifyCalldata, block.timestamp + 1000, signatures);
            dvn.execute(params);

            // commit verification
            bytes memory callData = abi.encodeWithSelector(
                IReceiveUlnE2.commitVerification.selector,
                packetHeader,
                payloadHash
            );
            {
                bytes32 hash = dvn.hashCallData(dstEid, address(dstUln), callData, block.timestamp + 1000);
                bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
                (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, ethSignedMessageHash); // matches dvn signer
                signatures = abi.encodePacked(r, s, v);
            }
            params[0] = ExecuteParam(dstEid, address(dstUln), callData, block.timestamp + 1000, signatures);
            dvn.execute(params);
        } else {
            SimpleMessageLibMock(payable(receiveLib)).validatePacket(_packetBytes);
        }
    }

    function assertGuid(bytes calldata packetBytes, bytes32 guid) external pure {
        bytes32 packetGuid = packetBytes.guid();
        require(packetGuid == guid, "guid not match");
    }

    function registerEndpoint(EndpointV2 endpoint) public {
        endpoints[endpoint.eid()] = address(endpoint);
    }

    function hasPendingPackets(uint16 _dstEid, bytes32 _dstAddress) public view returns (bool flag) {
        DoubleEndedQueue.Bytes32Deque storage queue = packetsQueue[_dstEid][_dstAddress];
        return queue.length() > 0;
    }

    function getNextInflightPacket(uint16 _dstEid, bytes32 _dstAddress) public view returns (bytes memory packetBytes) {
        DoubleEndedQueue.Bytes32Deque storage queue = packetsQueue[_dstEid][_dstAddress];
        if (queue.length() > 0) {
            bytes32 guid = queue.back();
            packetBytes = packets[guid];
        }
    }

    function addressToBytes32(address _addr) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(_addr)));
    }

    receive() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/ERC20Mock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ERC20Mock is ERC20 {
    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

    function mint(address _to, uint256 _amount) public {
        _mint(_to, _amount);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/ExecutorFeeLibMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.20;

import { ExecutorFeeLib } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/ExecutorFeeLib.sol";

contract ExecutorFeeLibMock is ExecutorFeeLib {
    constructor() ExecutorFeeLib(1e18) {}

    function _isV1Eid(uint32 /*_eid*/) internal pure override returns (bool) {
        return false;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/OFTAdapterMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { OFTAdapter } from "../../contracts/oft/OFTAdapter.sol";

contract OFTAdapterMock is OFTAdapter {
    constructor(address _token, address _lzEndpoint, address _delegate) OFTAdapter(_token, _lzEndpoint, _delegate) {}

    // @dev expose internal functions for testing purposes
    function debit(
        uint256 _amountToSendLD,
        uint256 _minAmountToCreditLD,
        uint32 _dstEid
    ) public returns (uint256 amountDebitedLD, uint256 amountToCreditLD) {
        return _debit(_amountToSendLD, _minAmountToCreditLD, _dstEid);
    }

    function debitView(
        uint256 _amountToSendLD,
        uint256 _minAmountToCreditLD,
        uint32 _dstEid
    ) public view returns (uint256 amountDebitedLD, uint256 amountToCreditLD) {
        return _debitView(_amountToSendLD, _minAmountToCreditLD, _dstEid);
    }

    function credit(address _to, uint256 _amountToCreditLD, uint32 _srcEid) public returns (uint256 amountReceivedLD) {
        return _credit(_to, _amountToCreditLD, _srcEid);
    }

    function removeDust(uint256 _amountLD) public view returns (uint256 amountLD) {
        return _removeDust(_amountLD);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/OFTComposerMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { IOAppComposer } from "../../contracts/oapp/interfaces/IOAppComposer.sol";

contract OFTComposerMock is IOAppComposer {
    // default empty values for testing a lzCompose received message
    address public from;
    bytes32 public guid;
    bytes public message;
    address public executor;
    bytes public extraData;

    function lzCompose(
        address _from,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata /*_extraData*/
    ) external payable {
        from = _from;
        guid = _guid;
        message = _message;
        executor = _executor;
        extraData = _message;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/OFTInspectorMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { IOAppMsgInspector } from "../../contracts/oapp/interfaces/IOAppMsgInspector.sol";

contract OFTInspectorMock is IOAppMsgInspector {
    function inspect(bytes calldata _message, bytes calldata _options) external pure returns (bool) {
        revert InspectionFailed(_message, _options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/OFTMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { OFT } from "../../contracts/oft/OFT.sol";
import { SendParam } from "../../contracts/oft/OFTCore.sol";

contract OFTMock is OFT {
    constructor(
        string memory _name,
        string memory _symbol,
        address _lzEndpoint,
        address _delegate
    ) OFT(_name, _symbol, _lzEndpoint, _delegate) {}

    function mint(address _to, uint256 _amount) public {
        _mint(_to, _amount);
    }

    // @dev expose internal functions for testing purposes
    function debit(
        uint256 _amountToSendLD,
        uint256 _minAmountToCreditLD,
        uint32 _dstEid
    ) public returns (uint256 amountDebitedLD, uint256 amountToCreditLD) {
        return _debit(_amountToSendLD, _minAmountToCreditLD, _dstEid);
    }

    function debitView(
        uint256 _amountToSendLD,
        uint256 _minAmountToCreditLD,
        uint32 _dstEid
    ) public view returns (uint256 amountDebitedLD, uint256 amountToCreditLD) {
        return _debitView(_amountToSendLD, _minAmountToCreditLD, _dstEid);
    }

    function removeDust(uint256 _amountLD) public view returns (uint256 amountLD) {
        return _removeDust(_amountLD);
    }

    function toLD(uint64 _amountSD) public view returns (uint256 amountLD) {
        return _toLD(_amountSD);
    }

    function toSD(uint256 _amountLD) public view returns (uint64 amountSD) {
        return _toSD(_amountLD);
    }

    function credit(address _to, uint256 _amountToCreditLD, uint32 _srcEid) public returns (uint256 amountReceivedLD) {
        return _credit(_to, _amountToCreditLD, _srcEid);
    }

    function buildMsgAndOptions(
        SendParam calldata _sendParam,
        uint256 _amountToCreditLD
    ) public view returns (bytes memory message, bytes memory options) {
        return _buildMsgAndOptions(_sendParam, _amountToCreditLD);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/PreCrimeV2Mock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { PreCrimePeer } from "../../contracts/precrime/interfaces/IPreCrime.sol";
import { IOAppPreCrimeSimulator } from "../../contracts/precrime/interfaces/IOAppPreCrimeSimulator.sol";
import { PreCrime } from "../../contracts/precrime/PreCrime.sol";
import { InboundPacket } from "../../contracts/precrime/libs/Packet.sol";

import { PreCrimeV2SimulatorMock } from "./PreCrimeV2SimulatorMock.sol";

contract PreCrimeV2Mock is PreCrime {
    constructor(address _endpoint, address _simulator) PreCrime(_endpoint, _simulator) {}

    uint32[] public eids;
    bytes[] public results;

    function buildSimulationResult() external view override returns (bytes memory) {
        return abi.encode(PreCrimeV2SimulatorMock(simulator).count());
    }

    function _getPreCrimePeers(
        InboundPacket[] memory _packets
    ) internal view override returns (PreCrimePeer[] memory peers) {
        for (uint256 i = 0; i < _packets.length; i++) {
            InboundPacket memory packet = _packets[i];
            if (IOAppPreCrimeSimulator(simulator).isPeer(packet.origin.srcEid, packet.origin.sender)) {
                return preCrimePeers;
            }
        }
        return (new PreCrimePeer[](0));
    }

    function _preCrime(InboundPacket[] memory, uint32[] memory _eids, bytes[] memory _results) internal override {
        eids = _eids;
        results = _results;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/PreCrimeV2SimulatorMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { Origin } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { OAppPreCrimeSimulator } from "../../contracts/precrime/OAppPreCrimeSimulator.sol";

contract PreCrimeV2SimulatorMock is OAppPreCrimeSimulator {
    uint256 public count;

    error InvalidEid();

    function _lzReceiveSimulate(
        Origin calldata _origin,
        bytes32 /*_guid*/,
        bytes calldata /*_message*/,
        address /*_executor*/,
        bytes calldata /*_extraData*/
    ) internal override {
        if (_origin.srcEid == 0) revert InvalidEid();
        count++;
    }

    function isPeer(uint32 _eid, bytes32 _peer) public pure override returns (bool) {
        return bytes32(uint256(_eid)) == _peer;
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/SendUln302Mock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { Packet } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol";
import { MessagingFee } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol";
import { SendUln302 } from "@layerzerolabs/lz-evm-messagelib-v2/contracts/uln/uln302/SendUln302.sol";

import { TestHelper } from "../TestHelper.sol";

contract SendUln302Mock is SendUln302 {
    // offchain packets schedule
    TestHelper public testHelper;

    constructor(
        address payable _verifyHelper,
        address _endpoint,
        uint256 _treasuryGasCap,
        uint256 _treasuryGasForFeeCap
    ) SendUln302(_endpoint, _treasuryGasCap, _treasuryGasForFeeCap) {
        testHelper = TestHelper(_verifyHelper);
    }

    function send(
        Packet calldata _packet,
        bytes calldata _options,
        bool _payInLzToken
    ) public override returns (MessagingFee memory fee, bytes memory encodedPacket) {
        (fee, encodedPacket) = super.send(_packet, _options, _payInLzToken);
        testHelper.schedulePacket(encodedPacket, _options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/oapp/test/mocks/SimpleMessageLibMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import { SimpleMessageLib } from "@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/SimpleMessageLib.sol";

import { TestHelper } from "../TestHelper.sol";

contract SimpleMessageLibMock is SimpleMessageLib {
    // offchain packets schedule
    TestHelper public testHelper;

    constructor(address payable _verifyHelper, address _endpoint) SimpleMessageLib(_endpoint, address(0x0)) {
        testHelper = TestHelper(_verifyHelper);
    }

    function _handleMessagingParamsHook(bytes memory _encodedPacket, bytes memory _options) internal override {
        testHelper.schedulePacket(_encodedPacket, _options);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/EndpointV2.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import { MessagingFee, MessagingParams, MessagingReceipt, Origin, ILayerZeroEndpointV2 } from "./interfaces/ILayerZeroEndpointV2.sol";
import { ISendLib, Packet } from "./interfaces/ISendLib.sol";
import { ILayerZeroReceiver } from "./interfaces/ILayerZeroReceiver.sol";
import { Errors } from "./libs/Errors.sol";
import { GUID } from "./libs/GUID.sol";
import { Transfer } from "./libs/Transfer.sol";
import { MessagingChannel } from "./MessagingChannel.sol";
import { MessagingComposer } from "./MessagingComposer.sol";
import { MessageLibManager } from "./MessageLibManager.sol";
import { MessagingContext } from "./MessagingContext.sol";

// LayerZero EndpointV2 is fully backward compatible with LayerZero Endpoint(V1), but it also supports additional
// features that Endpoint(V1) does not support now and may not in the future. We have also changed some terminology
// to clarify pre-existing language that might have been confusing.
//
// The following is a list of terminology changes:
//     -chainId -> eid
//          - Rationale: chainId was a term we initially used to describe an endpoint on a specific chain. Since
//          LayerZero supports non-EVMs we could not map the classic EVM chainIds to the LayerZero chainIds, making it
//          confusing for developers. With the addition of EndpointV2 and its backward compatible nature, we would have
//          two chainIds per chain that has Endpoint(V1), further confusing developers. We have decided to change the
//          name to Endpoint Id, or eid, for simplicity and clarity.
//     -adapterParams -> options
//     -userApplication -> oapp. Omnichain Application
//     -srcAddress -> sender
//     -dstAddress -> receiver
//          - Rationale: The sender/receiver on EVM is the address. However, on non-EVM chains, the sender/receiver could
//          represented as a public key, or some other identifier. The term sender/receiver is more generic
//     -payload -> message.
//          - Rationale: The term payload is used in the context of a packet, which is a combination of the message and GUID
contract EndpointV2 is ILayerZeroEndpointV2, MessagingChannel, MessageLibManager, MessagingComposer, MessagingContext {
    address public lzToken;

    mapping(address oapp => address delegate) public delegates;

    /// @param _eid the unique Endpoint Id for this deploy that all other Endpoints can use to send to it
    constructor(uint32 _eid, address _owner) MessagingChannel(_eid) {
        _transferOwnership(_owner);
    }

    /// @dev MESSAGING STEP 0
    /// @notice This view function gives the application built on top of LayerZero the ability to requests a quote
    /// with the same parameters as they would to send their message. Since the quotes are given on chain there is a
    /// race condition in which the prices could change between the time the user gets their quote and the time they
    /// submit their message. If the price moves up and the user doesn't send enough funds the transaction will revert,
    /// if the price goes down the _refundAddress provided by the app will be refunded the difference.
    /// @param _params the messaging parameters
    /// @param _sender the sender of the message
    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory) {
        // lzToken must be set to support payInLzToken
        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();

        // get the correct outbound nonce
        uint64 nonce = outboundNonce[_sender][_params.dstEid][_params.receiver] + 1;

        // construct the packet with a GUID
        Packet memory packet = Packet({
            nonce: nonce,
            srcEid: eid,
            sender: _sender,
            dstEid: _params.dstEid,
            receiver: _params.receiver,
            guid: GUID.generate(nonce, eid, _sender, _params.dstEid, _params.receiver),
            message: _params.message
        });

        // get the send library by sender and dst eid
        // use _ to avoid variable shadowing
        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);

        return ISendLib(_sendLibrary).quote(packet, _params.options, _params.payInLzToken);
    }

    /// @dev MESSAGING STEP 1 - OApp need to transfer the fees to the endpoint before sending the message
    /// @param _params the messaging parameters
    /// @param _refundAddress the address to refund both the native and lzToken
    function send(
        MessagingParams calldata _params,
        address _refundAddress
    ) external payable sendContext(_params.dstEid, msg.sender) returns (MessagingReceipt memory) {
        if (_params.payInLzToken && lzToken == address(0x0)) revert Errors.LZ_LzTokenUnavailable();

        // send message
        (MessagingReceipt memory receipt, address _sendLibrary) = _send(msg.sender, _params);

        // OApp can simulate with 0 native value it will fail with error including the required fee, which can be provided in the actual call
        // this trick can be used to avoid the need to write the quote() function
        // however, without the quote view function it will be hard to compose an oapp on chain
        uint256 suppliedNative = _suppliedNative();
        uint256 suppliedLzToken = _suppliedLzToken(_params.payInLzToken);
        _assertMessagingFee(receipt.fee, suppliedNative, suppliedLzToken);

        // handle lz token fees
        _payToken(lzToken, receipt.fee.lzTokenFee, suppliedLzToken, _sendLibrary, _refundAddress);

        // handle native fees
        _payNative(receipt.fee.nativeFee, suppliedNative, _sendLibrary, _refundAddress);

        return receipt;
    }

    /// @dev internal function for sending the messages used by all external send methods
    /// @param _sender the address of the application sending the message to the destination chain
    /// @param _params the messaging parameters
    function _send(
        address _sender,
        MessagingParams calldata _params
    ) internal returns (MessagingReceipt memory, address) {
        // get the correct outbound nonce
        uint64 latestNonce = _outbound(_sender, _params.dstEid, _params.receiver);

        // construct the packet with a GUID
        Packet memory packet = Packet({
            nonce: latestNonce,
            srcEid: eid,
            sender: _sender,
            dstEid: _params.dstEid,
            receiver: _params.receiver,
            guid: GUID.generate(latestNonce, eid, _sender, _params.dstEid, _params.receiver),
            message: _params.message
        });

        // get the send library by sender and dst eid
        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);

        // messageLib always returns encodedPacket with guid
        (MessagingFee memory fee, bytes memory encodedPacket) = ISendLib(_sendLibrary).send(
            packet,
            _params.options,
            _params.payInLzToken
        );

        // Emit packet information for DVNs, Executors, and any other offchain infrastructure to only listen
        // for this one event to perform their actions.
        emit PacketSent(encodedPacket, _params.options, _sendLibrary);

        return (MessagingReceipt(packet.guid, latestNonce, fee), _sendLibrary);
    }

    /// @dev MESSAGING STEP 2 - on the destination chain
    /// @dev configured receive library verifies a message
    /// @param _origin a struct holding the srcEid, nonce, and sender of the message
    /// @param _receiver the receiver of the message
    /// @param _payloadHash the payload hash of the message
    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external {
        if (!isValidReceiveLibrary(_receiver, _origin.srcEid, msg.sender)) revert Errors.LZ_InvalidReceiveLibrary();

        uint64 lazyNonce = lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender];
        if (!_initializable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotInitializable();
        if (!_verifiable(_origin, _receiver, lazyNonce)) revert Errors.LZ_PathNotVerifiable();

        // insert the message into the message channel
        _inbound(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, _payloadHash);
        emit PacketVerified(_origin, _receiver, _payloadHash);
    }

    /// @dev MESSAGING STEP 3 - the last step
    /// @dev execute a verified message to the designated receiver
    /// @dev the execution provides the execution context (caller, extraData) to the receiver. the receiver can optionally assert the caller and validate the untrusted extraData
    /// @dev cant reentrant because the payload is cleared before execution
    /// @param _origin the origin of the message
    /// @param _receiver the receiver of the message
    /// @param _guid the guid of the message
    /// @param _message the message
    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.
    function lzReceive(
        Origin calldata _origin,
        address _receiver,
        bytes32 _guid,
        bytes calldata _message,
        bytes calldata _extraData
    ) external payable {
        // clear the payload first to prevent reentrancy, and then execute the message
        _clearPayload(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, abi.encodePacked(_guid, _message));
        ILayerZeroReceiver(_receiver).lzReceive{ value: msg.value }(_origin, _guid, _message, msg.sender, _extraData);
        emit PacketDelivered(_origin, _receiver);
    }

    /// @param _origin the origin of the message
    /// @param _receiver the receiver of the message
    /// @param _guid the guid of the message
    /// @param _message the message
    /// @param _extraData the extra data provided by the executor.
    /// @param _reason the reason for failure
    function lzReceiveAlert(
        Origin calldata _origin,
        address _receiver,
        bytes32 _guid,
        uint256 _gas,
        uint256 _value,
        bytes calldata _message,
        bytes calldata _extraData,
        bytes calldata _reason
    ) external {
        emit LzReceiveAlert(_receiver, msg.sender, _origin, _guid, _gas, _value, _message, _extraData, _reason);
    }

    /// @dev Oapp uses this interface to clear a message.
    /// @dev this is a PULL mode versus the PUSH mode of lzReceive
    /// @dev the cleared message can be ignored by the app (effectively burnt)
    /// @dev authenticated by oapp
    /// @param _origin the origin of the message
    /// @param _guid the guid of the message
    /// @param _message the message
    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external {
        _assertAuthorized(_oapp);

        bytes memory payload = abi.encodePacked(_guid, _message);
        _clearPayload(_oapp, _origin.srcEid, _origin.sender, _origin.nonce, payload);
        emit PacketDelivered(_origin, _oapp);
    }

    /// @dev allows reconfiguration to recover from wrong configurations
    /// @dev users should never approve the EndpointV2 contract to spend their non-layerzero tokens
    /// @dev override this function if the endpoint is charging ERC20 tokens as native
    /// @dev only owner
    /// @param _lzToken the new layer zero token address
    function setLzToken(address _lzToken) public virtual onlyOwner {
        lzToken = _lzToken;
        emit LzTokenSet(_lzToken);
    }

    /// @dev recover the token sent to this contract by mistake
    /// @dev only owner
    /// @param _token the token to recover. if 0x0 then it is native token
    /// @param _to the address to send the token to
    /// @param _amount the amount to send
    function recoverToken(address _token, address _to, uint256 _amount) external onlyOwner {
        Transfer.nativeOrToken(_token, _to, _amount);
    }

    /// @dev handling token payments on endpoint. the sender must approve the endpoint to spend the token
    /// @dev internal function
    /// @param _token the token to pay
    /// @param _required the amount required
    /// @param _supplied the amount supplied
    /// @param _receiver the receiver of the token
    function _payToken(
        address _token,
        uint256 _required,
        uint256 _supplied,
        address _receiver,
        address _refundAddress
    ) internal {
        if (_required > 0) {
            Transfer.token(_token, _receiver, _required);
        }
        if (_required < _supplied) {
            unchecked {
                // refund the excess
                Transfer.token(_token, _refundAddress, _supplied - _required);
            }
        }
    }

    /// @dev handling native token payments on endpoint
    /// @dev override this if the endpoint is charging ERC20 tokens as native
    /// @dev internal function
    /// @param _required the amount required
    /// @param _supplied the amount supplied
    /// @param _receiver the receiver of the native token
    /// @param _refundAddress the address to refund the excess to
    function _payNative(
        uint256 _required,
        uint256 _supplied,
        address _receiver,
        address _refundAddress
    ) internal virtual {
        if (_required > 0) {
            Transfer.native(_receiver, _required);
        }
        if (_required < _supplied) {
            unchecked {
                // refund the excess
                Transfer.native(_refundAddress, _supplied - _required);
            }
        }
    }

    /// @dev get the balance of the lzToken as the supplied lzToken fee if payInLzToken is true
    function _suppliedLzToken(bool _payInLzToken) internal view returns (uint256 supplied) {
        if (_payInLzToken) {
            supplied = IERC20(lzToken).balanceOf(address(this));

            // if payInLzToken is true, the supplied fee must be greater than 0 to prevent a race condition
            // in which an oapp sending a message with lz token and the lz token is set to a new token between the tx
            // being sent and the tx being mined. if the required lz token fee is 0 and the old lz token would be
            // locked in the contract instead of being refunded
            if (supplied == 0) revert Errors.LZ_ZeroLzTokenFee();
        }
    }

    /// @dev override this if the endpoint is charging ERC20 tokens as native
    function _suppliedNative() internal view virtual returns (uint256) {
        return msg.value;
    }

    /// @dev Assert the required fees and the supplied fees are enough
    function _assertMessagingFee(
        MessagingFee memory _required,
        uint256 _suppliedNativeFee,
        uint256 _suppliedLzTokenFee
    ) internal pure {
        if (_required.nativeFee > _suppliedNativeFee || _required.lzTokenFee > _suppliedLzTokenFee) {
            revert Errors.LZ_InsufficientFee(
                _required.nativeFee,
                _suppliedNativeFee,
                _required.lzTokenFee,
                _suppliedLzTokenFee
            );
        }
    }

    /// @dev override this if the endpoint is charging ERC20 tokens as native
    /// @return 0x0 if using native. otherwise the address of the native ERC20 token
    function nativeToken() external view virtual returns (address) {
        return address(0x0);
    }

    /// @notice delegate is authorized by the oapp to configure anything in layerzero
    function setDelegate(address _delegate) external {
        delegates[msg.sender] = _delegate;
        emit DelegateSet(msg.sender, _delegate);
    }

    // ========================= Internal =========================
    function _initializable(
        Origin calldata _origin,
        address _receiver,
        uint64 _lazyInboundNonce
    ) internal view returns (bool) {
        return
            _lazyInboundNonce > 0 || // allowInitializePath already checked
            ILayerZeroReceiver(_receiver).allowInitializePath(_origin);
    }

    /// @dev bytes(0) payloadHash can never be submitted
    function _verifiable(
        Origin calldata _origin,
        address _receiver,
        uint64 _lazyInboundNonce
    ) internal view returns (bool) {
        return
            _origin.nonce > _lazyInboundNonce || // either initializing an empty slot or reverifying
            inboundPayloadHash[_receiver][_origin.srcEid][_origin.sender][_origin.nonce] != EMPTY_PAYLOAD_HASH; // only allow reverifying if it hasn't been executed
    }

    /// @dev assert the caller to either be the oapp or the delegate
    function _assertAuthorized(address _oapp) internal view override(MessagingChannel, MessageLibManager) {
        if (msg.sender != _oapp && msg.sender != delegates[_oapp]) revert Errors.LZ_Unauthorized();
    }

    // ========================= VIEW FUNCTIONS FOR OFFCHAIN ONLY =========================
    // Not involved in any state transition function.
    // ====================================================================================
    function initializable(Origin calldata _origin, address _receiver) external view returns (bool) {
        return _initializable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);
    }

    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool) {
        return _verifiable(_origin, _receiver, lazyInboundNonce[_receiver][_origin.srcEid][_origin.sender]);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/EndpointV2Alt.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import { EndpointV2 } from "./EndpointV2.sol";
import { Errors } from "./libs/Errors.sol";

/// @notice this is the endpoint contract for layerzero v2 deployed on chains using ERC20 as native tokens
contract EndpointV2Alt is EndpointV2 {
    error LZ_OnlyAltToken();

    /// @dev the altFeeToken is used for fees when the native token has no value
    /// @dev it is immutable for gas saving. only 1 endpoint for such chains
    address internal immutable nativeErc20;

    constructor(uint32 _eid, address _owner, address _altToken) EndpointV2(_eid, _owner) {
        nativeErc20 = _altToken;
    }

    /// @dev handling native token payments on endpoint
    /// @dev internal function
    /// @param _required the amount required
    /// @param _supplied the amount supplied
    /// @param _receiver the receiver of the native token
    /// @param _refundAddress the address to refund the excess to
    function _payNative(
        uint256 _required,
        uint256 _supplied,
        address _receiver,
        address _refundAddress
    ) internal override {
        if (msg.value > 0) revert LZ_OnlyAltToken();
        _payToken(nativeErc20, _required, _supplied, _receiver, _refundAddress);
    }

    /// @dev return the balance of the native token
    function _suppliedNative() internal view override returns (uint256) {
        return IERC20(nativeErc20).balanceOf(address(this));
    }

    /// @dev check if lzToken is set to the same address
    function setLzToken(address _lzToken) public override onlyOwner {
        if (_lzToken == nativeErc20) revert Errors.LZ_InvalidArgument();
        super.setLzToken(_lzToken);
    }

    function nativeToken() external view override returns (address) {
        return nativeErc20;
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/EndpointV2View.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Proxied } from "hardhat-deploy/solc_0.8/proxy/Proxied.sol";
import "./EndpointV2ViewUpgradeable.sol";

contract EndpointV2View is EndpointV2ViewUpgradeable, Proxied {
    function initialize(address _endpoint) external proxied initializer {
        __EndpointV2View_init(_endpoint);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/EndpointV2ViewUpgradeable.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Initializable } from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "./interfaces/ILayerZeroEndpointV2.sol";

enum ExecutionState {
    NotExecutable, // executor: waits for PayloadVerified event and starts polling for executable
    VerifiedButNotExecutable, // executor: starts active polling for executable
    Executable,
    Executed
}

contract EndpointV2ViewUpgradeable is Initializable {
    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);
    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);

    ILayerZeroEndpointV2 public endpoint;

    function __EndpointV2View_init(address _endpoint) internal onlyInitializing {
        __EndpointV2View_init_unchained(_endpoint);
    }

    function __EndpointV2View_init_unchained(address _endpoint) internal onlyInitializing {
        endpoint = ILayerZeroEndpointV2(_endpoint);
    }

    function initializable(Origin memory _origin, address _receiver) public view returns (bool) {
        return endpoint.initializable(_origin, _receiver);
    }

    /// @dev check if a message is verifiable.
    function verifiable(
        Origin memory _origin,
        address _receiver,
        address _receiveLib,
        bytes32 _payloadHash
    ) public view returns (bool) {
        if (!endpoint.isValidReceiveLibrary(_receiver, _origin.srcEid, _receiveLib)) return false;

        if (!endpoint.verifiable(_origin, _receiver)) return false;

        // checked in _inbound for verify
        if (_payloadHash == EMPTY_PAYLOAD_HASH) return false;

        return true;
    }

    /// @dev check if a message is executable.
    /// @return ExecutionState of Executed, Executable, or NotExecutable
    function executable(Origin memory _origin, address _receiver) public view returns (ExecutionState) {
        bytes32 payloadHash = endpoint.inboundPayloadHash(_receiver, _origin.srcEid, _origin.sender, _origin.nonce);

        // executed if the payload hash has been cleared and the nonce is less than or equal to lazyInboundNonce
        if (
            payloadHash == EMPTY_PAYLOAD_HASH &&
            _origin.nonce <= endpoint.lazyInboundNonce(_receiver, _origin.srcEid, _origin.sender)
        ) {
            return ExecutionState.Executed;
        }

        // executable if nonce has not been executed and has not been nilified and nonce is less than or equal to inboundNonce
        if (
            payloadHash != NIL_PAYLOAD_HASH &&
            _origin.nonce <= endpoint.inboundNonce(_receiver, _origin.srcEid, _origin.sender)
        ) {
            return ExecutionState.Executable;
        }

        // only start active executable polling if payload hash is not empty nor nil
        if (payloadHash != EMPTY_PAYLOAD_HASH && payloadHash != NIL_PAYLOAD_HASH) {
            return ExecutionState.VerifiedButNotExecutable;
        }

        // return NotExecutable as a catch-all
        return ExecutionState.NotExecutable;
    }

    /**
     * @dev This empty reserved space is put in place to allow future versions to add new
     * variables without shifting down storage in the inheritance chain.
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[49] private __gap;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/MessageLibManager.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { IMessageLib, MessageLibType } from "./interfaces/IMessageLib.sol";
import { IMessageLibManager, SetConfigParam } from "./interfaces/IMessageLibManager.sol";
import { Errors } from "./libs/Errors.sol";
import { BlockedMessageLib } from "./messagelib/BlockedMessageLib.sol";

abstract contract MessageLibManager is Ownable, IMessageLibManager {
    address private constant DEFAULT_LIB = address(0);

    // the library that reverts both on send and quote
    // must be configured on construction and be immutable
    address public immutable blockedLibrary;

    // only registered libraries all valid libraries
    // the blockedLibrary will be registered on construction
    address[] internal registeredLibraries;
    mapping(address lib => bool) public isRegisteredLibrary;

    // both sendLibrary and receiveLibrary config can be lazily resolved
    mapping(address sender => mapping(uint32 dstEid => address lib)) internal sendLibrary;
    mapping(address receiver => mapping(uint32 srcEid => address lib)) internal receiveLibrary;
    mapping(address receiver => mapping(uint32 srcEid => Timeout)) public receiveLibraryTimeout;

    mapping(uint32 dstEid => address lib) public defaultSendLibrary;
    mapping(uint32 srcEid => address lib) public defaultReceiveLibrary;
    mapping(uint32 srcEid => Timeout) public defaultReceiveLibraryTimeout;

    constructor() {
        blockedLibrary = address(new BlockedMessageLib());
        registerLibrary(blockedLibrary);
    }

    modifier onlyRegistered(address _lib) {
        if (!isRegisteredLibrary[_lib]) revert Errors.LZ_OnlyRegisteredLib();
        _;
    }

    modifier isSendLib(address _lib) {
        if (_lib != DEFAULT_LIB) {
            if (IMessageLib(_lib).messageLibType() == MessageLibType.Receive) revert Errors.LZ_OnlySendLib();
        }
        _;
    }

    modifier isReceiveLib(address _lib) {
        if (_lib != DEFAULT_LIB) {
            if (IMessageLib(_lib).messageLibType() == MessageLibType.Send) revert Errors.LZ_OnlyReceiveLib();
        }
        _;
    }

    modifier onlyRegisteredOrDefault(address _lib) {
        if (!isRegisteredLibrary[_lib] && _lib != DEFAULT_LIB) revert Errors.LZ_OnlyRegisteredOrDefaultLib();
        _;
    }

    /// @dev check if the library supported the eid.
    modifier onlySupportedEid(address _lib, uint32 _eid) {
        /// @dev doesnt need to check for default lib, because when they are initially added they get passed through this modifier
        if (_lib != DEFAULT_LIB) {
            if (!IMessageLib(_lib).isSupportedEid(_eid)) revert Errors.LZ_UnsupportedEid();
        }
        _;
    }

    function getRegisteredLibraries() external view returns (address[] memory) {
        return registeredLibraries;
    }

    /// @notice The Send Library is the Oapp specified library that will be used to send the message to the destination
    /// endpoint. If the Oapp does not specify a Send Library, the default Send Library will be used.
    /// @dev If the Oapp does not have a selected Send Library, this function will resolve to the default library
    /// configured by LayerZero
    /// @return lib address of the Send Library
    /// @param _sender The address of the Oapp that is sending the message
    /// @param _dstEid The destination endpoint id
    function getSendLibrary(address _sender, uint32 _dstEid) public view returns (address lib) {
        lib = sendLibrary[_sender][_dstEid];
        if (lib == DEFAULT_LIB) {
            lib = defaultSendLibrary[_dstEid];
            if (lib == address(0x0)) revert Errors.LZ_DefaultSendLibUnavailable();
        }
    }

    function isDefaultSendLibrary(address _sender, uint32 _dstEid) public view returns (bool) {
        return sendLibrary[_sender][_dstEid] == DEFAULT_LIB;
    }

    /// @dev the receiveLibrary can be lazily resolved that if not set it will point to the default configured by LayerZero
    function getReceiveLibrary(address _receiver, uint32 _srcEid) public view returns (address lib, bool isDefault) {
        lib = receiveLibrary[_receiver][_srcEid];
        if (lib == DEFAULT_LIB) {
            lib = defaultReceiveLibrary[_srcEid];
            if (lib == address(0x0)) revert Errors.LZ_DefaultReceiveLibUnavailable();
            isDefault = true;
        }
    }

    /// @dev called when the endpoint checks if the msgLib attempting to verify the msg is the configured msgLib of the Oapp
    /// @dev this check provides the ability for Oapp to lock in a trusted msgLib
    /// @dev it will fist check if the msgLib is the currently configured one. then check if the msgLib is the one in grace period of msgLib versioning upgrade
    function isValidReceiveLibrary(
        address _receiver,
        uint32 _srcEid,
        address _actualReceiveLib
    ) public view returns (bool) {
        // early return true if the _actualReceiveLib is the currently configured one
        (address expectedReceiveLib, bool isDefault) = getReceiveLibrary(_receiver, _srcEid);
        if (_actualReceiveLib == expectedReceiveLib) {
            return true;
        }

        // check the timeout condition otherwise
        // if the Oapp is using defaultReceiveLibrary, use the default Timeout config
        // otherwise, use the Timeout configured by the Oapp
        Timeout memory timeout = isDefault
            ? defaultReceiveLibraryTimeout[_srcEid]
            : receiveLibraryTimeout[_receiver][_srcEid];

        // requires the _actualReceiveLib to be the same as the one in grace period and the grace period has not expired
        // block.number is uint256 so timeout.expiry must > 0, which implies a non-ZERO value
        if (timeout.lib == _actualReceiveLib && timeout.expiry > block.number) {
            // timeout lib set and has not expired
            return true;
        }

        // returns false by default
        return false;
    }

    //------- Owner interfaces
    /// @dev all libraries have to implement the erc165 interface to prevent wrong configurations
    /// @dev only owner
    function registerLibrary(address _lib) public onlyOwner {
        // must have the right interface
        if (!IERC165(_lib).supportsInterface(type(IMessageLib).interfaceId)) revert Errors.LZ_UnsupportedInterface();
        // must have not been registered
        if (isRegisteredLibrary[_lib]) revert Errors.LZ_AlreadyRegistered();

        // insert into both the map and the list
        isRegisteredLibrary[_lib] = true;
        registeredLibraries.push(_lib);

        emit LibraryRegistered(_lib);
    }

    /// @dev owner setting the defaultSendLibrary
    /// @dev can set to the blockedLibrary, which is a registered library
    /// @dev the msgLib must enable the support before they can be registered to the endpoint as the default
    /// @dev only owner
    function setDefaultSendLibrary(
        uint32 _eid,
        address _newLib
    ) external onlyOwner onlyRegistered(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {
        // must provide a different value
        if (defaultSendLibrary[_eid] == _newLib) revert Errors.LZ_SameValue();
        defaultSendLibrary[_eid] = _newLib;
        emit DefaultSendLibrarySet(_eid, _newLib);
    }

    /// @dev owner setting the defaultSendLibrary
    /// @dev must be a registered library (including blockLibrary) with the eid support enabled
    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.
    /// @dev only owner
    function setDefaultReceiveLibrary(
        uint32 _eid,
        address _newLib,
        uint256 _gracePeriod
    ) external onlyOwner onlyRegistered(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {
        address oldLib = defaultReceiveLibrary[_eid];
        // must provide a different value
        if (oldLib == _newLib) revert Errors.LZ_SameValue();

        defaultReceiveLibrary[_eid] = _newLib;
        emit DefaultReceiveLibrarySet(_eid, _newLib);

        if (_gracePeriod > 0) {
            // override the current default timeout to the [old_lib + new expiry]
            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];
            timeout.lib = oldLib;
            timeout.expiry = block.number + _gracePeriod;
            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, timeout.expiry);
        } else {
            // otherwise, remove the old configuration.
            delete defaultReceiveLibraryTimeout[_eid];
            emit DefaultReceiveLibraryTimeoutSet(_eid, oldLib, 0);
        }
    }

    /// @dev owner setting the defaultSendLibrary
    /// @dev must be a registered library (including blockLibrary) with the eid support enabled
    /// @dev can used to (1) extend the current configuration (2) force remove the current configuration (3) change to a new configuration
    /// @param _expiry the block number when lib expires
    function setDefaultReceiveLibraryTimeout(
        uint32 _eid,
        address _lib,
        uint256 _expiry
    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) onlyOwner {
        if (_expiry == 0) {
            // force remove the current configuration
            delete defaultReceiveLibraryTimeout[_eid];
        } else {
            // override it with new configuration
            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();
            Timeout storage timeout = defaultReceiveLibraryTimeout[_eid];
            timeout.lib = _lib;
            timeout.expiry = _expiry;
        }
        emit DefaultReceiveLibraryTimeoutSet(_eid, _lib, _expiry);
    }

    /// @dev returns true only if both the default send/receive libraries are set
    function isSupportedEid(uint32 _eid) external view returns (bool) {
        return defaultSendLibrary[_eid] != address(0) && defaultReceiveLibrary[_eid] != address(0);
    }

    //------- OApp interfaces
    /// @dev Oapp setting the sendLibrary
    /// @dev must be a registered library (including blockLibrary) with the eid support enabled
    /// @dev authenticated by the Oapp
    function setSendLibrary(
        address _oapp,
        uint32 _eid,
        address _newLib
    ) external onlyRegisteredOrDefault(_newLib) isSendLib(_newLib) onlySupportedEid(_newLib, _eid) {
        _assertAuthorized(_oapp);

        // must provide a different value
        if (sendLibrary[_oapp][_eid] == _newLib) revert Errors.LZ_SameValue();
        sendLibrary[_oapp][_eid] = _newLib;
        emit SendLibrarySet(_oapp, _eid, _newLib);
    }

    /// @dev Oapp setting the receiveLibrary
    /// @dev must be a registered library (including blockLibrary) with the eid support enabled
    /// @dev in version migration, it can add a grace period to the old library. if the grace period is 0, it will delete the timeout configuration.
    /// @dev authenticated by the Oapp
    /// @param _gracePeriod the number of blocks from now until oldLib expires
    function setReceiveLibrary(
        address _oapp,
        uint32 _eid,
        address _newLib,
        uint256 _gracePeriod
    ) external onlyRegisteredOrDefault(_newLib) isReceiveLib(_newLib) onlySupportedEid(_newLib, _eid) {
        _assertAuthorized(_oapp);

        address oldLib = receiveLibrary[_oapp][_eid];
        // must provide new values
        if (oldLib == _newLib) revert Errors.LZ_SameValue();
        receiveLibrary[_oapp][_eid] = _newLib;
        emit ReceiveLibrarySet(_oapp, _eid, _newLib);

        if (_gracePeriod > 0) {
            // to simplify the logic, we only allow to set timeout if neither the new lib nor old lib is DEFAULT_LIB, which would should read the default timeout configurations
            // (1) if the Oapp wants to fall back to the DEFAULT, then set the newLib to DEFAULT with grace period == 0
            // (2) if the Oapp wants to change to a non DEFAULT from DEFAULT, then set the newLib to 'non-default' with _gracePeriod == 0, then use setReceiveLibraryTimeout() interface
            if (oldLib == DEFAULT_LIB || _newLib == DEFAULT_LIB) revert Errors.LZ_OnlyNonDefaultLib();

            // write to storage
            Timeout memory timeout = Timeout({ lib: oldLib, expiry: block.number + _gracePeriod });
            receiveLibraryTimeout[_oapp][_eid] = timeout;
            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, timeout.expiry);
        } else {
            delete receiveLibraryTimeout[_oapp][_eid];
            emit ReceiveLibraryTimeoutSet(_oapp, _eid, oldLib, 0);
        }
    }

    /// @dev Oapp setting the defaultSendLibrary
    /// @dev must be a registered library (including blockLibrary) with the eid support enabled
    /// @dev can used to (1) extend the current configuration (2)  force remove the current configuration (3) change to a new configuration
    /// @param _expiry the block number when lib expires
    function setReceiveLibraryTimeout(
        address _oapp,
        uint32 _eid,
        address _lib,
        uint256 _expiry
    ) external onlyRegistered(_lib) isReceiveLib(_lib) onlySupportedEid(_lib, _eid) {
        _assertAuthorized(_oapp);

        (, bool isDefault) = getReceiveLibrary(_oapp, _eid);
        // if current library is DEFAULT, Oapp cant set the timeout
        if (isDefault) revert Errors.LZ_OnlyNonDefaultLib();

        if (_expiry == 0) {
            // force remove the current configuration
            delete receiveLibraryTimeout[_oapp][_eid];
        } else {
            // override it with new configuration
            if (_expiry <= block.number) revert Errors.LZ_InvalidExpiry();
            Timeout storage timeout = receiveLibraryTimeout[_oapp][_eid];
            timeout.lib = _lib;
            timeout.expiry = _expiry;
        }
        emit ReceiveLibraryTimeoutSet(_oapp, _eid, _lib, _expiry);
    }

    //------- library config setter/getter. all pass-through functions to the msgLib

    /// @dev authenticated by the _oapp
    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external onlyRegistered(_lib) {
        _assertAuthorized(_oapp);

        IMessageLib(_lib).setConfig(_oapp, _params);
    }

    /// @dev a view function to query the current configuration of the OApp
    function getConfig(
        address _oapp,
        address _lib,
        uint32 _eid,
        uint32 _configType
    ) external view onlyRegistered(_lib) returns (bytes memory config) {
        return IMessageLib(_lib).getConfig(_eid, _oapp, _configType);
    }

    function _assertAuthorized(address _oapp) internal virtual;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/MessagingChannel.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IMessagingChannel } from "./interfaces/IMessagingChannel.sol";
import { Errors } from "./libs/Errors.sol";
import { GUID } from "./libs/GUID.sol";

abstract contract MessagingChannel is IMessagingChannel {
    bytes32 public constant EMPTY_PAYLOAD_HASH = bytes32(0);
    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);

    // The universally unique id (UUID) of this deployed Endpoint
    uint32 public immutable eid;

    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => uint64 nonce)))
        public lazyInboundNonce;
    mapping(address receiver => mapping(uint32 srcEid => mapping(bytes32 sender => mapping(uint64 inboundNonce => bytes32 payloadHash))))
        public inboundPayloadHash;
    mapping(address sender => mapping(uint32 dstEid => mapping(bytes32 receiver => uint64 nonce))) public outboundNonce;

    /// @param _eid is the universally unique id (UUID) of this deployed Endpoint
    constructor(uint32 _eid) {
        eid = _eid;
    }

    /// @dev increase and return the next outbound nonce
    function _outbound(address _sender, uint32 _dstEid, bytes32 _receiver) internal returns (uint64 nonce) {
        unchecked {
            nonce = ++outboundNonce[_sender][_dstEid][_receiver];
        }
    }

    /// @dev inbound won't update the nonce eagerly to allow unordered verification
    /// @dev instead, it will update the nonce lazily when the message is received
    /// @dev messages can only be cleared in order to preserve censorship-resistance
    function _inbound(
        address _receiver,
        uint32 _srcEid,
        bytes32 _sender,
        uint64 _nonce,
        bytes32 _payloadHash
    ) internal {
        if (_payloadHash == EMPTY_PAYLOAD_HASH) revert Errors.LZ_InvalidPayloadHash();
        inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] = _payloadHash;
    }

    /// @dev returns the max index of the longest gapless sequence of verified msg nonces.
    /// @dev the uninitialized value is 0. the first nonce is always 1
    /// @dev it starts from the lazyInboundNonce (last checkpoint) and iteratively check if the next nonce has been verified
    /// @dev this function can OOG if too many backlogs, but it can be trivially fixed by just clearing some prior messages
    /// @dev NOTE: Oapp explicitly skipped nonces count as "verified" for these purposes
    /// @dev eg. [1,2,3,4,6,7] => 4, [1,2,6,8,10] => 2, [1,3,4,5,6] => 1
    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) public view returns (uint64) {
        uint64 nonceCursor = lazyInboundNonce[_receiver][_srcEid][_sender];

        // find the effective inbound currentNonce
        unchecked {
            while (_hasPayloadHash(_receiver, _srcEid, _sender, nonceCursor + 1)) {
                ++nonceCursor;
            }
        }
        return nonceCursor;
    }

    /// @dev checks if the storage slot is not initialized. Assumes computationally infeasible that payload can hash to 0
    function _hasPayloadHash(
        address _receiver,
        uint32 _srcEid,
        bytes32 _sender,
        uint64 _nonce
    ) internal view returns (bool) {
        return inboundPayloadHash[_receiver][_srcEid][_sender][_nonce] != EMPTY_PAYLOAD_HASH;
    }

    /// @dev the caller must provide _nonce to prevent skipping the unintended nonce
    /// @dev it could happen in some race conditions, e.g. to skip nonce 3, but nonce 3 was consumed first
    /// @dev usage: skipping the next nonce to prevent message verification, e.g. skip a message when Precrime throws alerts
    /// @dev if the Oapp wants to skip a verified message, it should call the clear() function instead
    /// @dev after skipping, the lazyInboundNonce is set to the provided nonce, which makes the inboundNonce also the provided nonce
    /// @dev ie. allows the Oapp to increment the lazyInboundNonce without having had that corresponding msg be verified
    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external {
        _assertAuthorized(_oapp);

        if (_nonce != inboundNonce(_oapp, _srcEid, _sender) + 1) revert Errors.LZ_InvalidNonce(_nonce);
        lazyInboundNonce[_oapp][_srcEid][_sender] = _nonce;
        emit InboundNonceSkipped(_srcEid, _sender, _oapp, _nonce);
    }

    /// @dev Marks a packet as verified, but disallows execution until it is re-verified.
    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.
    /// @dev A non-verified nonce can be nilified by passing EMPTY_PAYLOAD_HASH for _payloadHash.
    /// @dev Assumes the computational intractability of finding a payload that hashes to bytes32.max.
    /// @dev Authenticated by the caller
    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {
        _assertAuthorized(_oapp);

        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];
        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);
        if (_nonce <= lazyInboundNonce[_oapp][_srcEid][_sender] && curPayloadHash == EMPTY_PAYLOAD_HASH)
            revert Errors.LZ_InvalidNonce(_nonce);
        // set it to nil
        inboundPayloadHash[_oapp][_srcEid][_sender][_nonce] = NIL_PAYLOAD_HASH;
        emit PacketNilified(_srcEid, _sender, _oapp, _nonce, _payloadHash);
    }

    /// @dev Marks a nonce as unexecutable and un-verifiable. The nonce can never be re-verified or executed.
    /// @dev Reverts if the provided _payloadHash does not match the currently verified payload hash.
    /// @dev Only packets with nonces less than or equal to the lazy inbound nonce can be burned.
    /// @dev Reverts if the nonce has already been executed.
    /// @dev Authenticated by the caller
    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external {
        _assertAuthorized(_oapp);

        bytes32 curPayloadHash = inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];
        if (curPayloadHash != _payloadHash) revert Errors.LZ_PayloadHashNotFound(curPayloadHash, _payloadHash);
        if (curPayloadHash == EMPTY_PAYLOAD_HASH || _nonce > lazyInboundNonce[_oapp][_srcEid][_sender])
            revert Errors.LZ_InvalidNonce(_nonce);
        delete inboundPayloadHash[_oapp][_srcEid][_sender][_nonce];
        emit PacketBurnt(_srcEid, _sender, _oapp, _nonce, _payloadHash);
    }

    /// @dev calling this function will clear the stored message and increment the lazyInboundNonce to the provided nonce
    /// @dev if a lot of messages are queued, the messages can be cleared with a smaller step size to prevent OOG
    /// @dev NOTE: this function does not change inboundNonce, it only changes the lazyInboundNonce up to the provided nonce
    function _clearPayload(
        address _receiver,
        uint32 _srcEid,
        bytes32 _sender,
        uint64 _nonce,
        bytes memory _payload
    ) internal returns (bytes32 actualHash) {
        uint64 currentNonce = lazyInboundNonce[_receiver][_srcEid][_sender];
        if (_nonce > currentNonce) {
            unchecked {
                // try to lazily update the inboundNonce till the _nonce
                for (uint64 i = currentNonce + 1; i <= _nonce; ++i) {
                    if (!_hasPayloadHash(_receiver, _srcEid, _sender, i)) revert Errors.LZ_InvalidNonce(i);
                }
                lazyInboundNonce[_receiver][_srcEid][_sender] = _nonce;
            }
        }

        // check the hash of the payload to verify the executor has given the proper payload that has been verified
        actualHash = keccak256(_payload);
        bytes32 expectedHash = inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];
        if (expectedHash != actualHash) revert Errors.LZ_PayloadHashNotFound(expectedHash, actualHash);

        // remove it from the storage
        delete inboundPayloadHash[_receiver][_srcEid][_sender][_nonce];
    }

    /// @dev returns the GUID for the next message given the path
    /// @dev the Oapp might want to include the GUID into the message in some cases
    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32) {
        uint64 nextNonce = outboundNonce[_sender][_dstEid][_receiver] + 1;
        return GUID.generate(nextNonce, eid, _sender, _dstEid, _receiver);
    }

    function _assertAuthorized(address _oapp) internal virtual;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/MessagingComposer.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IMessagingComposer } from "./interfaces/IMessagingComposer.sol";
import { ILayerZeroComposer } from "./interfaces/ILayerZeroComposer.sol";
import { Errors } from "./libs/Errors.sol";

abstract contract MessagingComposer is IMessagingComposer {
    bytes32 private constant NO_MESSAGE_HASH = bytes32(0);
    bytes32 private constant RECEIVED_MESSAGE_HASH = bytes32(uint256(1));

    mapping(address from => mapping(address to => mapping(bytes32 guid => mapping(uint16 index => bytes32 messageHash))))
        public composeQueue;

    /// @dev the Oapp sends the lzCompose message to the endpoint
    /// @dev the composer MUST assert the sender because anyone can send compose msg with this function
    /// @dev with the same GUID, the Oapp can send compose to multiple _composer at the same time
    /// @dev authenticated by the msg.sender
    /// @param _to the address which will receive the composed message
    /// @param _guid the message guid
    /// @param _message the message
    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external {
        // must have not been sent before
        if (composeQueue[msg.sender][_to][_guid][_index] != NO_MESSAGE_HASH) revert Errors.LZ_ComposeExists();
        composeQueue[msg.sender][_to][_guid][_index] = keccak256(_message);
        emit ComposeSent(msg.sender, _to, _guid, _index, _message);
    }

    /// @dev execute a composed messages from the sender to the composer (receiver)
    /// @dev the execution provides the execution context (caller, extraData) to the receiver.
    ///      the receiver can optionally assert the caller and validate the untrusted extraData
    /// @dev can not re-entrant
    /// @param _from the address which sends the composed message. in most cases, it is the Oapp's address.
    /// @param _to the address which receives the composed message
    /// @param _guid the message guid
    /// @param _message the message
    /// @param _extraData the extra data provided by the executor. this data is untrusted and should be validated.
    function lzCompose(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index,
        bytes calldata _message,
        bytes calldata _extraData
    ) external payable {
        // assert the validity
        bytes32 expectedHash = composeQueue[_from][_to][_guid][_index];
        bytes32 actualHash = keccak256(_message);
        if (expectedHash != actualHash) revert Errors.LZ_ComposeNotFound(expectedHash, actualHash);

        // marks the message as received to prevent reentrancy
        // cannot just delete the value, otherwise the message can be sent again and could result in some undefined behaviour
        // even though the sender(composing Oapp) is implicitly fully trusted by the composer.
        // eg. sender may not even realize it has such a bug
        composeQueue[_from][_to][_guid][_index] = RECEIVED_MESSAGE_HASH;
        ILayerZeroComposer(_to).lzCompose{ value: msg.value }(_from, _guid, _message, msg.sender, _extraData);
        emit ComposeDelivered(_from, _to, _guid, _index);
    }

    /// @param _from the address which sends the composed message
    /// @param _to the address which receives the composed message
    /// @param _guid the message guid
    /// @param _message the message
    /// @param _extraData the extra data provided by the executor
    /// @param _reason the reason why the message is not received
    function lzComposeAlert(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index,
        uint256 _gas,
        uint256 _value,
        bytes calldata _message,
        bytes calldata _extraData,
        bytes calldata _reason
    ) external {
        emit LzComposeAlert(_from, _to, msg.sender, _guid, _index, _gas, _value, _message, _extraData, _reason);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/MessagingContext.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IMessagingContext } from "./interfaces/IMessagingContext.sol";
import { Errors } from "./libs/Errors.sol";

/// this contract acts as a non-reentrancy guard and a source of messaging context
/// the context includes the remote eid and the sender address
/// it separates the send and receive context to allow messaging receipts (send back on receive())
abstract contract MessagingContext is IMessagingContext {
    uint256 private constant NOT_ENTERED = 1;
    uint256 private _sendContext = NOT_ENTERED;

    /// @dev the sendContext is set to 8 bytes 0s + 4 bytes eid + 20 bytes sender
    modifier sendContext(uint32 _dstEid, address _sender) {
        if (_sendContext != NOT_ENTERED) revert Errors.LZ_SendReentrancy();
        _sendContext = (uint256(_dstEid) << 160) | uint160(_sender);
        _;
        _sendContext = NOT_ENTERED;
    }

    /// @dev returns true if sending message
    function isSendingMessage() public view returns (bool) {
        return _sendContext != NOT_ENTERED;
    }

    /// @dev returns (eid, sender) if sending message, (0, 0) otherwise
    function getSendContext() external view returns (uint32, address) {
        return isSendingMessage() ? _getSendContext(_sendContext) : (0, address(0));
    }

    function _getSendContext(uint256 _context) internal pure returns (uint32, address) {
        return (uint32(_context >> 160), address(uint160(_context)));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroComposer.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

/**
 * @title ILayerZeroComposer
 */
interface ILayerZeroComposer {
    /**
     * @notice Composes a LayerZero message from an OApp.
     * @param _from The address initiating the composition, typically the OApp where the lzReceive was called.
     * @param _guid The unique identifier for the corresponding LayerZero src/dst tx.
     * @param _message The composed message payload in bytes. NOT necessarily the same payload passed via lzReceive.
     * @param _executor The address of the executor for the composed message.
     * @param _extraData Additional arbitrary data in bytes passed by the entity who executes the lzCompose.
     */
    function lzCompose(
        address _from,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) external payable;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroEndpointV2.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { IMessageLibManager } from "./IMessageLibManager.sol";
import { IMessagingComposer } from "./IMessagingComposer.sol";
import { IMessagingChannel } from "./IMessagingChannel.sol";
import { IMessagingContext } from "./IMessagingContext.sol";

struct MessagingParams {
    uint32 dstEid;
    bytes32 receiver;
    bytes message;
    bytes options;
    bool payInLzToken;
}

struct MessagingReceipt {
    bytes32 guid;
    uint64 nonce;
    MessagingFee fee;
}

struct MessagingFee {
    uint256 nativeFee;
    uint256 lzTokenFee;
}

struct Origin {
    uint32 srcEid;
    bytes32 sender;
    uint64 nonce;
}

interface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {
    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);

    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);

    event PacketDelivered(Origin origin, address receiver);

    event LzReceiveAlert(
        address indexed receiver,
        address indexed executor,
        Origin origin,
        bytes32 guid,
        uint256 gas,
        uint256 value,
        bytes message,
        bytes extraData,
        bytes reason
    );

    event LzTokenSet(address token);

    event DelegateSet(address sender, address delegate);

    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);

    function send(
        MessagingParams calldata _params,
        address _refundAddress
    ) external payable returns (MessagingReceipt memory);

    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;

    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);

    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);

    function lzReceive(
        Origin calldata _origin,
        address _receiver,
        bytes32 _guid,
        bytes calldata _message,
        bytes calldata _extraData
    ) external payable;

    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order
    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;

    function setLzToken(address _lzToken) external;

    function lzToken() external view returns (address);

    function nativeToken() external view returns (address);

    function setDelegate(address _delegate) external;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/ILayerZeroReceiver.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { Origin } from "./ILayerZeroEndpointV2.sol";

interface ILayerZeroReceiver {
    function allowInitializePath(Origin calldata _origin) external view returns (bool);

    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);

    function lzReceive(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) external payable;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessageLib.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import { SetConfigParam } from "./IMessageLibManager.sol";

enum MessageLibType {
    Send,
    Receive,
    SendAndReceive
}

interface IMessageLib is IERC165 {
    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;

    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);

    function isSupportedEid(uint32 _eid) external view returns (bool);

    // message libs of same major version are compatible
    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);

    function messageLibType() external view returns (MessageLibType);
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessageLibManager.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

struct SetConfigParam {
    uint32 eid;
    uint32 configType;
    bytes config;
}

interface IMessageLibManager {
    struct Timeout {
        address lib;
        uint256 expiry;
    }

    event LibraryRegistered(address newLib);
    event DefaultSendLibrarySet(uint32 eid, address newLib);
    event DefaultReceiveLibrarySet(uint32 eid, address newLib);
    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);
    event SendLibrarySet(address sender, uint32 eid, address newLib);
    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);
    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);

    function registerLibrary(address _lib) external;

    function isRegisteredLibrary(address _lib) external view returns (bool);

    function getRegisteredLibraries() external view returns (address[] memory);

    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;

    function defaultSendLibrary(uint32 _eid) external view returns (address);

    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _timeout) external;

    function defaultReceiveLibrary(uint32 _eid) external view returns (address);

    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;

    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);

    function isSupportedEid(uint32 _eid) external view returns (bool);

    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);

    /// ------------------- OApp interfaces -------------------
    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;

    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);

    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);

    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;

    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);

    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _gracePeriod) external;

    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);

    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;

    function getConfig(
        address _oapp,
        address _lib,
        uint32 _eid,
        uint32 _configType
    ) external view returns (bytes memory config);
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessagingChannel.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface IMessagingChannel {
    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);
    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);
    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);

    function eid() external view returns (uint32);

    // this is an emergency function if a message cannot be verified for some reasons
    // required to provide _nextNonce to avoid race condition
    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;

    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;

    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;

    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);

    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);

    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);

    function inboundPayloadHash(
        address _receiver,
        uint32 _srcEid,
        bytes32 _sender,
        uint64 _nonce
    ) external view returns (bytes32);

    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessagingComposer.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface IMessagingComposer {
    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);
    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);
    event LzComposeAlert(
        address indexed from,
        address indexed to,
        address indexed executor,
        bytes32 guid,
        uint16 index,
        uint256 gas,
        uint256 value,
        bytes message,
        bytes extraData,
        bytes reason
    );

    function composeQueue(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index
    ) external view returns (bytes32 messageHash);

    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;

    function lzCompose(
        address _from,
        address _to,
        bytes32 _guid,
        uint16 _index,
        bytes calldata _message,
        bytes calldata _extraData
    ) external payable;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/IMessagingContext.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

interface IMessagingContext {
    function isSendingMessage() external view returns (bool);

    function getSendContext() external view returns (uint32 dstEid, address sender);
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/interfaces/ISendLib.sol
================================================================================

// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0;

import { MessagingFee } from "./ILayerZeroEndpointV2.sol";
import { IMessageLib } from "./IMessageLib.sol";

struct Packet {
    uint64 nonce;
    uint32 srcEid;
    address sender;
    uint32 dstEid;
    bytes32 receiver;
    bytes32 guid;
    bytes message;
}

interface ISendLib is IMessageLib {
    function send(
        Packet calldata _packet,
        bytes calldata _options,
        bool _payInLzToken
    ) external returns (MessagingFee memory, bytes memory encodedPacket);

    function quote(
        Packet calldata _packet,
        bytes calldata _options,
        bool _payInLzToken
    ) external view returns (MessagingFee memory);

    function setTreasury(address _treasury) external;

    function withdrawFee(address _to, uint256 _amount) external;

    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/libs/AddressCast.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

library AddressCast {
    error AddressCast_InvalidSizeForAddress();
    error AddressCast_InvalidAddress();

    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {
        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();
        result = bytes32(_addressBytes);
        unchecked {
            uint256 offset = 32 - _addressBytes.length;
            result = result >> (offset * 8);
        }
    }

    function toBytes32(address _address) internal pure returns (bytes32 result) {
        result = bytes32(uint256(uint160(_address)));
    }

    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {
        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();
        result = new bytes(_size);
        unchecked {
            uint256 offset = 256 - _size * 8;
            assembly {
                mstore(add(result, 32), shl(offset, _addressBytes32))
            }
        }
    }

    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {
        result = address(uint160(uint256(_addressBytes32)));
    }

    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {
        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();
        result = address(bytes20(_addressBytes));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/libs/CalldataBytesLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

library CalldataBytesLib {
    function toU8(bytes calldata _bytes, uint256 _start) internal pure returns (uint8) {
        return uint8(_bytes[_start]);
    }

    function toU16(bytes calldata _bytes, uint256 _start) internal pure returns (uint16) {
        unchecked {
            uint256 end = _start + 2;
            return uint16(bytes2(_bytes[_start:end]));
        }
    }

    function toU32(bytes calldata _bytes, uint256 _start) internal pure returns (uint32) {
        unchecked {
            uint256 end = _start + 4;
            return uint32(bytes4(_bytes[_start:end]));
        }
    }

    function toU64(bytes calldata _bytes, uint256 _start) internal pure returns (uint64) {
        unchecked {
            uint256 end = _start + 8;
            return uint64(bytes8(_bytes[_start:end]));
        }
    }

    function toU128(bytes calldata _bytes, uint256 _start) internal pure returns (uint128) {
        unchecked {
            uint256 end = _start + 16;
            return uint128(bytes16(_bytes[_start:end]));
        }
    }

    function toU256(bytes calldata _bytes, uint256 _start) internal pure returns (uint256) {
        unchecked {
            uint256 end = _start + 32;
            return uint256(bytes32(_bytes[_start:end]));
        }
    }

    function toAddr(bytes calldata _bytes, uint256 _start) internal pure returns (address) {
        unchecked {
            uint256 end = _start + 20;
            return address(bytes20(_bytes[_start:end]));
        }
    }

    function toB32(bytes calldata _bytes, uint256 _start) internal pure returns (bytes32) {
        unchecked {
            uint256 end = _start + 32;
            return bytes32(_bytes[_start:end]);
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/libs/Errors.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

library Errors {
    error LZ_LzTokenUnavailable();
    error LZ_InvalidReceiveLibrary();
    error LZ_InvalidNonce(uint64 nonce);
    error LZ_InvalidArgument();
    error LZ_InvalidExpiry();
    error LZ_InvalidAmount(uint256 required, uint256 supplied);
    error LZ_OnlyRegisteredOrDefaultLib();
    error LZ_OnlyRegisteredLib();
    error LZ_OnlyNonDefaultLib();
    error LZ_Unauthorized();
    error LZ_DefaultSendLibUnavailable();
    error LZ_DefaultReceiveLibUnavailable();
    error LZ_PathNotInitializable();
    error LZ_PathNotVerifiable();
    error LZ_OnlySendLib();
    error LZ_OnlyReceiveLib();
    error LZ_UnsupportedEid();
    error LZ_UnsupportedInterface();
    error LZ_AlreadyRegistered();
    error LZ_SameValue();
    error LZ_InvalidPayloadHash();
    error LZ_PayloadHashNotFound(bytes32 expected, bytes32 actual);
    error LZ_ComposeNotFound(bytes32 expected, bytes32 actual);
    error LZ_ComposeExists();
    error LZ_SendReentrancy();
    error LZ_NotImplemented();
    error LZ_InsufficientFee(
        uint256 requiredNative,
        uint256 suppliedNative,
        uint256 requiredLzToken,
        uint256 suppliedLzToken
    );
    error LZ_ZeroLzTokenFee();
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/libs/GUID.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { AddressCast } from "./AddressCast.sol";

library GUID {
    using AddressCast for address;

    function generate(
        uint64 _nonce,
        uint32 _srcEid,
        address _sender,
        uint32 _dstEid,
        bytes32 _receiver
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_nonce, _srcEid, _sender.toBytes32(), _dstEid, _receiver));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/libs/Transfer.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

library Transfer {
    using SafeERC20 for IERC20;

    address internal constant ADDRESS_ZERO = address(0);

    error Transfer_NativeFailed(address _to, uint256 _value);
    error Transfer_ToAddressIsZero();

    function native(address _to, uint256 _value) internal {
        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();
        (bool success, ) = _to.call{ value: _value }("");
        if (!success) revert Transfer_NativeFailed(_to, _value);
    }

    function token(address _token, address _to, uint256 _value) internal {
        if (_to == ADDRESS_ZERO) revert Transfer_ToAddressIsZero();
        IERC20(_token).safeTransfer(_to, _value);
    }

    function nativeOrToken(address _token, address _to, uint256 _value) internal {
        if (_token == ADDRESS_ZERO) {
            native(_to, _value);
        } else {
            token(_token, _to, _value);
        }
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/messagelib/BlockedMessageLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { ERC165 } from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import { IMessageLib, MessageLibType } from "../interfaces/IMessageLib.sol";
import { Errors } from "../libs/Errors.sol";

contract BlockedMessageLib is ERC165 {
    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (type(uint64).max, type(uint8).max, 2);
    }

    function messageLibType() external pure returns (MessageLibType) {
        return MessageLibType.SendAndReceive;
    }

    function isSupportedEid(uint32) external pure returns (bool) {
        return true;
    }

    fallback() external {
        revert Errors.LZ_NotImplemented();
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/messagelib/SimpleMessageLib.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { ERC165 } from "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { IMessageLib, MessageLibType } from "../interfaces/IMessageLib.sol";
import { Packet } from "../interfaces/ISendLib.sol";
import { ILayerZeroEndpointV2, MessagingFee, Origin } from "../interfaces/ILayerZeroEndpointV2.sol";
import { Errors } from "../libs/Errors.sol";
import { PacketV1Codec } from "./libs/PacketV1Codec.sol";
import { Transfer } from "../libs/Transfer.sol";

contract SimpleMessageLib is Ownable, ERC165 {
    using SafeERC20 for IERC20;
    using PacketV1Codec for bytes;

    address public immutable endpoint;
    address public immutable treasury;
    uint32 public immutable localEid;
    uint8 public constant PACKET_VERSION = 1;

    address public whitelistCaller;

    uint256 public lzTokenFee;
    uint256 public nativeFee;

    bytes public defaultOption;

    error OnlyEndpoint();
    error OnlyWhitelistCaller();
    error InvalidEndpoint(address expected, address actual);
    error ToIsAddressZero();
    error LzTokenIsAddressZero();
    error TransferFailed();

    // only the endpoint can call SEND() and setConfig()
    modifier onlyEndpoint() {
        if (endpoint != msg.sender) {
            revert OnlyEndpoint();
        }
        _;
    }

    constructor(address _endpoint, address _treasury) {
        endpoint = _endpoint;
        treasury = _treasury;
        localEid = ILayerZeroEndpointV2(_endpoint).eid();
        lzTokenFee = 99;
        nativeFee = 100;
        //        defaultOption = Options.encodeLegacyOptionsType1(200000);
    }

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return interfaceId == type(IMessageLib).interfaceId || super.supportsInterface(interfaceId);
    }

    // no validation logic at all
    function validatePacket(bytes calldata packetBytes) external {
        if (whitelistCaller != address(0x0) && msg.sender != whitelistCaller) {
            revert OnlyWhitelistCaller();
        }
        Origin memory origin = Origin(packetBytes.srcEid(), packetBytes.sender(), packetBytes.nonce());
        ILayerZeroEndpointV2(endpoint).verify(origin, packetBytes.receiverB20(), keccak256(packetBytes.payload()));
    }

    // ------------------ onlyEndpoint ------------------
    function send(
        Packet calldata _packet,
        bytes memory _options,
        bool _payInLzToken
    ) external onlyEndpoint returns (MessagingFee memory fee, bytes memory encodedPacket, bytes memory options) {
        encodedPacket = PacketV1Codec.encode(_packet);

        options = _options.length == 0 ? defaultOption : _options;
        _handleMessagingParamsHook(encodedPacket, options);

        fee = MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);
    }

    // ------------------ onlyOwner ------------------
    function setDefaultOption(bytes memory _defaultOption) external onlyOwner {
        defaultOption = _defaultOption;
    }

    function setMessagingFee(uint256 _nativeFee, uint256 _lzTokenFee) external onlyOwner {
        nativeFee = _nativeFee;
        lzTokenFee = _lzTokenFee;
    }

    function setWhitelistCaller(address _whitelistCaller) external onlyOwner {
        whitelistCaller = _whitelistCaller;
    }

    function withdrawFee(address _to, uint256 _amount) external onlyOwner {
        if (_to == address(0x0)) {
            revert ToIsAddressZero();
        }

        address altTokenAddr = ILayerZeroEndpointV2(endpoint).nativeToken();

        // transfers native if altTokenAddr == address(0x0)
        Transfer.nativeOrToken(altTokenAddr, _to, _amount);
    }

    function withdrawLzTokenFee(address _to, uint256 _amount) external onlyOwner {
        if (_to == address(0x0)) {
            revert ToIsAddressZero();
        }
        address lzToken = ILayerZeroEndpointV2(endpoint).lzToken();
        if (lzToken == address(0x0)) {
            revert LzTokenIsAddressZero();
        }
        IERC20(lzToken).safeTransfer(_to, _amount);
    }

    // ------------------ View ------------------
    function quote(
        Packet calldata /*_packet*/,
        bytes calldata /*_options*/,
        bool _payInLzToken
    ) external view returns (MessagingFee memory) {
        return MessagingFee(nativeFee, _payInLzToken ? lzTokenFee : 0);
    }

    function isSupportedEid(uint32) external pure returns (bool) {
        return true;
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (0, 0, 2);
    }

    function messageLibType() external pure returns (MessageLibType) {
        return MessageLibType.SendAndReceive;
    }

    // ------------------ Internal ------------------
    function _handleMessagingParamsHook(bytes memory _encodedPacket, bytes memory _options) internal virtual {}

    fallback() external payable {
        revert Errors.LZ_NotImplemented();
    }

    receive() external payable {}
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/messagelib/libs/BitMaps.sol
================================================================================

// SPDX-License-Identifier: MIT

// modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/BitMaps.sol
pragma solidity ^0.8.20;

type BitMap256 is uint256;

using BitMaps for BitMap256 global;

library BitMaps {
    /**
     * @dev Returns whether the bit at `index` is set.
     */
    function get(BitMap256 bitmap, uint8 index) internal pure returns (bool) {
        uint256 mask = 1 << index;
        return BitMap256.unwrap(bitmap) & mask != 0;
    }

    /**
     * @dev Sets the bit at `index`.
     */
    function set(BitMap256 bitmap, uint8 index) internal pure returns (BitMap256) {
        uint256 mask = 1 << index;
        return BitMap256.wrap(BitMap256.unwrap(bitmap) | mask);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/messagelib/libs/ExecutorOptions.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { CalldataBytesLib } from "../../libs/CalldataBytesLib.sol";

library ExecutorOptions {
    using CalldataBytesLib for bytes;

    uint8 internal constant WORKER_ID = 1;

    uint8 internal constant OPTION_TYPE_LZRECEIVE = 1;
    uint8 internal constant OPTION_TYPE_NATIVE_DROP = 2;
    uint8 internal constant OPTION_TYPE_LZCOMPOSE = 3;
    uint8 internal constant OPTION_TYPE_ORDERED_EXECUTION = 4;

    error Executor_InvalidLzReceiveOption();
    error Executor_InvalidNativeDropOption();
    error Executor_InvalidLzComposeOption();

    /// @dev decode the next executor option from the options starting from the specified cursor
    /// @param _options [executor_id][executor_option][executor_id][executor_option]...
    ///        executor_option = [option_size][option_type][option]
    ///        option_size = len(option_type) + len(option)
    ///        executor_id: uint8, option_size: uint16, option_type: uint8, option: bytes
    /// @param _cursor the cursor to start decoding from
    /// @return optionType the type of the option
    /// @return option the option of the executor
    /// @return cursor the cursor to start decoding the next executor option
    function nextExecutorOption(
        bytes calldata _options,
        uint256 _cursor
    ) internal pure returns (uint8 optionType, bytes calldata option, uint256 cursor) {
        unchecked {
            // skip worker id
            cursor = _cursor + 1;

            // read option size
            uint16 size = _options.toU16(cursor);
            cursor += 2;

            // read option type
            optionType = _options.toU8(cursor);

            // startCursor and endCursor are used to slice the option from _options
            uint256 startCursor = cursor + 1; // skip option type
            uint256 endCursor = cursor + size;
            option = _options[startCursor:endCursor];
            cursor += size;
        }
    }

    function decodeLzReceiveOption(bytes calldata _option) internal pure returns (uint128 gas, uint128 value) {
        if (_option.length != 16 && _option.length != 32) revert Executor_InvalidLzReceiveOption();
        gas = _option.toU128(0);
        value = _option.length == 32 ? _option.toU128(16) : 0;
    }

    function decodeNativeDropOption(bytes calldata _option) internal pure returns (uint128 amount, bytes32 receiver) {
        if (_option.length != 48) revert Executor_InvalidNativeDropOption();
        amount = _option.toU128(0);
        receiver = _option.toB32(16);
    }

    function decodeLzComposeOption(
        bytes calldata _option
    ) internal pure returns (uint16 index, uint128 gas, uint128 value) {
        if (_option.length != 18 && _option.length != 34) revert Executor_InvalidLzComposeOption();
        index = _option.toU16(0);
        gas = _option.toU128(2);
        value = _option.length == 34 ? _option.toU128(18) : 0;
    }

    function encodeLzReceiveOption(uint128 _gas, uint128 _value) internal pure returns (bytes memory) {
        return _value == 0 ? abi.encodePacked(_gas) : abi.encodePacked(_gas, _value);
    }

    function encodeNativeDropOption(uint128 _amount, bytes32 _receiver) internal pure returns (bytes memory) {
        return abi.encodePacked(_amount, _receiver);
    }

    function encodeLzComposeOption(uint16 _index, uint128 _gas, uint128 _value) internal pure returns (bytes memory) {
        return _value == 0 ? abi.encodePacked(_index, _gas) : abi.encodePacked(_index, _gas, _value);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/contracts/messagelib/libs/PacketV1Codec.sol
================================================================================

// SPDX-License-Identifier: LZBL-1.2

pragma solidity ^0.8.20;

import { Packet } from "../../interfaces/ISendLib.sol";
import { AddressCast } from "../../libs/AddressCast.sol";

library PacketV1Codec {
    using AddressCast for address;
    using AddressCast for bytes32;

    uint8 internal constant PACKET_VERSION = 1;

    // header (version + nonce + path)
    // version
    uint256 private constant PACKET_VERSION_OFFSET = 0;
    //    nonce
    uint256 private constant NONCE_OFFSET = 1;
    //    path
    uint256 private constant SRC_EID_OFFSET = 9;
    uint256 private constant SENDER_OFFSET = 13;
    uint256 private constant DST_EID_OFFSET = 45;
    uint256 private constant RECEIVER_OFFSET = 49;
    // payload (guid + message)
    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)
    uint256 private constant MESSAGE_OFFSET = 113;

    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {
        encodedPacket = abi.encodePacked(
            PACKET_VERSION,
            _packet.nonce,
            _packet.srcEid,
            _packet.sender.toBytes32(),
            _packet.dstEid,
            _packet.receiver,
            _packet.guid,
            _packet.message
        );
    }

    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {
        return
            abi.encodePacked(
                PACKET_VERSION,
                _packet.nonce,
                _packet.srcEid,
                _packet.sender.toBytes32(),
                _packet.dstEid,
                _packet.receiver
            );
    }

    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {
        return abi.encodePacked(_packet.guid, _packet.message);
    }

    function header(bytes calldata _packet) internal pure returns (bytes calldata) {
        return _packet[0:GUID_OFFSET];
    }

    function version(bytes calldata _packet) internal pure returns (uint8) {
        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));
    }

    function nonce(bytes calldata _packet) internal pure returns (uint64) {
        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));
    }

    function srcEid(bytes calldata _packet) internal pure returns (uint32) {
        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));
    }

    function sender(bytes calldata _packet) internal pure returns (bytes32) {
        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);
    }

    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {
        return sender(_packet).toAddress();
    }

    function dstEid(bytes calldata _packet) internal pure returns (uint32) {
        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));
    }

    function receiver(bytes calldata _packet) internal pure returns (bytes32) {
        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);
    }

    function receiverB20(bytes calldata _packet) internal pure returns (address) {
        return receiver(_packet).toAddress();
    }

    function guid(bytes calldata _packet) internal pure returns (bytes32) {
        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);
    }

    function message(bytes calldata _packet) internal pure returns (bytes calldata) {
        return bytes(_packet[MESSAGE_OFFSET:]);
    }

    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {
        return bytes(_packet[GUID_OFFSET:]);
    }

    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {
        return keccak256(payload(_packet));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/BlockedMessageLib.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { AddressCast } from "../contracts/libs/AddressCast.sol";
import { MessagingParams } from "../contracts/interfaces/ILayerZeroEndpointV2.sol";
import { Errors } from "../contracts/libs/Errors.sol";

import { LayerZeroTest } from "./utils/LayerZeroTest.sol";

contract BlockedMessageLibTest is LayerZeroTest {
    function setUp() public override {
        super.setUp();
        setDefaultMsgLib(endpoint, blockedLibrary, remoteEid);
    }

    function test_Revert_Send() public {
        address payable receiver = payable(address(0x1));
        MessagingParams memory msgParams = MessagingParams(
            remoteEid,
            AddressCast.toBytes32(receiver),
            abi.encodePacked("message"),
            "0x",
            false
        );
        vm.expectRevert(Errors.LZ_NotImplemented.selector);
        endpoint.send{ value: 101 }(msgParams, receiver);
    }

    function test_Revert_Quote() public {
        address sender = address(0x1);
        MessagingParams memory msgParams = MessagingParams(remoteEid, bytes32(0), "", "", false);
        vm.expectRevert(Errors.LZ_NotImplemented.selector);
        endpoint.quote(msgParams, sender);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/EndpointV2.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import { AddressCast } from "../contracts/libs/AddressCast.sol";
import { MessagingFee, MessagingParams, MessagingReceipt, Origin, ILayerZeroEndpointV2 } from "../contracts/interfaces/ILayerZeroEndpointV2.sol";
import { EndpointV2 } from "../contracts/EndpointV2.sol";
import { SimpleMessageLib } from "../contracts/messagelib/SimpleMessageLib.sol";
import { Errors } from "../contracts/libs/Errors.sol";

import { LayerZeroTest } from "./utils/LayerZeroTest.sol";
import { OAppMock } from "./mocks/AppMock.sol";
import { TokenMock } from "./mocks/TokenMock.sol";

contract EndpointV2Test is LayerZeroTest {
    event LzReceiveFailed(Origin origin, address receiver, bytes reason);

    ERC20 internal lzToken;

    OAppMock internal oapp;
    address internal sender;
    bytes32 internal senderB32;
    address payable internal refundAddress;
    address internal receiver;
    bytes32 internal receiverB32;
    address internal delegate;
    bytes internal message;
    bytes32 internal guid;
    bytes internal payload;
    bytes32 internal payloadHash;

    mapping(uint64 => bool) recommittableNonces;

    function setUp() public override {
        super.setUp();
        lzToken = new TokenMock(1000);

        oapp = new OAppMock(address(endpoint));
        sender = address(this);
        senderB32 = AddressCast.toBytes32(sender);
        refundAddress = payable(address(123));
        receiver = address(oapp);
        receiverB32 = AddressCast.toBytes32(receiver);
        delegate = address(456);

        message = "foo";
        guid = keccak256("guid");
        payload = abi.encodePacked(guid, message);
        payloadHash = keccak256(payload);
    }

    function test_quote() public {
        MessagingParams memory msgParams = MessagingParams(remoteEid, bytes32(0), message, "", false);
        // quote native only
        MessagingFee memory msgFee = endpoint.quote(msgParams, sender);
        assertEq(msgFee.nativeFee, 100);
        assertEq(msgFee.lzTokenFee, 0);

        // fail to pay lz token due to endpoint not supporting lz token
        msgParams.payInLzToken = true;
        vm.expectRevert(Errors.LZ_LzTokenUnavailable.selector);
        endpoint.quote(msgParams, sender);

        // enable lz token and quote again
        endpoint.setLzToken(address(lzToken));
        msgFee = endpoint.quote(msgParams, sender);
        assertEq(msgFee.nativeFee, 100);
        assertEq(msgFee.lzTokenFee, 99);
    }

    function test_sendWithNative() public {
        MessagingParams memory msgParams = MessagingParams(remoteEid, receiverB32, message, "", false);

        // assert the PacketSent event
        vm.expectEmit(false, false, false, true, address(endpoint));
        bytes memory expectedPacket = newAndEncodePacket(1, localEid, sender, remoteEid, receiverB32, message);
        emit ILayerZeroEndpointV2.PacketSent(expectedPacket, "", address(simpleMsgLib));

        // send with 200 native, but refund 100
        MessagingReceipt memory receipt = endpoint.send{ value: 200 }(msgParams, refundAddress);
        assertEq(receipt.fee.nativeFee, 100);
        assertEq(receipt.fee.lzTokenFee, 0);

        // the balance of both msglib and refund should be 100, but endpoint should be 0
        assertEq(address(simpleMsgLib).balance, 100);
        assertEq(address(refundAddress).balance, 100);
        assertEq(address(endpoint).balance, 0);

        // fail to send with lz token
        msgParams.payInLzToken = true;
        vm.expectRevert(Errors.LZ_LzTokenUnavailable.selector);
        endpoint.send{ value: 200 }(msgParams, refundAddress);

        // fail for insufficient fee
        msgParams.payInLzToken = false;
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InsufficientFee.selector, 100, 99, 0, 0));
        endpoint.send{ value: 99 }(msgParams, refundAddress);
    }

    function test_sendWithNativeAndLzToken() public {
        // enable lz token and send lz token to endpoint
        endpoint.setLzToken(address(lzToken));
        lzToken.transfer(address(endpoint), 200);

        // send with 200 native and 200, but the endpoint only accept 100 native and 99 lz token
        MessagingParams memory msgParams = MessagingParams(remoteEid, receiverB32, message, "", true);
        MessagingReceipt memory receipt = endpoint.send{ value: 200 }(msgParams, refundAddress);
        assertEq(receipt.fee.nativeFee, 100);
        assertEq(receipt.fee.lzTokenFee, 99);

        // native balance of both msglib and refund should be 100, but endpoint should be 0
        assertEq(address(simpleMsgLib).balance, 100);
        assertEq(address(refundAddress).balance, 100);
        assertEq(address(endpoint).balance, 0);

        // lz token balance of msglib should be 99, but endpoint should be 0
        assertEq(lzToken.balanceOf(address(simpleMsgLib)), 99);
        assertEq(lzToken.balanceOf(address(endpoint)), 0);

        // fail for insufficient lz token
        lzToken.transfer(address(endpoint), 98);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InsufficientFee.selector, 100, 200, 99, 98));
        endpoint.send{ value: 200 }(msgParams, refundAddress);
    }

    function test_verify() public {
        Origin memory origin = Origin(remoteEid, senderB32, 1);

        // fail to verify by an invalid msglib
        vm.prank(address(0x1));
        vm.expectRevert(Errors.LZ_InvalidReceiveLibrary.selector);
        endpoint.verify(origin, receiver, payloadHash);

        vm.prank(address(simpleMsgLib));
        vm.expectEmit(false, false, false, true, address(endpoint));
        emit ILayerZeroEndpointV2.PacketVerified(origin, receiver, payloadHash);
        endpoint.verify(origin, receiver, payloadHash);
        assertEq(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1), payloadHash);

        // re-verify different payload with same nonce
        bytes32 newPayloadHash = keccak256("newPayload");
        vm.prank(address(simpleMsgLib));
        endpoint.verify(origin, receiver, newPayloadHash);
        assertEq(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1), newPayloadHash);
    }

    function test_lzReceive() public {
        // verify a payload to receive
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        endpoint.verify(origin, receiver, payloadHash);
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));

        // receive and clear payload
        vm.expectEmit(false, false, false, true, address(endpoint));
        emit ILayerZeroEndpointV2.PacketDelivered(origin, receiver);
        endpoint.lzReceive(origin, receiver, guid, message, "");
        assertFalse(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));
    }

    // This test should cover *all* cases where a payload hash can and cannot be recommitted to the messaging channel
    function test_recommitVerification() public {
        /* Populate the channel first
           1      | 2       | 3        | 4        | 5         | 6        | 7
           Burned | Skipped | Nilified | Verified | Executed  | Verified | Nilified
                  |         |          |          | LazyNonce |          | InboundNonce
        */
        vm.startPrank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        endpoint.verify(origin, receiver, payloadHash);

        vm.startPrank(receiver);
        endpoint.skip(receiver, remoteEid, senderB32, 2);
        endpoint.nilify(receiver, remoteEid, senderB32, 3, bytes32(0x0));

        vm.startPrank(address(simpleMsgLib));
        origin = Origin(remoteEid, senderB32, 4);
        endpoint.verify(origin, receiver, payloadHash);
        origin = Origin(remoteEid, senderB32, 5);
        endpoint.verify(origin, receiver, payloadHash);
        endpoint.lzReceive(origin, receiver, guid, message, "");
        origin = Origin(remoteEid, senderB32, 6);
        endpoint.verify(origin, receiver, payloadHash);

        vm.startPrank(receiver);
        endpoint.nilify(receiver, remoteEid, senderB32, 7, bytes32(0x0));
        endpoint.burn(receiver, remoteEid, senderB32, 1, payloadHash);

        vm.stopPrank();

        // Exactly-once delivery: cannot recommit an executed or skipped nonce
        // All other nonces should be recommittable
        recommittableNonces[1] = false;
        recommittableNonces[2] = false;
        recommittableNonces[3] = true;
        recommittableNonces[4] = true;
        recommittableNonces[5] = false;
        recommittableNonces[6] = true;
        recommittableNonces[7] = true;
        recommittableNonces[8] = true;
        for (uint64 _nonce = 0; _nonce <= 8; ++_nonce) {
            vm.prank(address(simpleMsgLib));
            origin = Origin(remoteEid, senderB32, _nonce);
            if (!recommittableNonces[_nonce]) {
                vm.expectRevert(Errors.LZ_PathNotVerifiable.selector);
            }
            endpoint.verify(origin, receiver, payloadHash);
        }
    }

    function test_initializePathway() public {
        // Temporarily blacklist the pathway before any messages are sent
        oapp.blacklistPathway(remoteEid, senderB32);

        vm.startPrank(address(simpleMsgLib));
        Origin memory originNonceOne = Origin(remoteEid, senderB32, 1);
        Origin memory originNonceTwo = Origin(remoteEid, senderB32, 2);
        // Pathway cannot verify the first nonce until OApp returns allowInitializePath = true
        vm.expectRevert(Errors.LZ_PathNotInitializable.selector);
        endpoint.verify(originNonceOne, receiver, payloadHash);

        // Pathway can verify the first nonce now that OApp returned allowInitializePath = true
        oapp.unBlacklistPathway(remoteEid, senderB32);
        endpoint.verify(originNonceOne, receiver, payloadHash);

        oapp.blacklistPathway(remoteEid, senderB32);
        vm.expectRevert(Errors.LZ_PathNotInitializable.selector);
        endpoint.verify(originNonceOne, receiver, payloadHash);

        // Pathway cannot be "closed" once one (or more) nonces have been executed
        endpoint.lzReceive(originNonceOne, receiver, guid, message, "");
        endpoint.verify(originNonceTwo, receiver, payloadHash);
    }

    function test_lzReceiveFail() public {
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        bytes memory invalidMsg = bytes("Invalid message");
        bytes32 invalidPayloadHash = keccak256(abi.encodePacked(guid, invalidMsg));

        // verify an invalid payload
        endpoint.verify(origin, receiver, invalidPayloadHash);
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));

        // fund the executor
        address executor = address(0xdead);
        vm.deal(executor, 100);
        vm.prank(executor);

        // mock the executor call the lzReceive() with 100 value
        // fail to receive due to app revert when the message is not "foo"
        // payload should not be cleared and refund the value
        vm.expectRevert();
        endpoint.lzReceive{ value: 100 }(origin, receiver, guid, invalidMsg, "");
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));
        assertEq(address(executor).balance, 100);
    }

    function _test_clear(address _delegate) internal {
        // verify a payload to receive
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        endpoint.verify(origin, receiver, payloadHash);
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));

        // clear payload
        vm.prank(_delegate);
        vm.expectEmit(false, false, false, true, address(endpoint));
        emit ILayerZeroEndpointV2.PacketDelivered(origin, receiver);
        endpoint.clear(receiver, origin, guid, message);
    }

    function test_clear() public {
        _test_clear(receiver);
    }

    function test_clear_delegated() public {
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        endpoint.verify(origin, receiver, payloadHash);
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));
        vm.prank(delegate);
        vm.expectRevert(Errors.LZ_Unauthorized.selector);
        endpoint.clear(receiver, origin, guid, message);

        vm.prank(receiver);
        endpoint.setDelegate(delegate);
        _test_clear(delegate);
    }

    function test_clear_undelegated() public {
        vm.prank(receiver);
        endpoint.setDelegate(delegate);
        _test_clear(receiver);
    }

    function test_setLzToken() public {
        assertEq(endpoint.lzToken(), address(0x0));
        endpoint.setLzToken(address(lzToken));
        assertEq(endpoint.lzToken(), address(lzToken));

        vm.prank(address(1)); // invalid owner
        vm.expectRevert(); // not owner revert
        endpoint.setLzToken(address(0));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/EndpointV2Alt.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import { AddressCast } from "../contracts/libs/AddressCast.sol";
import { MessagingFee, MessagingParams, MessagingReceipt, Origin } from "../contracts/interfaces/ILayerZeroEndpointV2.sol";
import { EndpointV2Alt } from "../contracts/EndpointV2Alt.sol";
import { SimpleMessageLib } from "../contracts/messagelib/SimpleMessageLib.sol";
import { Errors } from "../contracts/libs/Errors.sol";

import { LayerZeroTest } from "./utils/LayerZeroTest.sol";
import { OAppMock } from "./mocks/AppMock.sol";
import { TokenMock } from "./mocks/TokenMock.sol";

contract EndpointV2AltTest is LayerZeroTest {
    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);

    error LZ_OnlyAltToken();

    // endpoint2 is the endpoint with alt token
    EndpointV2Alt internal endpointAlt;
    SimpleMessageLib internal simpleMsgLibAlt;

    ERC20 internal altToken;
    ERC20 internal lzToken;

    OAppMock internal oapp;
    address payable internal refundAddress;
    address internal receiver;
    bytes32 internal receiverB32;
    bytes internal message;

    function setUp() public override {
        super.setUp();
        lzToken = new TokenMock(1000);
        altToken = new TokenMock(1000);

        endpointAlt = setupEndpointAlt(localEid, address(altToken));
        simpleMsgLibAlt = setupSimpleMessageLib(address(endpointAlt), remoteEid, true);
        receiver = address(oapp);
        receiverB32 = AddressCast.toBytes32(receiver);
        message = "foo";
        refundAddress = payable(address(123));
    }

    function test_Send_WithAlt() public {
        // send with 200 alt, but only accept 100 alt
        altToken.transfer(address(endpointAlt), 200);
        MessagingParams memory msgParams = MessagingParams(remoteEid, receiverB32, message, "", false);
        MessagingReceipt memory receipt = endpointAlt.send(msgParams, refundAddress);
        assertEq(receipt.fee.nativeFee, 100);
        assertEq(receipt.fee.lzTokenFee, 0);

        // alt token balance of msglib is 100, but endpoint should be 0
        assertEq(altToken.balanceOf(address(simpleMsgLibAlt)), 100);
        assertEq(altToken.balanceOf(address(endpointAlt)), 0);
        assertEq(altToken.balanceOf(address(refundAddress)), 100);

        // fail for insufficient fee
        altToken.transfer(address(endpointAlt), 99);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InsufficientFee.selector, 100, 99, 0, 0));
        endpointAlt.send(msgParams, refundAddress);

        // fail for sending with value
        altToken.transfer(address(endpointAlt), 100);
        vm.expectRevert(abi.encodeWithSelector(LZ_OnlyAltToken.selector));
        endpointAlt.send{ value: 1 }(msgParams, refundAddress);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/EndpointV2View.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";
import "./utils/LayerZeroTest.sol";
import "./mocks/AppMock.sol";
import "../contracts/EndpointV2View.sol";

contract EndpointV2ViewTest is LayerZeroTest {
    using AddressCast for address;

    bytes32 public constant NIL_PAYLOAD_HASH = bytes32(type(uint256).max);

    OAppMock internal oapp;
    bytes32 internal senderB32;
    address internal receiver;
    bytes internal message;
    bytes32 internal guid;
    bytes32 internal payloadHash;

    EndpointV2View internal endpointView;

    function setUp() public override {
        super.setUp();
        oapp = new OAppMock(address(endpoint));
        senderB32 = address(this).toBytes32();
        receiver = address(oapp);
        message = "foo";
        guid = keccak256("guid");
        payloadHash = keccak256(abi.encodePacked(guid, message));

        endpointView = new EndpointV2View();
        endpointView.initialize(address(endpoint));
    }

    function test_Executable_NotExecutable() public {
        // not verified
        assertEq(
            uint256(endpointView.executable(Origin(remoteEid, senderB32, 1), receiver)),
            uint256(ExecutionState.NotExecutable)
        );
    }

    function test_Executable_VerifiedButNotExecutable() public {
        // verify a payload to receive
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 2);
        endpoint.verify(origin, receiver, payloadHash);

        // verified
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 2) != bytes32(0));

        // not executable, since only nonce 2 is verified and nonce 1 is not
        assertEq(uint256(endpointView.executable(origin, receiver)), uint256(ExecutionState.VerifiedButNotExecutable));
    }

    function test_Executable_NotExecutable_NilPayloadHash() public {
        // verify a payload to receive
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 2);
        endpoint.verify(origin, receiver, payloadHash);
        vm.prank(receiver);
        endpoint.nilify(receiver, origin.srcEid, origin.sender, origin.nonce, payloadHash);

        // verified
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 2) != bytes32(0));

        // not executable and not verified
        assertEq(uint256(endpointView.executable(origin, receiver)), uint256(ExecutionState.NotExecutable));
    }

    function test_Executable_Executable() public {
        // verify a payload to receive
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        endpoint.verify(origin, receiver, payloadHash);

        // verified
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));

        assertEq(uint256(endpointView.executable(origin, receiver)), uint256(ExecutionState.Executable));
    }

    function test_Executable_Executed() public {
        // verify a payload to receive
        vm.prank(address(simpleMsgLib));
        Origin memory origin = Origin(remoteEid, senderB32, 1);
        endpoint.verify(origin, receiver, payloadHash);

        // verified
        assertTrue(endpoint.inboundPayloadHash(receiver, remoteEid, senderB32, 1) != bytes32(0));

        // execute
        endpoint.lzReceive(origin, receiver, guid, message, "");

        assertEq(uint256(endpointView.executable(origin, receiver)), uint256(ExecutionState.Executed));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/MessageLibManager.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Errors } from "../contracts/libs/Errors.sol";

import { LayerZeroTest } from "./utils/LayerZeroTest.sol";
import { MessageLibMock } from "./mocks/MessageLibMock.sol";

import { SetConfigParam } from "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol";

contract MessageLibManagerTest is LayerZeroTest {
    address internal constant OAPP = address(0xdead);
    address internal constant DELEGATE = address(0xbeef);

    address internal msglib;
    address internal newMsglib;
    address internal invalidMsglib;

    function setUp() public override {
        super.setUp();
        msglib = address(simpleMsgLib);
        newMsglib = address(new MessageLibMock(true));
        invalidMsglib = address(new MessageLibMock(false));
    }

    function test_constructor() public {
        assertTrue(endpoint.isRegisteredLibrary(blockedLibrary));
    }

    function test_registerLibraryByNotOwner() public {
        vm.startPrank(address(0x0)); // test not owner
        vm.expectRevert("Ownable: caller is not the owner");
        endpoint.registerLibrary(newMsglib);
        assertFalse(endpoint.isRegisteredLibrary(newMsglib));
    }

    function test_registerLibrary() public {
        endpoint.registerLibrary(newMsglib);
        assertTrue(endpoint.isRegisteredLibrary(newMsglib));

        // cant register again
        vm.expectRevert(Errors.LZ_AlreadyRegistered.selector);
        endpoint.registerLibrary(newMsglib);

        // check all registered libraries
        address[] memory libs = endpoint.getRegisteredLibraries();
        assertEq(libs.length, 3);
        assertEq(libs[0], blockedLibrary);
        assertEq(libs[1], msglib);
        assertEq(libs[2], newMsglib);
    }

    function test_registerInvalidLibrary() public {
        // register an EOA and revert with an empty error message
        vm.expectRevert();
        endpoint.registerLibrary(address(0x1));

        // register a contract without the required interface
        vm.expectRevert(Errors.LZ_UnsupportedInterface.selector);
        endpoint.registerLibrary(invalidMsglib);
    }

    function test_setDefaultSendLibraryByNotOwner() public {
        vm.startPrank(address(0x0)); // not owner
        vm.expectRevert("Ownable: caller is not the owner");
        endpoint.setDefaultSendLibrary(2, msglib);
    }

    function test_setDefaultSendLibraryWithUnregisteredLib() public {
        vm.expectRevert(Errors.LZ_OnlyRegisteredLib.selector);
        endpoint.setDefaultSendLibrary(2, newMsglib);
    }

    function test_setDefaultSendLibrary() public {
        // set new default
        endpoint.setDefaultSendLibrary(2, blockedLibrary);

        address defaultSendLib = endpoint.defaultSendLibrary(2);
        assertEq(defaultSendLib, blockedLibrary);

        bool isDefault = endpoint.isDefaultSendLibrary(address(0x0), 2);
        assertEq(isDefault, true);

        // set default to the same library
        vm.expectRevert(Errors.LZ_SameValue.selector);
        endpoint.setDefaultSendLibrary(2, blockedLibrary);
    }

    function test_setDefaultSendLibraryWithInvalidEid() public {
        endpoint.registerLibrary(newMsglib);
        vm.expectRevert(Errors.LZ_UnsupportedEid.selector);
        endpoint.setDefaultSendLibrary(type(uint32).max, newMsglib);
    }

    function test_setDefaultReceiveLibraryByNotOwner() public {
        vm.startPrank(address(0x0)); // not owner
        vm.expectRevert("Ownable: caller is not the owner");
        endpoint.setDefaultReceiveLibrary(2, msglib, 0);
    }

    function test_setDefaultReceiveLibraryWithUnregisteredLib() public {
        vm.expectRevert(Errors.LZ_OnlyRegisteredLib.selector);
        endpoint.setDefaultReceiveLibrary(2, newMsglib, 0);
    }

    function test_setDefaultReceiveLibrary() public {
        // set new default
        endpoint.setDefaultReceiveLibrary(2, blockedLibrary, 0);

        address defaultReceiveLib = endpoint.defaultReceiveLibrary(2);
        assertEq(defaultReceiveLib, blockedLibrary);

        // set default to the same library
        vm.expectRevert(Errors.LZ_SameValue.selector);
        endpoint.setDefaultReceiveLibrary(2, blockedLibrary, 0);
    }

    function test_setDefaultReceiveLibraryWithInvalidEid() public {
        endpoint.registerLibrary(newMsglib);
        vm.expectRevert(Errors.LZ_UnsupportedEid.selector);
        endpoint.setDefaultReceiveLibrary(type(uint32).max, newMsglib, 0);
    }

    function test_setDefaultReceiveLibraryTimeoutByNotOwner() public {
        vm.startPrank(address(0x0)); // not owner
        vm.expectRevert("Ownable: caller is not the owner");
        endpoint.setDefaultReceiveLibraryTimeout(2, msglib, 0);
    }

    function test_setDefaultReceiveLibraryTimeoutWithUnregisteredLib() public {
        vm.expectRevert(Errors.LZ_OnlyRegisteredLib.selector);
        endpoint.setDefaultReceiveLibraryTimeout(2, newMsglib, 0);
    }

    function test_setDefaultReceiveLibraryTimeoutWithUnsupportedEid() public {
        endpoint.registerLibrary(newMsglib);
        vm.expectRevert(Errors.LZ_UnsupportedEid.selector);
        endpoint.setDefaultReceiveLibraryTimeout(type(uint32).max, newMsglib, 0);
    }

    function test_setDefaultReceiveLibraryTimeoutWithInvalidTimestamp() public {
        vm.roll(10); // set block.number to 10
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidExpiry.selector));
        endpoint.setDefaultReceiveLibraryTimeout(2, blockedLibrary, 9);
    }

    function test_setDefaultReceiveLibraryTimeout() public {
        vm.roll(10); // set block.number to 10

        // change default receive library with 1 grace period
        endpoint.setDefaultReceiveLibrary(2, blockedLibrary, 1);
        (address lastLib, uint256 expiry) = endpoint.defaultReceiveLibraryTimeout(2);
        assertEq(lastLib, msglib);
        assertEq(expiry, 10 + 1);

        // set timeout to 15 and change the timeout library
        endpoint.setDefaultReceiveLibraryTimeout(2, blockedLibrary, 15);
        (lastLib, expiry) = endpoint.defaultReceiveLibraryTimeout(2);
        assertEq(lastLib, blockedLibrary);
        assertEq(expiry, 15);

        // disable timeout
        endpoint.setDefaultReceiveLibraryTimeout(2, msglib, 0);
        (lastLib, expiry) = endpoint.defaultReceiveLibraryTimeout(2);
        assertEq(lastLib, address(0));
        assertEq(expiry, 0);
    }

    function _test_setSendLibrary(address delegate) internal {
        vm.startPrank(delegate);
        endpoint.setSendLibrary(delegate, 2, blockedLibrary);

        address sendLib = endpoint.getSendLibrary(delegate, 2);
        assertEq(sendLib, blockedLibrary);

        bool isDefault = endpoint.isDefaultSendLibrary(delegate, 2);
        assertFalse(isDefault);

        // set to the same library
        vm.expectRevert(Errors.LZ_SameValue.selector);
        endpoint.setSendLibrary(delegate, 2, blockedLibrary);

        // set to the default library
        endpoint.setSendLibrary(delegate, 2, address(0));
        sendLib = endpoint.getSendLibrary(delegate, 2);
        assertEq(sendLib, msglib);
    }

    function test_setSendLibrary() public {
        vm.startPrank(OAPP);
        endpoint.setDelegate(DELEGATE);
        _test_setSendLibrary(OAPP);
    }

    function test_setSendLibrary_delegated() public {
        vm.startPrank(DELEGATE);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_Unauthorized.selector));
        endpoint.setSendLibrary(OAPP, 2, blockedLibrary);
        _test_setSendLibrary(DELEGATE);
    }

    function test_setSendLibraryWithUnregisteredLib() public {
        vm.startPrank(OAPP);
        vm.expectRevert(Errors.LZ_OnlyRegisteredOrDefaultLib.selector);
        endpoint.setSendLibrary(OAPP, 2, newMsglib);
    }

    function test_setSendLibraryWithInvalidEid() public {
        endpoint.registerLibrary(newMsglib);
        vm.startPrank(OAPP);
        vm.expectRevert(Errors.LZ_UnsupportedEid.selector);
        endpoint.setSendLibrary(OAPP, type(uint32).max, newMsglib);
    }

    function test_getSendLibraryWithInvalidEid() public {
        vm.expectRevert(Errors.LZ_DefaultSendLibUnavailable.selector);
        endpoint.getSendLibrary(OAPP, type(uint32).max);
    }

    function _test_setReceiveLibrary(address _delegate) internal {
        vm.startPrank(_delegate);

        // fail to set non-default library with grace period
        vm.expectRevert(Errors.LZ_OnlyNonDefaultLib.selector);
        endpoint.setReceiveLibrary(OAPP, 2, blockedLibrary, 1);

        // set non-default library
        endpoint.setReceiveLibrary(OAPP, 2, blockedLibrary, 0);
        (address receiveLib, bool isDefault) = endpoint.getReceiveLibrary(OAPP, 2);
        assertEq(receiveLib, blockedLibrary);
        assertFalse(isDefault);

        // set to the same library
        vm.expectRevert(Errors.LZ_SameValue.selector);
        endpoint.setReceiveLibrary(OAPP, 2, blockedLibrary, 0);

        // set to the default library
        endpoint.setReceiveLibrary(OAPP, 2, address(0), 0);
        receiveLib = endpoint.getSendLibrary(OAPP, 2);
        assertEq(receiveLib, msglib);
    }

    function test_setReceiveLibrary() public {
        _test_setReceiveLibrary(OAPP);
    }

    function test_setReceiveLibrary_delegated() public {
        vm.startPrank(OAPP);
        endpoint.setDelegate(DELEGATE);
        _test_setReceiveLibrary(DELEGATE);
    }

    function test_setReceiveLibrary_undelegated() public {
        vm.startPrank(OAPP);
        endpoint.setDelegate(DELEGATE);
        _test_setReceiveLibrary(OAPP);
    }

    function test_setReceiveLibrary_unauthorized() public {
        // Should revert if setDelegate not called
        vm.expectRevert();
        _test_setReceiveLibrary(DELEGATE);
    }

    function test_getReceiveLibraryWithInvalidEid() public {
        vm.expectRevert(Errors.LZ_DefaultReceiveLibUnavailable.selector);
        endpoint.getReceiveLibrary(OAPP, type(uint32).max);
    }

    function _test_setReceiveLibraryTimeout(address _delegate) public {
        vm.roll(10); // set block.number to 10
        vm.startPrank(_delegate);

        // change default receive library with 1 grace period
        endpoint.setReceiveLibrary(OAPP, 2, blockedLibrary, 0);
        endpoint.setReceiveLibrary(OAPP, 2, msglib, 1);
        (address lastLib, uint256 expiry) = endpoint.receiveLibraryTimeout(OAPP, 2);
        assertEq(lastLib, blockedLibrary);
        assertEq(expiry, 10 + 1);

        // set timeout to 15 and change the timeout library
        endpoint.setReceiveLibraryTimeout(OAPP, 2, msglib, 15);
        (lastLib, expiry) = endpoint.receiveLibraryTimeout(OAPP, 2);
        assertEq(lastLib, msglib);
        assertEq(expiry, 15);
    }

    function test_setReceiveLibraryTimeout() public {
        _test_setReceiveLibraryTimeout(OAPP);
    }

    function test_setReceiveLibraryTimeout_delegated() public {
        vm.prank(OAPP);
        endpoint.setDelegate(DELEGATE);
        _test_setReceiveLibraryTimeout(DELEGATE);
    }

    function test_setReceiveLibraryTimeout_undelegated() public {
        vm.prank(OAPP);
        endpoint.setDelegate(DELEGATE);
        _test_setReceiveLibraryTimeout(OAPP);
    }

    function test_setReceiveLibraryTimeoutWithUnregisteredLib() public {
        vm.startPrank(OAPP);
        vm.expectRevert(Errors.LZ_OnlyRegisteredLib.selector);
        endpoint.setReceiveLibraryTimeout(OAPP, 2, newMsglib, 0);
    }

    function test_setReceiveLibraryTimeoutWithInvalidEid() public {
        endpoint.registerLibrary(newMsglib);
        vm.startPrank(OAPP);
        vm.expectRevert(Errors.LZ_UnsupportedEid.selector);
        endpoint.setReceiveLibraryTimeout(OAPP, type(uint32).max, newMsglib, 0);
    }

    function test_setReceiveLibraryTimeoutWithInvalidTimestamp() public {
        vm.roll(10); // set block.number to 10
        vm.startPrank(OAPP);
        endpoint.setReceiveLibrary(OAPP, 2, blockedLibrary, 0); // change to non-default library first
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidExpiry.selector));
        endpoint.setReceiveLibraryTimeout(OAPP, 2, msglib, 9); // invalid number
    }

    function test_isValidReceiveLibraryForDefaultLibrary() public {
        // initialize the oapp inside the messageLibManager
        vm.prank(OAPP);

        // default receive library is msglib
        bool isValid = endpoint.isValidReceiveLibrary(OAPP, 2, msglib);
        assertTrue(isValid);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, blockedLibrary);
        assertFalse(isValid);

        // change the default receive library to blockedLibrary with 5 grace period
        // then both msglib and blockedLibrary are valid before number 15
        vm.roll(10); // set block.number to 10
        endpoint.setDefaultReceiveLibrary(2, blockedLibrary, 5);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, msglib);
        assertTrue(isValid);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, blockedLibrary);
        assertTrue(isValid);

        // after number 15, only blockedLibrary is valid
        vm.roll(15);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, msglib);
        assertFalse(isValid);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, blockedLibrary);
        assertTrue(isValid);
    }

    function test_isValidReceiveLibraryForNonDefaultLibrary() public {
        vm.roll(10); // set block.number to 10
        endpoint.registerLibrary(newMsglib); // register a new library

        // oapp set receive library to newMsglib
        // the new library is valid, but the default library is not
        vm.startPrank(OAPP);
        // initialize the oapp inside the messageLibManager
        endpoint.setReceiveLibrary(OAPP, 2, newMsglib, 0);
        bool isValid = endpoint.isValidReceiveLibrary(OAPP, 2, newMsglib);
        assertTrue(isValid);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, msglib);
        assertFalse(isValid);

        // oapp set the timeout for the msglib before number 15
        // both newMsglib and msglib are valid before number 15
        endpoint.setReceiveLibraryTimeout(OAPP, 2, msglib, 15);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, newMsglib);
        assertTrue(isValid);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, msglib);
        assertTrue(isValid);

        // after number 15, only newMsglib is valid
        vm.roll(15);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, newMsglib);
        assertTrue(isValid);
        isValid = endpoint.isValidReceiveLibrary(OAPP, 2, msglib);
        assertFalse(isValid);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/MessagingChannel.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { AddressCast } from "../contracts/libs/AddressCast.sol";
import { Errors } from "../contracts/libs/Errors.sol";
import { MessagingChannel } from "../contracts/MessagingChannel.sol";

contract MessagingChannelTest is Test, MessagingChannel {
    mapping(address oapp => address delegate) public delegates;

    uint32 internal remoteEid;
    address internal sender;
    bytes32 internal senderB32;
    address internal receiver;
    bytes32 internal receiverB32;
    address internal delegate;

    bytes internal message;
    bytes32 internal guid;
    bytes internal payload;
    bytes32 internal payloadHash;

    constructor() MessagingChannel(1) {
        remoteEid = 1;
        sender = address(0x123);
        senderB32 = AddressCast.toBytes32(sender);
        receiver = address(0x456);
        receiverB32 = AddressCast.toBytes32(receiver);
        delegate = address(0x789);

        message = "foo";
        guid = keccak256("guid");
        payload = abi.encodePacked(guid, message);
        payloadHash = keccak256(payload);
    }

    function test_outbound() public {
        // nonce 1
        uint64 nonce = _outbound(sender, remoteEid, receiverB32);
        assertEq(nonce, 1);
        assertEq(outboundNonce[sender][remoteEid][receiverB32], 1);

        // nonce 2
        nonce = _outbound(sender, remoteEid, receiverB32);
        assertEq(nonce, 2);
        assertEq(outboundNonce[sender][remoteEid][receiverB32], 2);
    }

    function test_Inbound_Revert_InvalidPayloadHash() public {
        // revert due to invalid payload hash
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidPayloadHash.selector));
        _inbound(receiver, remoteEid, senderB32, 1, bytes32(0x0));
    }

    function test_inbound() public {
        _inbound(receiver, remoteEid, senderB32, 1, payloadHash);
        assertTrue(_hasPayloadHash(receiver, remoteEid, senderB32, 1));
        assertEq(inboundPayloadHash[receiver][remoteEid][senderB32][1], payloadHash);
    }

    function test_inboundNonce() public {
        // the initial inbound nonce is 0
        uint64 inBoundNonce = inboundNonce(receiver, remoteEid, senderB32);
        assertEq(inBoundNonce, 0);

        // inbound with nonce 1
        _inbound(receiver, remoteEid, senderB32, 1, payloadHash);
        inBoundNonce = inboundNonce(receiver, remoteEid, senderB32);
        assertEq(inBoundNonce, 1);

        // inbound with nonce 5, but the inbound nonce is still 1
        _inbound(receiver, remoteEid, senderB32, 5, payloadHash);
        inBoundNonce = inboundNonce(receiver, remoteEid, senderB32);
        assertEq(inBoundNonce, 1);

        // inbound with nonce 3, but the inbound nonce is still 1
        _inbound(receiver, remoteEid, senderB32, 3, payloadHash);
        inBoundNonce = inboundNonce(receiver, remoteEid, senderB32);
        assertEq(inBoundNonce, 1);

        // after inbound nonce 2, the inbound nonce is 3
        _inbound(receiver, remoteEid, senderB32, 2, payloadHash);
        inBoundNonce = inboundNonce(receiver, remoteEid, senderB32);
        assertEq(inBoundNonce, 3);

        // after inbound nonce 4, the inbound nonce is 5
        _inbound(receiver, remoteEid, senderB32, 4, payloadHash);
        inBoundNonce = inboundNonce(receiver, remoteEid, senderB32);
        assertEq(inBoundNonce, 5);
    }

    function _test_skip(address _delegate) internal {
        // skip next nonce 1, and the lazyInboundNonce should become 1
        vm.startPrank(_delegate);
        vm.expectEmit(false, false, false, true);
        emit InboundNonceSkipped(remoteEid, senderB32, receiver, 1);
        this.skip(receiver, remoteEid, senderB32, 1);
        assert(lazyInboundNonce[receiver][remoteEid][senderB32] == 1);

        uint64 inboundNonce = this.inboundNonce(receiver, remoteEid, senderB32);
        // fail to skip with an invalid nonce
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, uint64(inboundNonce + 2)));
        this.skip(receiver, remoteEid, senderB32, inboundNonce + 2);
    }

    function test_skip() public {
        _test_skip(receiver);
    }

    function test_skip_delegated() public {
        // Test that the delegate cannot skip before receiver sets delegate
        vm.prank(delegate);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_Unauthorized.selector));
        this.skip(receiver, remoteEid, senderB32, 1);
        // Set delegate
        vm.prank(receiver);
        this.setDelegate(delegate);
        // skip next nonce 1, and the lazyInboundNonce should become 1
        _test_skip(delegate);
    }

    function test_skip_undelegated() public {
        // Set delegate
        vm.prank(receiver);
        this.setDelegate(delegate);
        _test_skip(receiver);
    }

    function _test_nilify(address _delegate) internal {
        vm.startPrank(_delegate);

        // Nilify an unverified nonce should succeed
        uint64 curNonce = 1;
        vm.expectEmit(false, false, false, true);
        emit PacketNilified(
            remoteEid,
            senderB32,
            receiver,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );
        this.nilify(
            receiver,
            remoteEid,
            senderB32,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );

        // Nilify should revert with PayloadHashNotFound if the provided payload hash does not match the contents of inboundPayloadHash
        bytes32 wrongPayloadHash = bytes32(uint256(payloadHash) + 1);
        _inbound(receiver, remoteEid, senderB32, curNonce, payloadHash);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_PayloadHashNotFound.selector, payloadHash, wrongPayloadHash));
        this.nilify(receiver, remoteEid, senderB32, curNonce, wrongPayloadHash);

        // Nilify a verified but non-executed nonce should succeed
        _inbound(receiver, remoteEid, senderB32, curNonce, payloadHash);
        vm.expectEmit(false, false, false, true);
        emit PacketNilified(
            remoteEid,
            senderB32,
            receiver,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );
        this.nilify(
            receiver,
            remoteEid,
            senderB32,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );

        // Nilify an executed nonce should revert with InvalidNonce
        curNonce = 2;
        _inbound(receiver, remoteEid, senderB32, curNonce, payloadHash);
        _clearPayload(receiver, remoteEid, senderB32, curNonce, payload);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, curNonce));
        this.nilify(
            receiver,
            remoteEid,
            senderB32,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );

        uint64 lazyNonce = lazyInboundNonce[receiver][remoteEid][senderB32];
        assertEq(lazyNonce, curNonce);

        // Nilify a non-executed nonce lower than lazyInboundNonce should succeed
        curNonce = 1;
        _inbound(receiver, remoteEid, senderB32, curNonce, payloadHash);
        _clearPayload(receiver, remoteEid, senderB32, curNonce, payload);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, curNonce));
        this.nilify(
            receiver,
            remoteEid,
            senderB32,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );

        // Nilify should work on any nonce greater than lazy inbound nonce
        curNonce = type(uint64).max;
        vm.expectEmit(false, false, false, true);
        emit PacketNilified(
            remoteEid,
            senderB32,
            receiver,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );
        this.nilify(
            receiver,
            remoteEid,
            senderB32,
            curNonce,
            inboundPayloadHash[receiver][remoteEid][senderB32][curNonce]
        );
    }

    function test_nilify() public {
        _test_nilify(receiver);
    }

    function test_nilify_delegated() public {
        vm.prank(delegate);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_Unauthorized.selector));
        this.nilify(receiver, remoteEid, senderB32, 1, inboundPayloadHash[receiver][remoteEid][senderB32][1]);
        vm.prank(receiver);
        this.setDelegate(delegate);
        _test_nilify(delegate);
    }

    function test_nilify_undelegated() public {
        vm.prank(receiver);
        this.setDelegate(delegate);
        _test_nilify(receiver);
    }

    function _test_burn(address _delegate) internal {
        /*
        1        | 2        | 3         | 4
        verified | executed | executed  | verified
                 |          | lazyNonce |
        */
        vm.startPrank(_delegate);

        for (uint64 _nonce = 1; _nonce <= 4; ++_nonce) {
            _inbound(receiver, remoteEid, senderB32, _nonce, payloadHash);
        }
        uint64 lazyNonce = 3;
        _clearPayload(receiver, remoteEid, senderB32, lazyNonce - 1, payload);
        _clearPayload(receiver, remoteEid, senderB32, lazyNonce, payload);
        assertEq(lazyNonce, this.lazyInboundNonce(receiver, remoteEid, senderB32));

        // Burn should revert with InvalidNonce if the requested nonce is greater than lazyInboundNonce
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, lazyNonce + 1));
        this.burn(receiver, remoteEid, senderB32, lazyNonce + 1, payloadHash);

        // Burn should revert with InvalidNonce if the payload hash of the requested nonce is 0x0
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, lazyNonce - 1));
        this.burn(receiver, remoteEid, senderB32, lazyNonce - 1, EMPTY_PAYLOAD_HASH);

        // Burn should revert with PayloadHashNotFound if the provided payload hash does not match the contents of inboundPayloadHash
        bytes32 wrongPayloadHash = bytes32(uint256(payloadHash) + 1);
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_PayloadHashNotFound.selector, payloadHash, wrongPayloadHash));
        this.burn(receiver, remoteEid, senderB32, 1, wrongPayloadHash);

        // Burn a verified but non-executed nonce should succeed
        vm.expectEmit(false, false, false, true);
        emit PacketBurnt(remoteEid, senderB32, receiver, 1, payloadHash);
        this.burn(receiver, remoteEid, senderB32, 1, payloadHash);
        assertFalse(_hasPayloadHash(receiver, remoteEid, senderB32, 1));
    }

    function test_burn() public {
        _test_burn(receiver);
    }

    function test_burn_delegated() public {
        vm.prank(delegate);
        vm.expectRevert(Errors.LZ_Unauthorized.selector);
        this.burn(receiver, remoteEid, senderB32, 1, inboundPayloadHash[receiver][remoteEid][senderB32][1]);
        vm.prank(receiver);
        this.setDelegate(delegate);
        _test_burn(delegate);
    }

    function test_burn_undelegated() public {
        vm.prank(receiver);
        this.setDelegate(delegate);
        _test_burn(receiver);
    }

    function test_clear() public {
        // verify nonce 1, 2, 4
        _inbound(receiver, remoteEid, senderB32, 1, payloadHash);
        _inbound(receiver, remoteEid, senderB32, 2, payloadHash);
        _inbound(receiver, remoteEid, senderB32, 4, payloadHash);

        // try to clear nonce 4 but fails due to nonce 3 not inbounded
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, uint64(3)));
        _clearPayload(receiver, remoteEid, senderB32, 4, payload);

        // clear nonce 2 successfully
        _clearPayload(receiver, remoteEid, senderB32, 2, payload);

        // verify nonce 3
        _inbound(receiver, remoteEid, senderB32, 3, payloadHash);

        // clear nonce 4 successfully
        _clearPayload(receiver, remoteEid, senderB32, 4, payload);
    }

    function test_clearInvalidPayload() public {
        // verify nonce 1;
        _inbound(receiver, remoteEid, senderB32, 1, payloadHash);

        // reverts due to wrong message
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_PayloadHashNotFound.selector, payloadHash, keccak256("bar")));
        _clearPayload(receiver, remoteEid, senderB32, 1, "bar"); // wrong message
    }

    function test_clearTwice() public {
        // verify nonce 1;
        _inbound(receiver, remoteEid, senderB32, 1, payloadHash);

        // clears successfully
        _clearPayload(receiver, remoteEid, senderB32, 1, payload);

        // reverts due to already cleared
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_PayloadHashNotFound.selector, bytes32(0x0), payloadHash));
        _clearPayload(receiver, remoteEid, senderB32, 1, payload);
    }

    function test_nextGuid() public {
        address senderAddr = address(this);
        bytes32 expectedGuid = keccak256(
            abi.encodePacked(uint64(1), eid, AddressCast.toBytes32(senderAddr), remoteEid, receiverB32)
        );
        bytes32 actualGuid = this.nextGuid(senderAddr, remoteEid, receiverB32);
        assertEq(actualGuid, expectedGuid);
    }

    function setDelegate(address _delegate) public {
        delegates[msg.sender] = _delegate;
    }

    function _assertAuthorized(address _oapp) internal view override {
        if (msg.sender != _oapp && msg.sender != delegates[_oapp]) revert Errors.LZ_Unauthorized();
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/MessagingComposer.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Errors } from "../contracts/libs/Errors.sol";

import { LayerZeroTest } from "./utils/LayerZeroTest.sol";
import { OAppMock, ComposerMock } from "./mocks/AppMock.sol";
import { IMessagingComposer } from "../contracts/interfaces/IMessagingComposer.sol";

contract MessagingComposerTest is LayerZeroTest {
    address internal oapp;
    address internal composer;
    bytes32 internal guid;
    bytes internal message;

    function setUp() public override {
        super.setUp();
        oapp = address(new OAppMock(address(endpoint)));
        composer = OAppMock(oapp).composer();
        guid = keccak256("guid");
        message = bytes("foobar");
    }

    function test_sendCompose() public {
        vm.startPrank(oapp);

        vm.expectEmit(false, false, false, true, address(endpoint));
        emit IMessagingComposer.ComposeSent(oapp, composer, guid, 0, message);
        endpoint.sendCompose(composer, guid, 0, message);
        assertEq(endpoint.composeQueue(oapp, composer, guid, 0), keccak256(message));

        // revert due to sending same message
        vm.expectRevert(Errors.LZ_ComposeExists.selector);
        endpoint.sendCompose(composer, guid, 0, message);
    }

    function test_lzCompose() public {
        // send composed message
        vm.prank(oapp);
        endpoint.sendCompose(composer, guid, 0, message);

        // lzCompose and clear composed message
        vm.expectEmit(false, false, false, true, address(endpoint));
        emit IMessagingComposer.ComposeDelivered(oapp, composer, guid, 0);
        endpoint.lzCompose(oapp, composer, guid, 0, message, bytes(""));
        assertEq(endpoint.composeQueue(oapp, composer, guid, 0), bytes32(uint256(1))); // message marked as sent
        assertEq(ComposerMock(composer).count(), 1);

        // cant resend message even if it is marked as sent
        vm.expectRevert(Errors.LZ_ComposeExists.selector);
        vm.prank(oapp);
        endpoint.sendCompose(composer, guid, 0, message);
    }

    function test_lzComposeFail() public {
        vm.prank(address(oapp));
        bytes memory invalidMsg = bytes("Invalid message");
        endpoint.sendCompose(composer, guid, 0, invalidMsg);

        // fund the executor
        address executor = address(0xdead);
        vm.deal(executor, 100);
        vm.prank(executor);

        // mock the executor call the lzCompose() with 100 value
        // fail to receive due to app revert when the message is not "foobar"
        // payload should not be cleared and refund the value
        vm.expectRevert();
        endpoint.lzCompose{ value: 100 }(oapp, composer, guid, 0, invalidMsg, bytes(""));
        assertEq(endpoint.composeQueue(oapp, composer, guid, 0), keccak256(invalidMsg));
        assertEq(address(executor).balance, 100);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/MessagingContext.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { MessagingContext } from "../contracts/MessagingContext.sol";

contract MessagingContextTest is Test, MessagingContext {
    function test_sendContext() public {
        // send context
        send(1, address(0x123));

        // no send context after send()
        assertFalse(isSendingMessage());
        (uint32 dstEid, address sender) = this.getSendContext();
        assertEq(dstEid, 0);
        assertEq(sender, address(0));
    }

    function send(uint32 _dstEid, address _sender) public sendContext(_dstEid, _sender) {
        assertTrue(isSendingMessage());
        (uint32 dstEid, address sender) = this.getSendContext();
        assertEq(dstEid, _dstEid);
        assertEq(sender, _sender);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/libtests/AddressCast.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { AddressCast } from "../../contracts/libs/AddressCast.sol";

contract AddressCastTest is Test {
    AddressCastWrapper internal addressCastWrapper;

    function setUp() public {
        addressCastWrapper = new AddressCastWrapper();
    }

    function test_Bytes_ToBytes32() public {
        bytes memory bytesAddress = abi.encodePacked(address(0x1));
        bytes32 bytes32Address = addressCastWrapper.toBytes32(bytesAddress);
        assertEq(bytes32Address, bytes32(uint256(0x1)), "should be equal");
    }

    function test_Revert_Bytes_ToBytes32_IfGt32Bytes() public {
        bytes memory bytesAddress = abi.encodePacked(address(0x1), address(0x2));
        vm.expectRevert(AddressCast.AddressCast_InvalidAddress.selector);
        addressCastWrapper.toBytes32(bytesAddress);
    }

    function test_Address_ToBytes32() public {
        bytes32 bytes32Address = AddressCast.toBytes32(address(0x1));
        assertEq(bytes32Address, bytes32(uint256(0x1)), "should be equal");
    }

    function test_ToBytes() public {
        bytes32 bytes32Address = bytes32(uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
        bytes memory bytesAddress = AddressCast.toBytes(bytes32Address, 20);
        assertEq(bytesAddress, abi.encodePacked(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF), "should be equal");

        bytesAddress = AddressCast.toBytes(bytes32Address, 1);
        assertEq(bytesAddress, abi.encodePacked(uint8(0xff)), "should be equal");

        bytesAddress = AddressCast.toBytes(bytes32Address, 2);
        assertEq(bytesAddress, abi.encodePacked(uint16(0xffff)), "should be equal");

        bytesAddress = AddressCast.toBytes(bytes32Address, 32);
        assertEq(
            bytesAddress,
            abi.encodePacked(uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)),
            "should be equal"
        );
    }

    function test_Revert_ToBytes_IfSizeGt32() public {
        bytes32 bytes32Address = bytes32(
            uint256(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffff)
        );
        vm.expectRevert(AddressCast.AddressCast_InvalidSizeForAddress.selector);
        AddressCast.toBytes(bytes32Address, 33);
    }

    function test_Revert_ToBytes_IfSizeEq0() public {
        bytes32 bytes32Address = bytes32(
            uint256(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffff)
        );
        vm.expectRevert(AddressCast.AddressCast_InvalidSizeForAddress.selector);
        AddressCast.toBytes(bytes32Address, 0);
    }

    function test_Bytes_ToAddress() public {
        bytes memory bytesAddress = abi.encodePacked(address(0x1));
        address addressAddress = addressCastWrapper.toAddress(bytesAddress);
        assertEq(addressAddress, address(0x1), "should be equal");
    }

    function test_Bytes32_ToAddress() public {
        bytes32 bytes32Address = bytes32(uint256(0x1));
        address addressAddress = AddressCast.toAddress(bytes32Address);
        assertEq(addressAddress, address(0x1), "should be equal");
    }
}

contract AddressCastWrapper {
    function toBytes32(bytes calldata _addressBytes) public pure returns (bytes32) {
        return AddressCast.toBytes32(_addressBytes);
    }

    function toAddress(bytes calldata _addressBytes) public pure returns (address result) {
        return AddressCast.toAddress(_addressBytes);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/libtests/BitMaps.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { BitMap256, BitMaps } from "../../contracts/messagelib/libs/BitMaps.sol";

contract BitMapsTest is Test {
    function test_set(uint8 keyA, uint8 keyB, uint8 keyC) public {
        vm.assume(keyA != keyB && keyA != keyC && keyB != keyC);

        BitMap256 bitmap;

        bitmap = BitMaps.set(bitmap, keyA);
        bitmap = BitMaps.set(bitmap, keyB);
        assertEq(BitMaps.get(bitmap, keyA), true);
        assertEq(BitMaps.get(bitmap, keyB), true);
        assertEq(BitMaps.get(bitmap, keyC), false);
    }

    function test_set0() public {
        BitMap256 bitmap;
        assertFalse(BitMaps.get(bitmap, 0));
        bitmap = BitMaps.set(bitmap, 0);
        assertTrue(BitMaps.get(bitmap, 0));
    }

    function test_setMax() public {
        BitMap256 bitmap;
        assertFalse(BitMaps.get(bitmap, type(uint8).max));
        bitmap = BitMaps.set(bitmap, type(uint8).max);
        assertTrue(BitMaps.get(bitmap, type(uint8).max));
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/libtests/CalldataBytesLib.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { CalldataBytesLib } from "../../contracts/libs/CalldataBytesLib.sol";

contract CalldataBytesLibTest is Test {
    bytes internal constant BYTES = hex"1234567890123456789012345678901234567890123456789012345678901234567890";

    function test_toU8() public {
        uint8 v = CalldataBytesLibWrapper.toU8(BYTES, 0);
        assertEq(v, uint8(0x12));
    }

    function test_toU16() public {
        uint16 v = CalldataBytesLibWrapper.toU16(BYTES, 0);
        assertEq(v, uint16(0x1234));
    }

    function test_toU32() public {
        uint32 v = CalldataBytesLibWrapper.toU32(BYTES, 0);
        assertEq(v, uint32(0x12345678));
    }

    function test_toU64() public {
        uint64 v = CalldataBytesLibWrapper.toU64(BYTES, 0);
        assertEq(v, uint64(0x1234567890123456));
    }

    function test_toU128() public {
        uint128 v = CalldataBytesLibWrapper.toU128(BYTES, 0);
        assertEq(v, uint128(0x12345678901234567890123456789012));
    }

    function test_toU256() public {
        uint256 v = CalldataBytesLibWrapper.toU256(BYTES, 0);
        assertEq(v, uint256(0x1234567890123456789012345678901234567890123456789012345678901234));
    }

    function test_toAddr() public {
        address v = CalldataBytesLibWrapper.toAddr(BYTES, 0);
        assertEq(v, address(0x1234567890123456789012345678901234567890));
    }

    function test_toB32() public {
        bytes32 v = CalldataBytesLibWrapper.toB32(BYTES, 0);
        assertEq(v, bytes32(0x1234567890123456789012345678901234567890123456789012345678901234));
    }
}

/// @dev A wrapper of CalldataBytesLibWrapper to expose internal functions for calldata params
library CalldataBytesLibWrapper {
    function toU8(bytes calldata _bytes, uint256 _start) external pure returns (uint8) {
        return CalldataBytesLib.toU8(_bytes, _start);
    }

    function toU16(bytes calldata _bytes, uint256 _start) external pure returns (uint16) {
        return CalldataBytesLib.toU16(_bytes, _start);
    }

    function toU32(bytes calldata _bytes, uint256 _start) external pure returns (uint32) {
        return CalldataBytesLib.toU32(_bytes, _start);
    }

    function toU64(bytes calldata _bytes, uint256 _start) external pure returns (uint64) {
        return CalldataBytesLib.toU64(_bytes, _start);
    }

    function toU128(bytes calldata _bytes, uint256 _start) external pure returns (uint128) {
        return CalldataBytesLib.toU128(_bytes, _start);
    }

    function toU256(bytes calldata _bytes, uint256 _start) external pure returns (uint256) {
        return CalldataBytesLib.toU256(_bytes, _start);
    }

    function toAddr(bytes calldata _bytes, uint256 _start) external pure returns (address) {
        return CalldataBytesLib.toAddr(_bytes, _start);
    }

    function toB32(bytes calldata _bytes, uint256 _start) external pure returns (bytes32) {
        return CalldataBytesLib.toB32(_bytes, _start);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/libtests/ExecutorOptions.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { ExecutorOptions } from "../../contracts/messagelib/libs/ExecutorOptions.sol";

contract ExecutorOptionsTest is Test {
    function test_nextExecutorOption() public {
        bytes memory option = ExecutorOptions.encodeLzReceiveOption(1, 2);
        bytes memory options = abi.encodePacked(
            ExecutorOptions.WORKER_ID,
            uint16(option.length + 1), // option type + option length
            ExecutorOptions.OPTION_TYPE_LZRECEIVE,
            option
        );

        (uint8 optionType, bytes memory actualOption, uint256 cursor) = ExecutorOptionsWrapper.nextExecutorOption(
            options,
            0
        );
        assertEq(optionType, ExecutorOptions.OPTION_TYPE_LZRECEIVE);
        assertEq(actualOption, option);
        assertEq(cursor, options.length);
    }

    function test_lzReceiveOption() public {
        bytes memory option = ExecutorOptions.encodeLzReceiveOption(1, 0);
        assertEq(option.length, 16);

        (uint128 gas, uint128 value) = ExecutorOptionsWrapper.decodeLzReceiveOption(option);
        assertEq(gas, 1);
        assertEq(value, 0);

        option = ExecutorOptions.encodeLzReceiveOption(1, 2);
        assertEq(option.length, 32);

        (gas, value) = ExecutorOptionsWrapper.decodeLzReceiveOption(option);
        assertEq(gas, 1);
        assertEq(value, 2);
    }

    function test_nativeDropOption() public {
        bytes memory option = ExecutorOptions.encodeNativeDropOption(1, bytes32(uint256(0x1234)));
        assertEq(option.length, 48);

        (uint128 value, bytes32 receiver) = ExecutorOptionsWrapper.decodeNativeDropOption(option);
        assertEq(value, 1);
        assertEq(receiver, bytes32(uint256(0x1234)));
    }

    function test_lzComposeOption() public {
        bytes memory option = ExecutorOptions.encodeLzComposeOption(0, 1, 0);
        assertEq(option.length, 18);

        (uint16 index, uint128 gas, uint128 value) = ExecutorOptionsWrapper.decodeLzComposeOption(option);
        assertEq(index, 0);
        assertEq(gas, 1);
        assertEq(value, 0);

        option = ExecutorOptions.encodeLzComposeOption(0, 1, 2);
        assertEq(option.length, 34);

        (index, gas, value) = ExecutorOptionsWrapper.decodeLzComposeOption(option);
        assertEq(index, 0);
        assertEq(gas, 1);
        assertEq(value, 2);
    }
}

library ExecutorOptionsWrapper {
    function nextExecutorOption(
        bytes calldata _options,
        uint256 _cursor
    ) external pure returns (uint8 optionType, bytes memory option, uint256 cursor) {
        return ExecutorOptions.nextExecutorOption(_options, _cursor);
    }

    function decodeLzReceiveOption(bytes calldata _option) external pure returns (uint128 gas, uint128 value) {
        return ExecutorOptions.decodeLzReceiveOption(_option);
    }

    function decodeNativeDropOption(bytes calldata _option) external pure returns (uint128 amount, bytes32 receiver) {
        return ExecutorOptions.decodeNativeDropOption(_option);
    }

    function decodeLzComposeOption(
        bytes calldata _option
    ) external pure returns (uint16 index, uint128 gas, uint128 value) {
        return ExecutorOptions.decodeLzComposeOption(_option);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/libtests/PacketV1Codec.t.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { Packet } from "../../contracts/interfaces/ISendLib.sol";
import { AddressCast } from "../../contracts/libs/AddressCast.sol";
import { PacketV1Codec } from "../../contracts/messagelib/libs/PacketV1Codec.sol";

contract PacketV1CodecTest is Test {
    uint64 internal nonce;
    uint32 internal srcEid;
    address internal sender;
    uint32 internal dstEid;
    bytes32 internal receiver;
    bytes32 internal guid;
    bytes internal message;

    bytes internal encodedPacket;

    function setUp() public {
        nonce = 1;
        srcEid = 2;
        sender = address(0x123);
        dstEid = 3;
        receiver = AddressCast.toBytes32(address(0x456));
        guid = bytes32(uint256(0x789));
        message = hex"aabbcc";

        Packet memory packet = Packet(nonce, srcEid, sender, dstEid, receiver, guid, message);
        encodedPacket = PacketV1Codec.encode(packet);
    }

    function test_header() public {
        bytes memory header = PacketV1CodecWrapper.header(encodedPacket);
        bytes memory expectedHeader = abi.encodePacked(
            PacketV1Codec.PACKET_VERSION,
            nonce,
            srcEid,
            AddressCast.toBytes32(sender),
            dstEid,
            receiver
        );
        assertEq(header, expectedHeader);
    }

    function test_version() public {
        uint8 v = PacketV1CodecWrapper.version(encodedPacket);
        assertEq(PacketV1Codec.PACKET_VERSION, v);
    }

    function test_nonce() public {
        uint64 n = PacketV1CodecWrapper.nonce(encodedPacket);
        assertEq(nonce, n);
    }

    function test_srcEid() public {
        uint32 eid = PacketV1CodecWrapper.srcEid(encodedPacket);
        assertEq(srcEid, eid);
    }

    function test_sender() public {
        bytes32 s = PacketV1CodecWrapper.sender(encodedPacket);
        assertEq(sender, AddressCast.toAddress(s));
    }

    function test_senderAddressB20() public {
        address s = PacketV1CodecWrapper.senderAddressB20(encodedPacket);
        assertEq(sender, s);
    }

    function test_dstEid() public {
        uint32 eid = PacketV1CodecWrapper.dstEid(encodedPacket);
        assertEq(dstEid, eid);
    }

    function test_receiver() public {
        bytes32 r = PacketV1CodecWrapper.receiver(encodedPacket);
        assertEq(receiver, r);
    }

    function test_receiverB20() public {
        address r = PacketV1CodecWrapper.receiverB20(encodedPacket);
        assertEq(receiver, AddressCast.toBytes32(r));
    }

    function test_guid() public {
        bytes32 id = PacketV1CodecWrapper.guid(encodedPacket);
        assertEq(guid, id);
    }

    function test_message() public {
        bytes memory m = PacketV1CodecWrapper.message(encodedPacket);
        assertEq(message, m);
    }

    function test_payload() public {
        bytes memory expectedPayload = abi.encodePacked(guid, message);
        bytes memory payload = PacketV1CodecWrapper.payload(encodedPacket);
        assertEq(payload, expectedPayload);
    }
}

/// @dev A wrapper of PacketV1Codec to expose internal functions for calldata params
library PacketV1CodecWrapper {
    using PacketV1Codec for bytes;

    function header(bytes calldata _encodedPacket) external pure returns (bytes memory) {
        return _encodedPacket.header();
    }

    function version(bytes calldata _encodedPacket) external pure returns (uint8) {
        return _encodedPacket.version();
    }

    function nonce(bytes calldata _encodedPacket) external pure returns (uint64) {
        return _encodedPacket.nonce();
    }

    function srcEid(bytes calldata _encodedPacket) external pure returns (uint32) {
        return _encodedPacket.srcEid();
    }

    function sender(bytes calldata _encodedPacket) external pure returns (bytes32) {
        return _encodedPacket.sender();
    }

    function senderAddressB20(bytes calldata _encodedPacket) external pure returns (address) {
        return _encodedPacket.senderAddressB20();
    }

    function dstEid(bytes calldata _encodedPacket) external pure returns (uint32) {
        return _encodedPacket.dstEid();
    }

    function receiver(bytes calldata _encodedPacket) external pure returns (bytes32) {
        return _encodedPacket.receiver();
    }

    function receiverB20(bytes calldata _encodedPacket) external pure returns (address) {
        return _encodedPacket.receiverB20();
    }

    function guid(bytes calldata _encodedPacket) external pure returns (bytes32) {
        return _encodedPacket.guid();
    }

    function message(bytes calldata _encodedPacket) external pure returns (bytes memory) {
        return _encodedPacket.message();
    }

    function payload(bytes calldata _encodedPacket) external pure returns (bytes memory) {
        return _encodedPacket.payload();
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/mocks/AppMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ILayerZeroEndpointV2, Origin } from "../../contracts/interfaces/ILayerZeroEndpointV2.sol";
import { ILayerZeroComposer } from "../../contracts/interfaces/ILayerZeroComposer.sol";
import { ILayerZeroReceiver } from "../../contracts/interfaces/ILayerZeroReceiver.sol";

// demonstrate how to external apps (bar) compose layerzero apps (foo)
// source: bar calls foo.send()
// destination: foo received the message and execute a trailing call
contract OAppMock is ILayerZeroReceiver {
    error InvalidMessage();

    bytes public constant FOO_MESSAGE = "foo";
    bytes public constant BAR_MESSAGE = "bar";

    address public immutable endpoint;
    address public immutable composer;

    mapping(uint32 => mapping(bytes32 => bool)) public pathwayBlacklist;

    constructor(address _endpoint) {
        endpoint = _endpoint;
        composer = address(new ComposerMock(address(this)));
    }

    function lzReceive(
        Origin calldata /*_origin*/,
        bytes32 _guid,
        bytes calldata _message,
        address /*_executor*/,
        bytes calldata /*_extraData*/
    ) public payable {
        if (keccak256(_message) != keccak256(FOO_MESSAGE)) {
            revert InvalidMessage();
        }

        bytes memory message = bytes.concat(_message, BAR_MESSAGE);
        ILayerZeroEndpointV2(endpoint).sendCompose(composer, _guid, 0, message);
    }

    function allowInitializePath(Origin calldata _origin) public view override returns (bool) {
        return !pathwayBlacklist[_origin.srcEid][_origin.sender];
    }

    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public pure override returns (uint64) {
        return 0;
    }

    function blacklistPathway(uint32 _srcEid, bytes32 _sender) public {
        pathwayBlacklist[_srcEid][_sender] = true;
    }

    function unBlacklistPathway(uint32 _srcEid, bytes32 _sender) public {
        pathwayBlacklist[_srcEid][_sender] = false;
    }
}

contract ComposerMock is ILayerZeroComposer {
    error InvalidMessage();
    error InvalidOApp();

    address public immutable oapp;
    uint256 public count;

    constructor(address _oapp) {
        oapp = _oapp;
    }

    function lzCompose(
        address _oapp,
        bytes32 /*_guid*/,
        bytes calldata _message,
        address,
        bytes calldata
    ) external payable override {
        if (_oapp != address(oapp)) {
            revert InvalidOApp();
        }

        if (keccak256(_message) != keccak256("foobar")) {
            revert InvalidMessage();
        }
        count += 1;
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/mocks/MessageLibMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ERC165 } from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import { MessageLibType } from "../../contracts/interfaces/IMessageLib.sol";

contract MessageLibMock is ERC165 {
    bool internal isSupported;

    constructor(bool _isSupported) {
        isSupported = _isSupported;
    }

    function supportsInterface(bytes4) public view override returns (bool) {
        return isSupported;
    }

    function isSupportedEid(uint32 _eid) external pure returns (bool) {
        return _eid != type(uint32).max;
    }

    function messageLibType() external pure returns (MessageLibType) {
        return MessageLibType.SendAndReceive;
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/mocks/TokenMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TokenMock is ERC20 {
    constructor(uint256 amount) ERC20("token", "tkn") {
        _mint(msg.sender, amount);
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/mocks/TreasuryMock.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

contract TreasuryMock is Ownable {
    function withdraw() external onlyOwner {
        //withdraw
    }

    function withdrawAlt() external onlyOwner {
        //withdraw token
    }
}


================================================================================
File: packages/layerzero-v2/evm/protocol/test/utils/LayerZeroTest.sol
================================================================================

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import { Test } from "forge-std/Test.sol";

import { Packet } from "../../contracts/interfaces/ISendLib.sol";
import { AddressCast } from "../../contracts/libs/AddressCast.sol";
import { PacketV1Codec } from "../../contracts/messagelib/libs/PacketV1Codec.sol";
import { SimpleMessageLib } from "../../contracts/messagelib/SimpleMessageLib.sol";
import { EndpointV2 } from "../../contracts/EndpointV2.sol";
import { EndpointV2Alt } from "../../contracts/EndpointV2Alt.sol";

import { TreasuryMock } from "../mocks/TreasuryMock.sol";

contract LayerZeroTest is Test {
    uint32 internal localEid;
    uint32 internal remoteEid;
    EndpointV2 internal endpoint;
    SimpleMessageLib internal simpleMsgLib;
    address internal blockedLibrary;

    function setUp() public virtual {
        localEid = 1;
        remoteEid = 2;
        (endpoint, simpleMsgLib) = setupEndpointWithSimpleMsgLib(localEid);
        setDefaultMsgLib(endpoint, address(simpleMsgLib), remoteEid);
        blockedLibrary = endpoint.blockedLibrary();
    }

    function setUpEndpoint(uint32 _eid) public returns (EndpointV2) {
        return new EndpointV2(_eid, address(this));
    }

    function setupEndpointAlt(uint32 _eid, address _altToken) public returns (EndpointV2Alt) {
        return new EndpointV2Alt(_eid, address(this), _altToken);
    }

    function setupEndpointWithSimpleMsgLib(uint32 _eid) public returns (EndpointV2, SimpleMessageLib) {
        EndpointV2 e = setUpEndpoint(_eid);

        TreasuryMock treasuryMock = new TreasuryMock();
        SimpleMessageLib msgLib = new SimpleMessageLib(address(e), address(treasuryMock));

        // register msg lib
        e.registerLibrary(address(msgLib));

        return (e, msgLib);
    }

    function setupSimpleMessageLib(
        address _endpoint,
        uint32 _remoteEid,
        bool _isDefault
    ) public returns (SimpleMessageLib) {
        TreasuryMock treasuryMock = new TreasuryMock();
        SimpleMessageLib msgLib = new SimpleMessageLib(_endpoint, address(treasuryMock));

        EndpointV2 endPoint = EndpointV2(_endpoint);
        endPoint.registerLibrary(address(msgLib));

        if (_isDefault) setDefaultMsgLib(endPoint, address(msgLib), _remoteEid);

        return msgLib;
    }

    function setDefaultMsgLib(EndpointV2 _endpoint, address _msglib, uint32 _remoteEid) public {
        _endpoint.setDefaultSendLibrary(_remoteEid, _msglib);
        _endpoint.setDefaultReceiveLibrary(_remoteEid, _msglib, 0);
    }

    function newPacket(
        uint64 _nonce,
        uint32 _srcEid,
        address _sender,
        uint32 _dstEid,
        bytes32 _receiver,
        bytes memory _message
    ) public pure returns (Packet memory) {
        bytes32 guid = keccak256(abi.encodePacked(_nonce, _srcEid, AddressCast.toBytes32(_sender), _dstEid, _receiver));
        return Packet(_nonce, _srcEid, _sender, _dstEid, _receiver, guid, _message);
    }

    function newAndEncodePacket(
        uint64 _nonce,
        uint32 _srcEid,
        address _sender,
        uint32 _dstEid,
        bytes32 _receiver,
        bytes memory _message
    ) public pure returns (bytes memory) {
        Packet memory packet = newPacket(_nonce, _srcEid, _sender, _dstEid, _receiver, _message);
        return PacketV1Codec.encode(packet);
    }
}

